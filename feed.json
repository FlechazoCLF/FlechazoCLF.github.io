{
    "version": "https://jsonfeed.org/version/1",
    "title": "我在人间贩卖黄昏，只为收集世间温柔遇见你.",
    "subtitle": "有幸来到人间的旅人",
    "icon": "https://flechazoclf.github.io/FlechazoCLF.github.io/images/favicon.ico",
    "description": "我在人间贩卖星光",
    "home_page_url": "https://FlechazoCLF.github.io/FlechazoCLF.github.io",
    "items": [
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html",
            "title": "小柴带你学AutoSar系列三、标准和规范篇（4）RTE",
            "date_published": "2024-10-31T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴带你学autosar系列三-标准和规范篇4rte\"><a class=\"anchor\" href=\"#小柴带你学autosar系列三-标准和规范篇4rte\">#</a> 小柴带你学 AutoSar 系列三、标准和规范篇（4）RTE</h1>\n<h1 id=\"1-introduction\"><a class=\"anchor\" href=\"#1-introduction\">#</a> <strong>1 Introduction</strong></h1>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801140814168.png\" alt=\"image-20240801140814168\"></p>\n<blockquote>\n<p>This document contains the software specification of the AUTOSAR Run-Time Environment (<em>RTE</em>) and the <em>Basic Software Scheduler</em>. Basically, the RTE together with the OS, AUTOSAR COM and other Basic Software Modules is the implementation of the Virtual Functional Bus concepts (<em>VFB</em>, [1]). The RTE implements the AUTOSAR Virtual Functional Bus interfaces and thereby realizes the communication between AUTOSAR software-components.</p>\n</blockquote>\n<p>RTE 是通信的接口</p>\n<blockquote>\n<p>This document describes how these concepts are realized within the RTE. Further more, the Application Programming Interface (<em>API</em>) of the RTE and the interaction of the RTE with other basic software modules is specified.</p>\n<p>The <em>Basic Software Scheduler</em> offers concepts and services to integrate Basic Software Modules Hence, the <em>Basic Software Scheduler</em></p>\n<ul>\n<li>embed <em>Basic Software Module</em> implementations into the AUTOSAR OS context</li>\n<li>trigger main processing functions of the <em>Basic Software Module</em>s</li>\n<li>apply data consistency mechanisms for the <em>Basic Software Module</em>s</li>\n<li>to communicate modes between <em>Basic Software Module</em>s</li>\n</ul>\n</blockquote>\n<p>在 OS 中嵌入基础软件</p>\n<p>触发主处理函数</p>\n<p>数据一致性的机制</p>\n<p>基础软件之间的通信模式</p>\n<h1 id=\"2-rte-overview\"><a class=\"anchor\" href=\"#2-rte-overview\">#</a> <strong>2 RTE Overview</strong></h1>\n<h2 id=\"21-the-rte-in-the-context-of-autosar\"><a class=\"anchor\" href=\"#21-the-rte-in-the-context-of-autosar\">#</a> 2.1 The RTE in the Context of AUTOSAR</h2>\n<blockquote>\n<p>In principle the RTE can be logically divided into two sub-parts realizing:</p>\n<ul>\n<li>the communication between software components</li>\n<li>the scheduling of the software components</li>\n</ul>\n</blockquote>\n<p>软件组件的通信</p>\n<p>软件组件的调度</p>\n<h2 id=\"22-autosar-concepts\"><a class=\"anchor\" href=\"#22-autosar-concepts\">#</a> <strong>2.2</strong> AUTOSAR Concepts</h2>\n<h3 id=\"221-autosar-software-components\"><a class=\"anchor\" href=\"#221-autosar-software-components\">#</a> <strong>2.2.1</strong> AUTOSAR Software-components</h3>\n<blockquote>\n<p>In AUTOSAR, “application” software is conceptually located above the AUTOSAR RTE and consists of “AUTOSAR application software-components” that are ECU and location independent and “AUTOSAR sensor-actuator components” that are dependent on ECU hardware and thus not readily relocatable for reasons of performance/efficiency.</p>\n<p>This means that, subject to constraints imposed by the system designer, an AUTOSAR software-component can be deployed to any available ECU during system configuration. The RTE is then responsible for ensuring that components can communicate and that the system continues to function as expected wherever the components are deployed.</p>\n</blockquote>\n<p>也就是说为了解耦，软件组件可以部署到任意位置，耦合的地方由 RTE 实现通信 / 调度。</p>\n<h3 id=\"222-basic-software-modules\"><a class=\"anchor\" href=\"#222-basic-software-modules\">#</a> <strong>2.2.2</strong> Basic Software Modules</h3>\n<blockquote>\n<p>As well as “AUTOSAR software-components” an AUTOSAR ECU includes basic software modules. Basic software modules can access the ECU abstraction layer as well as other basic software modules directly and are thus neither ECU nor location independent.</p>\n</blockquote>\n<p>BSW 可以访问 ECU 抽象以及其他模块的硬件抽象。</p>\n<blockquote>\n<p>An “AUTOSAR software-component” <em>cannot</em> directly access basic software modules – all communication is via AUTOSAR interfaces and therefore under the control of the RTE. The requirement to not have direct access applies to all <em>Basic Software Modules</em> including the operating system [SRS_Rte_00020] and the communication service.</p>\n</blockquote>\n<p>SWC 不可以直接访问 BSW，需要通过 RTE</p>\n<h3 id=\"223-communication\"><a class=\"anchor\" href=\"#223-communication\">#</a> <strong>2.2.3</strong> Communication</h3>\n<p>通信是通过 port 来进行的，具体请看<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83MDk5OTU4NTE=\">二、VFB 虚拟功能总线</span></p>\n<blockquote>\n<p>The RTE provides different paradigms for the communication between software component instances: sender-receiver (signal passing), client-server (function invocation), mode switch, and NvBlockSwComponentType interaction.</p>\n</blockquote>\n<h4 id=\"支持的通信方式\"><a class=\"anchor\" href=\"#支持的通信方式\">#</a> 支持的通信方式</h4>\n<ul>\n<li>sender-receiver (signal passing)</li>\n<li>client-server (function invocation)</li>\n<li>mode switch</li>\n<li>NvBlockSwComponentType interaction</li>\n</ul>\n<h4 id=\"communication-paradigms\"><a class=\"anchor\" href=\"#communication-paradigms\">#</a> <strong>Communication Paradigms</strong></h4>\n<blockquote>\n<p>Inter-Partition communication occurs between runnable entities in components mapped to different partitions of the same ECU and therefore involve a context switch and crossing a protection boundary (memory protection, timing protection, isolation on a core). Inter-ECU communication occurs between runnable entities in components that have been mapped to different ECUs and so is inherently concurrent and involves potentially unreliable communication.</p>\n</blockquote>\n<p>要作到可靠的通信会涉及几个问题</p>\n<ul>\n<li>memory protection</li>\n<li>timing protection</li>\n<li>isolation on a core</li>\n</ul>\n<h4 id=\"communication-modes\"><a class=\"anchor\" href=\"#communication-modes\">#</a> <strong>Communication Modes</strong></h4>\n<blockquote>\n<p>The RTE supports two modes for sender-receiver communication:</p>\n<ul>\n<li><strong>Explicit</strong> — A component uses explicit RTE API calls to send and receive data elements [SRS_Rte_00098].</li>\n<li><strong>Implicit</strong> — The RTE automatically reads a specified set of data elements before a runnable is invoked and automatically writes (a different) set of data elements after the runnable entity has terminated [SRS_Rte_00128] [SRS_Rte_00129]. The term “implicit” is used here since the runnable does not actively initiate the reception or transmission of data.</li>\n</ul>\n</blockquote>\n<p>分两种一种显式、一种隐式。</p>\n<p>显式就是由 API<strong> 主动调用</strong>的发送或接收数据</p>\n<p>隐式就是类似<strong>回调函数</strong>这样被自动调用的发送或接收数据</p>\n<h4 id=\"static-communication\"><a class=\"anchor\" href=\"#static-communication\">#</a> <strong>Static Communication</strong></h4>\n<p>预先配置的通信链路</p>\n<h4 id=\"multiplicity\"><a class=\"anchor\" href=\"#multiplicity\">#</a> <strong>Multiplicity</strong></h4>\n<ul>\n<li>sender-receiver communication\n<ul>\n<li>支持 1:n</li>\n<li>支持 n:1</li>\n</ul>\n</li>\n<li>client-server communications\n<ul>\n<li>仅支持 n:1</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"224-concurrency\"><a class=\"anchor\" href=\"#224-concurrency\">#</a> <strong>2.2.4</strong> Concurrency</h3>\n<p>并发</p>\n<h2 id=\"23-the-rte-generator\"><a class=\"anchor\" href=\"#23-the-rte-generator\">#</a> <strong>2.3</strong> The RTE Generator</h2>\n<blockquote>\n<p>The RTE generator is one of a set of tools5 that create the realization of the AUTOSAR virtual function bus for an ECU based on information in the ECU Configuration Description. The RTE Generator is responsible for creating the AUTOSAR software component API functions that link AUTOSAR software-components to the OS and manage communication between AUTOSAR software-components and between AUTOSAR software-components and basic software modules.</p>\n</blockquote>\n<p>RTE 生成器是创建 VFB 的工具，负责上下层的交互</p>\n<h2 id=\"24-design-decisions\"><a class=\"anchor\" href=\"#24-design-decisions\">#</a> <strong>2.4</strong> Design Decisions</h2>\n<h1 id=\"3-rte-generation-process\"><a class=\"anchor\" href=\"#3-rte-generation-process\">#</a> <strong>3 RTE Generation Process</strong></h1>\n<blockquote>\n<p>The RTE Generator is used in different roles for the following phases:</p>\n<ul>\n<li>RTE Contract Phase</li>\n<li>Basic Software Scheduler Contract Phase</li>\n<li>PreBuild Data Set Contract Phase</li>\n<li>Basic Software Scheduler Generation Phase</li>\n<li>RTE Generation Phase</li>\n<li>PreBuild Data Set Generation Phase</li>\n<li>PostBuild Data Set Generation Phase</li>\n</ul>\n</blockquote>\n<h2 id=\"rte-generator-for-software-components\"><a class=\"anchor\" href=\"#rte-generator-for-software-components\">#</a> <strong>RTE Generator for Software-Components</strong></h2>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20241101233232600.png\" alt=\"image-20241101233232600\"></p>\n<p>很显然</p>\n<ul>\n<li>先描述 ECU</li>\n<li>然后通过配置工具配置，接着生成代码</li>\n<li>最后编译为可执行文件</li>\n</ul>\n<p>下面是一些 log 信息</p>\n<p>The following list is a collection of proposed information items in particular applicable</p>\n<p>to log files used for exchanging information about errors.</p>\n<ul>\n<li><strong>ErrorCode</strong> – A symbolic name for the message text</li>\n<li><strong>StandardErrorCode</strong> – The reference to the AUTOSAR error code</li>\n<li><strong>ConstraintCode</strong> – Reference to the semantic constraint mentioned in the AUTOSAR template specification.</li>\n<li><strong>Signature</strong> – Signature of the message for duplicate checks</li>\n<li><strong>Timestamp</strong> – A time stamp for the message</li>\n<li><strong>ShortName</strong> – A unique identification which allows to refer to particular error messages This can also be used to establish references between error messages, e.g. for screening and also to trace back to root cause</li>\n<li><strong>Desc</strong> – The human readable message text</li>\n<li><strong>Component</strong> – Such information item may help the user to locate the problem in the model</li>\n<li><strong>BaseUrl</strong> – An url for a base directory which can be used as basis for file references in a log file. This is typically the root direactory of a project structure.</li>\n<li><strong>ColumNumber</strong> – The column of the error position</li>\n<li><strong>LineNumber</strong> – The line number of the error position</li>\n<li><strong>LongName</strong> – The title of the error message</li>\n<li><strong>ObjectCategory</strong> – The category of for example the involved ApplicationPrimitve DataType (e.g.VALUE)</li>\n<li><strong>PrimaryErrorReference</strong> – Reference to the root cause if applicable</li>\n<li><strong>ScopeEntryReference</strong> – Reference to a scoping message if applicable</li>\n<li><strong>Object</strong> – The shortName based reference to the AUTOSAR element which caused the error</li>\n<li><strong>ToolName</strong> – The name of the tool which reported the error</li>\n<li><strong>ToolVersion</strong> – The version of the tools which reported the error</li>\n<li><strong>IncidentUrl</strong> – The Url which refers to the artifact in which the error occurs</li>\n<li><strong>Value</strong> – The actual found value which caused the problem</li>\n</ul>\n<h2 id=\"rte-generator-for-basic-software-scheduler\"><a class=\"anchor\" href=\"#rte-generator-for-basic-software-scheduler\">#</a> <strong>RTE Generator for Basic Software Scheduler</strong></h2>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240731162912897.png\" alt=\"image-20240731162912897\"></p>\n<ul>\n<li><strong>Contract Phase</strong>\n<ul>\n<li><strong>RTE Contract Phase</strong></li>\n<li><strong>Basic Software Scheduler Contract Phase</strong></li>\n</ul>\n</li>\n<li><strong>PreBuild Data Set Contract Phase</strong></li>\n<li><strong>Edit ECU Configuration of the RTE</strong></li>\n<li><strong>Generation Phase</strong>\n<ul>\n<li><strong>Basic Software Scheduler Generation Phase</strong></li>\n<li><strong>RTE Generation Phase</strong></li>\n<li><strong>Cluster Generation Phase</strong></li>\n<li><strong>Basic Software Module Description generation</strong>\n<ul>\n<li><strong>Bsw Module Description</strong></li>\n<li><strong>Bsw Internal Behavior</strong></li>\n<li><strong>Bsw Implementation</strong></li>\n</ul>\n</li>\n<li><strong>Com and LdCom usage</strong>\n<ul>\n<li><strong>Com user generation</strong></li>\n<li><strong>LdCom user generation</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>PreBuild Data Set Generation Phase</strong></li>\n<li><strong>PostBuild Data Set Generation Phase</strong></li>\n<li><strong>RTE Configuration interaction with other BSW Modules</strong>\n<ul>\n<li>The generated RTE interacts heavily with other AUTOSAR Basic Software Modules like Com, LdCom and Os. 会和这三个模块有大量的交互</li>\n</ul>\n</li>\n</ul>\n<p>规范这块感觉有点过于细节了</p>\n<p>我是没耐心看完哈哈哈</p>\n<p>可能只有做 RTE 生成的工具需要仔细研究</p>\n<p>小柴就偷个懒吧</p>\n<h1 id=\"4-rte-functional-specification\"><a class=\"anchor\" href=\"#4-rte-functional-specification\">#</a> <strong>4 RTE Functional Specification</strong></h1>\n<h2 id=\"41-architectural-concepts\"><a class=\"anchor\" href=\"#41-architectural-concepts\">#</a> <strong>4.1</strong> Architectural concepts</h2>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801140814168.png\" alt=\"image-20240801140814168\"></p>\n<p><strong>RTE and Data Types</strong></p>\n<p><strong>RTE and AUTOSAR Software-Components</strong></p>\n<blockquote>\n<p>The description of an AUTOSAR software-component is divided into the sections</p>\n<ul>\n<li>hierarchical structure</li>\n<li>ports and interfaces</li>\n<li>internal behavior</li>\n<li>implementation</li>\n</ul>\n</blockquote>\n<p>AUTOSAR 的组件描述分为一下几个</p>\n<ul>\n<li>层次结构</li>\n<li>端口和接口</li>\n<li>内部行为</li>\n<li>实现</li>\n</ul>\n<h2 id=\"42-rte-and-basic-software-scheduler-implementation-aspects\"><a class=\"anchor\" href=\"#42-rte-and-basic-software-scheduler-implementation-aspects\">#</a> <strong>4.2</strong> RTE and Basic Software Scheduler Implementation Aspects</h2>\n<blockquote>\n<p>This section describes some specific implementation aspects of an AUTOSAR RTE and the Basic Software Scheduler. It will mainly address</p>\n<ul>\n<li>the mapping of logical concepts (e.g., Runnable Entities, BSW Schedulable Entities) to technical architectures (namely, the AUTOSAR OS)</li>\n<li>the decoupling of pending interrupts (in the Basic Software) and the notification of AUTOSAR software components</li>\n<li>data consistency problems to be solved by the RTE</li>\n</ul>\n</blockquote>\n<p>支持这种链式的 task</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801144825065.png\" alt=\"image-20240801144825065\"></p>\n<p>RTE 事件类型</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801145237116.png\" alt=\"image-20240801145237116\"></p>\n<blockquote>\n<p>According to the meta model each kind of RTEEvent can either</p>\n<p><strong>ACT</strong> activate a RunnableEntity, or</p>\n<p><strong>WUP</strong> wakeup a RunnableEntity at its WaitPoints</p>\n</blockquote>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801145505813.png\" alt=\"image-20240801145505813\"></p>\n<h3 id=\"这里task有几种不同的触发方式\"><a class=\"anchor\" href=\"#这里task有几种不同的触发方式\">#</a> 这里 task 有几种不同的触发方式</h3>\n<h4 id=\"without-osevent\"><a class=\"anchor\" href=\"#without-osevent\">#</a> <strong>Without</strong> <strong>OsEvent</strong></h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskA</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">RE1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">Schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">RE3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskB</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">RE2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr></tbody></table></figure><h4 id=\"with-osevent\"><a class=\"anchor\" href=\"#with-osevent\">#</a> <strong>With</strong> <strong>OsEvent</strong></h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskA</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    EventMaskType Event<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">WaitEvent</span><span class=\"token punctuation\">(</span>EvtA <span class=\"token operator\">|</span> EvtB <span class=\"token operator\">|</span> EvtC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">GetEvent</span><span class=\"token punctuation\">(</span>TaskA<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>Event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtA<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtC<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskD<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskB</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token function\">RE1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token function\">RE2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskD</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token function\">RE3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr></tbody></table></figure><h4 id=\"monitoring-of-group-of-runnables\"><a class=\"anchor\" href=\"#monitoring-of-group-of-runnables\">#</a> <strong>Monitoring of group of runnables</strong></h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskA</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    EventMaskType Event<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">WaitEvent</span><span class=\"token punctuation\">(</span>EvtA <span class=\"token operator\">|</span> EvtB <span class=\"token operator\">|</span> EvtC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">GetEvent</span><span class=\"token punctuation\">(</span>TaskA<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>Event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtA<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token function\">RE1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token function\">RE4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Event <span class=\"token operator\">&amp;</span> EvtC<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            <span class=\"token function\">ClearEvent</span><span class=\"token punctuation\">(</span>EvtC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token function\">RE5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token function\">ActivateTask</span><span class=\"token punctuation\">(</span>TaskC<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskB</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token function\">RE2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token function\">RE3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">TaskC</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token function\">RE6</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token function\">RE7</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token function\">TerminateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">}</span></pre></td></tr></tbody></table></figure><h3 id=\"状态机制\"><a class=\"anchor\" href=\"#状态机制\">#</a> 状态机制</h3>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801153626566.png\" alt=\"image-20240801153626566\"></p>\n<p>一个任务的执行周期例子</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801154048073.png\" alt=\"image-20240801154048073\"></p>\n<h3 id=\"425-interrupt-decoupling-and-notifications\"><a class=\"anchor\" href=\"#425-interrupt-decoupling-and-notifications\">#</a> <strong>4.2.5</strong> Interrupt decoupling and notifications</h3>\n<blockquote>\n<p>Several of these BSW functionalities create situations, signalled by an interrupt, when AUTOSAR SW-Cs have to be involved. To inform AUTOSAR software components of those situations, runnables in AUTOSAR software components are activated by notifications. So interrupts that occur in the basic software have to be transformed into notifications of the AUTOSAR software components. Such a transformation has to take place at RTE level <strong>at the latest</strong>! Which interrupt is connected to which notification is decided either during system configuration/generation time or as part of the design of Complex Device Drivers or the Microcontroller Abstraction Layer.</p>\n</blockquote>\n<p>也就是说，中断的向上提醒要在 RTE 里实现（就是要在 RTE 里通知 SWC 哎不对啊，不是说上下啥都要通过 RTE 吗？那这句是废话了 ）</p>\n<p>P174 页介绍了一堆配置参数</p>\n<h3 id=\"426-data-consistency\"><a class=\"anchor\" href=\"#426-data-consistency\">#</a> <strong>4.2.6</strong> Data Consistency</h3>\n<p><strong>任务切换会导致数据一致性问题的发生</strong>【<strong>这块还挺重要的💮</strong>】</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801160250193.png\" alt=\"image-20240801160250193\"></p>\n<p><strong>避免这一问题有一下机制</strong></p>\n<blockquote>\n<ul>\n<li><strong>Sequential scheduling strategy</strong>\n<ul>\n<li><strong>顺序调度机制</strong></li>\n<li>The activation code of Runnables is sequentially placed in one task/ISR2 so that no interference between them is possible because one Runnable is only activated after the termination of the other. Data consistency is guaranteed.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>\n<p><strong>Interrupt blocking strategy</strong></p>\n<ul>\n<li><strong>中断阻塞机制</strong></li>\n<li>Interrupt blocking can be an appropriate means if collision avoidance is required for a very short amount of time. This might be done by disabling respectively suspending all interrupts, Os interrupts only or - if hardware supports it - only of some interrupt levels. In general this mechanism must be applied with care because it might influence SW in tasks with higher priority too and the timing of the complete system.</li>\n</ul>\n</li>\n<li>\n<p><strong>Usage of OS resources</strong></p>\n<ul>\n<li><strong>使用 OS resources</strong></li>\n<li>Usage of OS resources. Advantage in comparison to Interrupt blocking strategy is that less SW parts with higher priority are blocked. Disadvantage is that implementation might consume more resources (code, runtime) due to the more sophisticated mechanism. Appropriateness of this mechanism may vary depending on the number of OSs/cores and/or the number of available resources.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>Task blocking strategy</strong>\n<ul>\n<li><strong>Task 阻塞策略</strong></li>\n<li>Task task preemption is prohibited. This might be reached e.g. by assigning same priorities to affected tasks, by assigning same internal OS resource to affected tasks or by configuring the tasks to be non-preemptive. This mechanismmay be inappropriate in multi-partitioned systems.</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>Copy strategy</strong>\n<ul>\n<li><strong>拷贝策略</strong></li>\n<li>Idea: The RTE creates copies of data items so that concurrent accesses in different task/ISR2 contexts cannot collide because some of the accesses are redirected to the copies.</li>\n<li>How it can work:\n<ul>\n<li>Application for <strong>read</strong> <em>conflicts</em>:</li>\n<li>For all readers with lower priority than the writer a <em>read copy</em> is provided.</li>\n<li>Example:</li>\n<li>There exist Runnable R1, Runnable R2, data item X and a copy data item X. When Runnable R1 is running in higher priority task context than R2, and R1 is the only one writing X and R2 is reading X it is possible to guarantee data consistency by making a copy of data item X to variable X before activation of R2 and redirecting write access from X to X* or the read access from X to X for R2.</li>\n<li>Application for <strong>write</strong> <em>conflicts</em>:\n<ul>\n<li>If one or more data item receiver with a higher priority than the sender exist, a <em>write copy</em> for the sender is provided.</li>\n<li>Example:</li>\n<li>There exist Runnable R1, Runnable R2, data item X and copy data item X.When Runnable R1 (running in lower priority task context than R2) is writing X and R2 is reading X, it is possible to guarantee data consistency by making a copy of data item X to data item X <strong>before</strong> activation of R1 together with redirecting the write access from X to X* for R1 or the read access from X to X* for R2.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Usage of this copy mechanism may make sense if one or more of the following conditions hold:\n<ul>\n<li>This copy mechanism can handle those cases when only one instance does the data write access.</li>\n<li>R2 is accessing X several times.</li>\n<li>More than one Runnable R2 has read (resp. write) access to X.</li>\n<li>To save runtime is more important than to save code and RAM.</li>\n<li>Additional RAM requirements to hold the copies is acceptable.</li>\n</ul>\n</li>\n<li>Further issues to be taken into account:\n<ul>\n<li>AUTOSAR SW-Cs provided as source code and AUTOSAR SW-Cs provided as object code may or have to be handled in different ways. The redirecting mechanism for source code could use macros for C and C++ very efficiently whereas object-code AUTOSAR SW-Cs most likely are forced to use references.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>Assignment of data consistency mechanisms</strong></p>\n<p>可以在 RTE 中配置如下几种不同的机制</p>\n<blockquote>\n<p>Actually following values for configuration parameter RteExclusiveAreaImplMechanism must be supported:</p>\n<ul>\n<li>ALL_INTERRUPT_BLOCKING</li>\n</ul>\n<p>This value requests enabling and disabling of all Interrupts and is based on the</p>\n<p><em>Interrupt blocking strategy</em>.</p>\n<ul>\n<li>OS_INTERRUPT_BLOCKING</li>\n</ul>\n<p>This value requests enabling and disabling of Os Interrupts and is based on the</p>\n<p><em>Interrupt blocking strategy</em>.</p>\n<ul>\n<li>OS_RESOURCE</li>\n</ul>\n<p>This value requests to apply the <em>Usage of OS resources</em> mechanism.</p>\n<ul>\n<li>OS_SPINLOCK</li>\n</ul>\n<p>This value is used to co-ordinate concurrent access by TASKs/ISR2s on different</p>\n<p>cores to a shared resource.</p>\n<ul>\n<li>NONE</li>\n</ul>\n<p>RTE generator shall not apply any mechanisms for data consistency. Data con</p>\n<p>sistency will be ensured by methods outside of RTE implementation control.</p>\n<ul>\n<li>RTE_PLUGIN</li>\n</ul>\n<p>This value requests to apply the RTE Implementation Plug-In mechanism.</p>\n</blockquote>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801170445357.png\" alt=\"image-20240801170445357\"></p>\n<h2 id=\"43-communication-paradigms\"><a class=\"anchor\" href=\"#43-communication-paradigms\">#</a> <strong>4.3</strong> Communication Paradigms</h2>\n<blockquote>\n<p>AUTOSAR supports two basic communication paradigms: Client-Server and Sender Receiver. AUTOSAR software-components communicate through well defined ports and the behavior is statically defined by attributes.</p>\n</blockquote>\n<p>AUTOSAR 有两种通信模式</p>\n<ul>\n<li>Client-Server</li>\n<li>Sender Receiver</li>\n</ul>\n<blockquote>\n<p>The RTE provides the implementation of these communication paradigms. For inter ECU communication the RTE uses the functionalities provided by COM. For inter Partition communication (within the same ECU) the RTE may use functionalities provided by the IOC module. For intra-Partition the RTE provides the functionality on its own.</p>\n</blockquote>\n<p>对于 ECU 间的通信采用 COM 模块提供的功能</p>\n<p>对应分区间的通信采用 IOC 模块的功能实现</p>\n<blockquote>\n<p>With Sender-Receiver communication there are two main principles: Data Distribution and Event Distribution.</p>\n</blockquote>\n<p>对于 Sender Receiver 有两个原则</p>\n<ul>\n<li>数据分发</li>\n<li>事件分发</li>\n</ul>\n<h3 id=\"431-sender-receiver\"><a class=\"anchor\" href=\"#431-sender-receiver\">#</a> <strong>4.3.1</strong> Sender-Receiver</h3>\n<p><strong>Receive Modes</strong></p>\n<blockquote>\n<p>The RTE supports multiple receive modes for passing data to receivers. The four possible receive modes are:</p>\n<ul>\n<li><strong>Implicit data read access</strong>\n<ul>\n<li>when the receiver’s runnable executes it shall have access to a “copy” of the data that remains unchanged during the execution of the runnable.</li>\n<li>当接收器的 runnable 执行时，它应有权访问在 runnable 执行期间保持不变的数据的副本</li>\n</ul>\n</li>\n<li><strong>Explicit data read access</strong>\n<ul>\n<li>the RTE generator creates a non-blocking API call to enable a receiver to poll (and read) data. This receive mode is an “explicit” mode since an explicit API call is invoked by the receiver.</li>\n<li>RTE 生成器创建非阻塞 API 调用以使接收器能够 poll (和读取) 数据。此接收模式为 “显示模式，因为接收器调用了显式 API 调用。</li>\n</ul>\n</li>\n<li><strong>wake up of wait point</strong>\n<ul>\n<li>the RTE generator creates a blocking API call that the receiver invokes to read data.</li>\n<li>RTE 生成器创建一个阻塞 API 调用，接收器调用该 API 调用来读取数据。</li>\n</ul>\n</li>\n<li><strong>activation of runnable entity</strong>\n<ul>\n<li>the receiving runnable entity is invoked automatically by the RTE whenever new data is available. To access the new data, the runnable entity either has to use “implicit data read access” or “explicit data read access”, i.e. invoke an Rte_IRead, Rte_Read, Rte_DRead or Rte_Receive call, depending on the input configuration. This receive mode differs from “implicit data read access” since the receiver is invoked by the RTE in response to a DataReceivedEvent.</li>\n<li>只要有新数据可用，RTE 就会自动调用接收的可运行实体。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829150512271.png\" alt=\"image-20240829150512271\"></p>\n<p>涉及到一些方面</p>\n<p><strong>Receive Modes</strong></p>\n<p><strong>Multiple Data Elements</strong></p>\n<p><strong>Multiple Receivers and Senders</strong></p>\n<p><strong>Implicit and Explicit Data Reception and Transmission</strong></p>\n<p><strong>Transmission Acknowledgement</strong></p>\n<p><strong>Communication Time-out</strong></p>\n<p><strong>Data Element Invalidation</strong></p>\n<p><strong>Filters</strong></p>\n<p><strong>Buffering</strong></p>\n<p><strong>Operation</strong></p>\n<p><strong>“Never received status” for Data Element</strong></p>\n<p><strong>“Update flag” for Data Element</strong></p>\n<p><strong>Dynamic data type</strong></p>\n<p><strong>Inter-ECU communication through TP</strong></p>\n<p><strong>Inter-ECU communication of arrays of bytes</strong></p>\n<p><strong>Handling of acknowledgment events</strong></p>\n<p><strong>Meta data for application</strong></p>\n<h3 id=\"432-client-server\"><a class=\"anchor\" href=\"#432-client-server\">#</a> <strong>4.3.2</strong> Client-Server</h3>\n<p><strong>Multiplicity</strong></p>\n<blockquote>\n<p>Client-server interfaces contain two dimensions of multiplicity; multiple clients invoking a single server and multiple operations within a client-server interface.</p>\n</blockquote>\n<p>客户端 - 服务器接口包含两个多维度：多个客户端调用单个服务器以及客户端 - 服务器界面内的多个操作。</p>\n<p><strong>Communication Time-out</strong></p>\n<p><strong>Port-Defined argument values</strong></p>\n<p><strong>Buffering</strong></p>\n<blockquote>\n<p>The buffering mechanisms described here also apply to the serialization of server calls in the Basic Software Scheduler.</p>\n</blockquote>\n<p>这里描述的缓冲机制也适用于基本软件调度程序中的服务器调用的序列化。</p>\n<p>也就是对调用的指令进行缓冲，可以同时发送多条指令，服务器这边逐一执行</p>\n<p><strong>Inter-ECU and Inter-Partition Response to Request Mapping</strong></p>\n<p><strong>Client Identifier</strong></p>\n<p><strong>SequenceCounter</strong></p>\n<p><strong>Inter-ECU Response Channel Fan-Out</strong></p>\n<p><strong>Parameter Serialization</strong></p>\n<h3 id=\"433-swc-internal-communication\"><a class=\"anchor\" href=\"#433-swc-internal-communication\">#</a> <strong>4.3.3</strong> SWC internal communication</h3>\n<p><strong>Inter Runnable Variables</strong></p>\n<blockquote>\n<p>Sender/Receiver and Client/Server communication through AUTOSAR ports are</p>\n<p>the model for communication between AUTOSAR SW-Cs.</p>\n</blockquote>\n<p>通过 AUTOSAR 端口的发送 / 接收和客户端 / 服务器通信是 AUTOSAR SW-C 之间的通信模型</p>\n<blockquote>\n<p>For communication between Runnables inside of an AUTOSAR SW-C the AUTOSAR SW-C Template [2] establishes a separate mechanism.</p>\n</blockquote>\n<p>对于 AUTOSAR SW-C 内部的可运行程序之间的通信，AUTOSAR SW-C 模板 [2] 建立一个单独的机制。</p>\n<blockquote>\n<p>But why not use Sender/Receiver communication directly instead? Purpose is data encapsulation / data hiding.</p>\n</blockquote>\n<p>但是为什么不直接使用 Sender/Receiver 通信呢？目的是数据封装 / 数据隐藏。</p>\n<h3 id=\"434-inter-partition-communication\"><a class=\"anchor\" href=\"#434-inter-partition-communication\">#</a> <strong>4.3.4</strong> Inter-Partition communication</h3>\n<blockquote>\n<p>Partitions are used to decompose an ECU into functional units. Partitions can contain both SW-Cs and BSW modules.</p>\n</blockquote>\n<p>分区用于将 ECU 分解为功能单元。分区可以包含 SW-C 模块和 BSW 模块。</p>\n<blockquote>\n<p>The partitioning is done to protect the software contained in the partitions against each other or to increase the performance by running the partitions on different cores of a multi core controller.</p>\n</blockquote>\n<p>进行分区是为了保护分区中包含的软件相互保护，或者通过在多核控制器的不同核心上运行分区来提高性能。</p>\n<p><strong>Inter partition data communication using IOC</strong></p>\n<blockquote>\n<p>The IOC (Inter OS-Application Communication) is a feature of the AUTOSAR OS, which provides a data oriented communication mechanism between partitions.</p>\n</blockquote>\n<p>IOC (Inter OS-Application Communication) 是 AUTOSAROS 的一个特性，它提供了一个面向数据的分区之间的通信机制。</p>\n<blockquote>\n<p>The IOC provides communication buffers, queues, and protected access functions/macros to these buffers that can be used from any pre-configured partitions concurrently.</p>\n</blockquote>\n<p>IOC 为这些缓冲区提供通信缓冲区、队列和受保护的访问函数 / 宏，这些缓冲区内可以同时从任何预先配置的分区使用。</p>\n<blockquote>\n<p>The IOC offers communication of data to another core or between memory protected partitions with guarantee of data consistency.</p>\n</blockquote>\n<p>IOC 提供数据到另一个核心或内存保护分区之间的通信，保证数据的一致性。</p>\n<p><strong>Inter partition data communication using Basic Software Scheduler</strong></p>\n<blockquote>\n<p>The Basic Software Scheduler provides Sender-Receiver and Client-Server communications mechanisms for communication between Basic Software Modules in different partitions.</p>\n</blockquote>\n<p>基本软件调度器提供发送 - 接收和客户端 - 服务器通信机制，用于在不同分区的基本软件模块之间的通信。</p>\n<blockquote>\n<p>Therefore these communication paradigms can be used by Basic Software Modules in a multi core environment.</p>\n</blockquote>\n<p>因此，这些通信范例可以被基本软件模块在多核心环境中使用。</p>\n<p><strong>Accessing (Ld)Com and Det in multicore/multipartition configuration</strong></p>\n<p><strong>Accessing NvM in multicore/multipartition configurations</strong></p>\n<p><strong>Signaling and control flow support for inter partition communication</strong></p>\n<blockquote>\n<p>The OS representation of a partition is an OS Application.</p>\n<p>This is a (non-exhaustive) summary of OS features that can be used for signaling and control flow across partition boundaries:</p>\n</blockquote>\n<p>这是一个 (非详尽的) 操作系统功能概述，这些功能可用于跨分区边界的信令和控制流:</p>\n<blockquote>\n<ul>\n<li>activation of tasks</li>\n<li>start and stop of schedule tables</li>\n<li>event signaling</li>\n<li>alarms</li>\n<li>spin locks (for inter core synchronization)</li>\n</ul>\n<p>The following are not available for inter core signaling:</p>\n<ul>\n<li>OS Resource</li>\n<li>DisableAllInterrupts</li>\n</ul>\n<p>For inter core synchronization, spin locks are provided. But, for efficiency reasons they should be used with care.</p>\n</blockquote>\n<p>为了实现核心间同步，提供了自旋锁，但出于效率考虑，应谨慎使用。</p>\n<p><strong>Trusted Functions</strong></p>\n<p><strong>Memory Protection and Pointer Type Parameters in RTE API</strong></p>\n<h3 id=\"435-portinterface-element-mapping-and-data-conversion\"><a class=\"anchor\" href=\"#435-portinterface-element-mapping-and-data-conversion\">#</a> <strong>4.3.5</strong> PortInterface Element Mapping and Data Conversion</h3>\n<h3 id=\"436-network-representation\"><a class=\"anchor\" href=\"#436-network-representation\">#</a> <strong>4.3.6</strong> Network Representation</h3>\n<p><strong>Network Representation with no data transformation</strong></p>\n<p><strong>Network Representation with data transformation</strong></p>\n<h3 id=\"437-data-conversion\"><a class=\"anchor\" href=\"#437-data-conversion\">#</a> <strong>4.3.7</strong> Data Conversion</h3>\n<h3 id=\"438-range-checks-during-runtime\"><a class=\"anchor\" href=\"#438-range-checks-during-runtime\">#</a> <strong>4.3.8</strong> Range Checks during Runtime</h3>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829160808040.png\" alt=\"image-20240829160808040\"></p>\n<h2 id=\"44-modes\"><a class=\"anchor\" href=\"#44-modes\">#</a> <strong>4.4</strong> Modes</h2>\n<h3 id=\"441-mode-user\"><a class=\"anchor\" href=\"#441-mode-user\">#</a> <strong>4.4.1</strong> Mode User</h3>\n<blockquote>\n<p>The ModeDeclarations can be used in two ways by the mode user</p>\n<ul>\n<li>Modes can be used to trigger runnables</li>\n<li>An RTEEvent or BswEvent that starts an ExecutableEntity can contain a mode disabling dependency.</li>\n</ul>\n</blockquote>\n<h3 id=\"442-mode-manager\"><a class=\"anchor\" href=\"#442-mode-manager\">#</a> <strong>4.4.2</strong> Mode Manager</h3>\n<blockquote>\n<p>Entering and leaving modes is initiated by a mode manager.</p>\n</blockquote>\n<p>进入和离开模式由模式管理器启动。</p>\n<blockquote>\n<p>A mode manager might be a basic software module, for example the Basic Software Mode Manager (BswM), the communication manager (ComM), or the ECU state manager (EcuM).</p>\n</blockquote>\n<p>模式管理器可以是基本软件模块，例如基本软件模式管理器 (BSWM)、通信管理器 (ComM) 或 ECU 状态管理器 (EcuM)。</p>\n<blockquote>\n<p>The modemanager may also be an AUTOSAR SW-C. In this case, it is called an application mode manager.</p>\n</blockquote>\n<p>模式管理器也可以是 AUTOSAR SW-C。在这种情况下，它被称为应用程序模式管理器。</p>\n<h3 id=\"443-refinement-of-the-semantics-of-modedeclarations-and-mode\"><a class=\"anchor\" href=\"#443-refinement-of-the-semantics-of-modedeclarations-and-mode\">#</a> <strong>4.4.3</strong> Refinement of the semantics of ModeDeclarations and <strong>Mode</strong></h3>\n<p><strong>DeclarationGroups</strong></p>\n<h3 id=\"444-order-of-actions-taken-by-the-rte-basic-software-scheduler-upon-inter\"><a class=\"anchor\" href=\"#444-order-of-actions-taken-by-the-rte-basic-software-scheduler-upon-inter\">#</a> <strong>4.4.4</strong> Order of actions taken by the RTE / Basic Software Scheduler <strong>upon inter</strong></h3>\n<p><strong>ception of a mode switch notification</strong></p>\n<p><strong>synchronous</strong> 同步</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829161635073.png\" alt=\"image-20240829161635073\"></p>\n<p><strong>asynchronous</strong> 异步</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829161733205.png\" alt=\"image-20240829161733205\"></p>\n<p><strong>Assignment of mode machine instances to RTE and Basic Software Scheduler</strong></p>\n<p><strong>Initialization of mode machine instances</strong></p>\n<p><strong>Notification of mode switches</strong></p>\n<p><strong>Mode switch acknowledgment</strong></p>\n<p><strong>Mapping of ModeDeclarations</strong></p>\n<p><strong>Distributed Shared Mode Queues</strong></p>\n<h2 id=\"45-external-and-internal-trigger\"><a class=\"anchor\" href=\"#45-external-and-internal-trigger\">#</a> <strong>4.5</strong> External and Internal Trigger</h2>\n<ul>\n<li><strong>External Trigger Event Communication</strong></li>\n<li><strong>Trigger Source</strong></li>\n<li><strong>Multiplicity</strong>\n<ul>\n<li><strong>Multiple Trigger</strong></li>\n<li><strong>Multiple Trigger Sinks Single Trigger Source</strong></li>\n<li><strong>Multiple Trigger Sources Single Trigger Sink</strong></li>\n</ul>\n</li>\n<li><strong>Synchronized Trigger</strong></li>\n</ul>\n<p><strong>Inter Runnable Triggering</strong></p>\n<ul>\n<li><strong>Multiplicity</strong></li>\n</ul>\n<p><strong>Inter Basic Software Module Entity Triggering</strong></p>\n<p><strong>Inter ECU Trigger Communication</strong></p>\n<p><strong>Queuing of Triggers</strong></p>\n<p><strong>Activation of triggered ExecutableEntities</strong></p>\n<h2 id=\"46-initialization-and-finalization\"><a class=\"anchor\" href=\"#46-initialization-and-finalization\">#</a> <strong>4.6</strong> Initialization and Finalization</h2>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240902163033649.png\" alt=\"image-20240902163033649\"></p>\n<p><strong>Initialization of the RTE</strong></p>\n<p><strong>Finalization of the RTE</strong></p>\n<p><strong>Finalization of the</strong> <strong>Basic Software Scheduler</strong></p>\n<p><strong>Initialization and Finalization of AUTOSAR Software-Components</strong></p>\n<h2 id=\"47-variant-handling-support\"><a class=\"anchor\" href=\"#47-variant-handling-support\">#</a> <strong>4.7</strong> Variant Handling Support</h2>\n<h3 id=\"471-overview\"><a class=\"anchor\" href=\"#471-overview\">#</a> <strong>4.7.1</strong> Overview</h3>\n<blockquote>\n<p>The <em>AUTOSAR Template</em>s support the creation of <em>Variant</em>s in a subset of its model elements. The <em>Variant Handling</em> support in the in <em>AUTOSAR Template</em>s is driven by the purpose to describe variability in a <em>AUTOSAR System</em> on several aspects, e.g.</p>\n</blockquote>\n<p>AUTOSAR 模板支持在其模型元素子集中创建变体。AUTOSAR 模板中的变体处理支持旨在从多个方面描述 AUTOSAR 系统中的可变性，例如:</p>\n<blockquote>\n<ul>\n<li>Virtual Functional Bus</li>\n<li>Component SwcInternalBehavior and SwcImplementation</li>\n<li>Deployment of the software components to ECUs</li>\n<li>Communication Matrix</li>\n<li>Basic Software Modules</li>\n</ul>\n</blockquote>\n<p>虚拟功能总线<br>\n组件外部行为和功能<br>\n将软件组件部署到 ECU<br>\n 通信矩阵<br>\n基本软件模块</p>\n<blockquote>\n<p>This approach requires that the RTE Generator is able to process the described Variability in input configurations and partially to implement described variability in the generated RTE and Basic Software Scheduler code.</p>\n</blockquote>\n<p>这种方法要求 RTE 生成器能够处理输入配置中描述的变量，并在生成的 RTE 和基本软件调度器代码中部分实现所描述的变量。</p>\n<h3 id=\"472-choosing-a-variant-and-binding-variability\"><a class=\"anchor\" href=\"#472-choosing-a-variant-and-binding-variability\">#</a> 4.7.2 Choosing a Variant and Binding Variability</h3>\n<p><strong>General impact of Binding Times on RTE generation</strong></p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905103227817.png\" alt=\"image-20240905103227817\"></p>\n<blockquote>\n<p>R resolve variability, a particular variant is the output</p>\n<p>I implement variability, all possible variants in the output</p>\n<p>RV provide values to resolve implemented variability <em>PreBuild</em> or <em>PostBuild</em></p>\n<p>n/a not applicable</p>\n</blockquote>\n<p>绑定时间对 RTE 生成的影响</p>\n<p><strong>Choosing a particular variant</strong></p>\n<p><strong>SystemDesignTime</strong></p>\n<p><strong>CodeGenerationTime</strong></p>\n<p><strong>PreCompileTime</strong></p>\n<p><strong>LinkTime</strong></p>\n<h3 id=\"473-variability-affecting-the-rte-generation\"><a class=\"anchor\" href=\"#473-variability-affecting-the-rte-generation\">#</a> 4.7.3 Variability affecting the RTE generation</h3>\n<p><strong>Software Composition</strong></p>\n<p><strong>Atomic Software Component and its Internal Behavior</strong></p>\n<ul>\n<li><strong>RTE API which is subject to variability</strong></li>\n</ul>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114721400.png\" alt=\"image-20240905114721400\"></p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114737008.png\" alt=\"image-20240905114737008\"></p>\n<ul>\n<li><strong>Conditional API options</strong></li>\n</ul>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114754389.png\" alt=\"image-20240905114754389\"></p>\n<ul>\n<li><strong>Runnable Entity’s and RTEEvents</strong></li>\n</ul>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114848386.png\" alt=\"image-20240905114848386\"></p>\n<ul>\n<li><strong>Conditional Memory Allocation</strong></li>\n</ul>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114911511.png\" alt=\"image-20240905114911511\"></p>\n<p><strong>NvBlockComponent and its Internal Behavior</strong></p>\n<p><strong>Parameter Component</strong></p>\n<p><strong>Basic Software Modules and its Internal Behavior</strong></p>\n<p><strong>Flat Instance descriptor</strong></p>\n<h3 id=\"474-variability-affecting-the-basic-software-scheduler-generation\"><a class=\"anchor\" href=\"#474-variability-affecting-the-basic-software-scheduler-generation\">#</a> 4.7.4 Variability affecting the Basic Software Scheduler generation</h3>\n<h2 id=\"48-development-error\"><a class=\"anchor\" href=\"#48-development-error\">#</a> <strong>4.8</strong> Development error</h2>\n<h2 id=\"49-bypass-support\"><a class=\"anchor\" href=\"#49-bypass-support\">#</a> <strong>4.9</strong> Bypass Support</h2>\n<p>旁路支持</p>\n<blockquote>\n<p>Rapid prototyping can be used during electronic control unit development to evaluate and test new software control algorithms for various functions.</p>\n</blockquote>\n<p>在电子控制单元开发过程中，可以使用快速原型来评估和测试适用于各种功能的新软件控制算法。</p>\n<blockquote>\n<p>With Fullpass technology the original ECU is totally replaced by a Rapid Prototyping Unit (RPU).</p>\n</blockquote>\n<p>采用 Fullpass 技术，原有的 ECU 完全被快速原型单元 (RPU) 所取代。</p>\n<blockquote>\n<p>With Bypass technology the original ECU and software stays in the control loop to supports the majority of the control algorithms and interface with sensors, actuators and communication buses: only the specific control algorithm that shall be prototyped is deported into the RPU (external bypass) or even directly executed in the original ECU (internal bypass).</p>\n</blockquote>\n<p>通过旁路技术，原始 ECU 和软件留在控制回路中，以支持大多数控制算法并与传感器致动器和通信总线接口：只有应进行原型设计的特定控制算法被发送到 RPU (外部旁路) 中，甚至直接在原始 ECU (内部旁路) 中执行。</p>\n<blockquote>\n<p>Bypass mainly consists in replacing at run time inputs and/or outputs of the original software algorithms by value computed by the prototype algorithm under test.</p>\n</blockquote>\n<p>绕过主要包括在运行时用被测试的原型算法计算的值替换原始软件算法的输入和 / 或输出。</p>\n<blockquote>\n<p>The RTE does not directly implement bypass but the RTE provides supports for the integration of such implementation by CDD and/or integration code.</p>\n</blockquote>\n<p>RTE 不直接实现绕过，但 RTE 支持通过 CDD 和 / 或集成代码实现此类实现。</p>\n<h3 id=\"491-bypass-description\"><a class=\"anchor\" href=\"#491-bypass-description\">#</a> <strong>4.9.1</strong> Bypass description</h3>\n<h3 id=\"492-component-wrapper-method\"><a class=\"anchor\" href=\"#492-component-wrapper-method\">#</a> <strong>4.9.2</strong> Component wrapper method</h3>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905135241264.png\" alt=\"image-20240905135241264\"></p>\n<h3 id=\"493-direct-buffer-access-method\"><a class=\"anchor\" href=\"#493-direct-buffer-access-method\">#</a> <strong>4.9.3</strong> Direct buffer access method</h3>\n<blockquote>\n<p>The direct buffer access method provides runtime direct read and write access to the RTE buffers that implement the ECU communication infrastructure.</p>\n</blockquote>\n<p>直接缓冲区访问方法提供对实现 ECU 通信基础设施的 RTE 缓冲区的运行时直接读写访问</p>\n<h3 id=\"494-extended-buffer-access-method\"><a class=\"anchor\" href=\"#494-extended-buffer-access-method\">#</a> <strong>4.9.4</strong> Extended buffer access method</h3>\n<blockquote>\n<p>The extended buffer access method enhances the support for rapid prototyping (RP) to support the bypass use case where the RTE cannot be regenerated by the bypass user.</p>\n</blockquote>\n<p>扩展缓冲区访问方法增强了对快速原型 (RP) 的支持，以支持旁路用户无法再生 RTE 的旁路用例。</p>\n<blockquote>\n<p>The goal is to ensure that all VariableDataPrototypes that are communicated via RTE APIs are written to and read back from a RP global buffer that can be modified by rapid prototyping tools (RPT).</p>\n</blockquote>\n<p>目标是确保所有通过 RTE ApI 通信的变量数据原型都写入并从 RP 全局缓冲区读回，该缓冲区可通过快速原型生成工具 (RPT) 进行修改。</p>\n<blockquote>\n<p>The method applies to all RTE APIs and not just those for implicit access and hence is termed the <em>extended</em> buffer access method.</p>\n</blockquote>\n<p>该方法适用于所有 RTE API，而不仅仅是用于隐式访问的 API，因此被称为扩展缓冲区访问方法。</p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905141458222.png\" alt=\"image-20240905141458222\"></p>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905141637776.png\" alt=\"image-20240905141637776\"></p>\n<h3 id=\"495-service-based-prototyping\"><a class=\"anchor\" href=\"#495-service-based-prototyping\">#</a> <strong>4.9.5</strong> Service Based Prototyping</h3>\n<blockquote>\n<p>Access to the RP global buffers and RP global measurement buffers can be implemented by using a service based ECU interface in which an additional RP service component, such as an “XCP on CAN” or “XCP on Ethernet” service, is added to the ECU application.</p>\n</blockquote>\n<p>可以使用基于服务的 ECU 接口访问 RP 全局缓冲区和 RP 全局测量缓冲区，其中在 ECU 应用程序中添加了额外的 RP 服务组件，例如 “CAN 上的 XCP” 或 “以太网上的 XCP” 服务</p>\n<blockquote>\n<p>The integration of the service can be performed pre-build by means of source code based integration, for example, by adding an XCP or custom BSW component, or post-build by patching the binary code of an already compiled ECU image.</p>\n</blockquote>\n<p>服务集成可以通过源代码集成 (例如，通过添加 XCP 或自定义 BSW 组件) 进行预构建，也可以通过修补已经编译的 ECU 映像的二进制代码进行后构建。</p>\n<blockquote>\n<p>In a service based scenario data is sampled and/or stimulated at RP service points.</p>\n</blockquote>\n<p>在基于服务的场景中，数据在 RP 服务点被采样和 / 或激励。</p>\n<blockquote>\n<p>During either sampling or stimulation the data is read and/or written from the memory associated with the VariableDataPrototype to/from a local buffer during the execution of the RP service point and hence transferred to/from the RP tool.</p>\n</blockquote>\n<p>在采样或刺激期间，在执行 RP 服务点期间，从与 VariableDataPrototype 关联的存储器中读取和 / 或写入本地缓冲区，从而将数据传输到 / 从 RP 工具。</p>\n<blockquote>\n<p>Within the context of the RTE the data stimulated by the RP service points are the RP global buffers and RP global measurement buffers however any data that is measurable is potentially subject to reading.</p>\n</blockquote>\n<p>在 RTE 的上下文中，由 RP 服务点激发的数据是 RP 全局缓冲区和 RP 全局测量缓冲区，但是任何可测量数据都可能受到读取。</p>\n<blockquote>\n<p>A RP service point is simply a call of a RP service function that is provided by the RP service component.</p>\n</blockquote>\n<p>RP 服务点只是对 RP 服务组件提供的 RP 服务函数的调用。</p>\n<blockquote>\n<p>The RP service function is responsible for sampling (reading) and stimulating (writing) the bypass data.</p>\n</blockquote>\n<p>RP 服务功能负责对旁路数据进行采样 (读取) 和激励 (写入)。</p>\n<blockquote>\n<p>The action of sampling may then trigger the RP system to perform the bypass (this may involve the communication of the sampled data to an external system for computation) ready for reading when the stimulation occurs.</p>\n</blockquote>\n<p>采样操作可能会触发 RP 系统执行旁路操作 (这可能涉及将采样数据传送到外部系统进行计算)，以便在刺激发生时进行读取。</p>\n<h2 id=\"410-data-transformation\"><a class=\"anchor\" href=\"#410-data-transformation\">#</a> <strong>4.10</strong> Data Transformation</h2>\n<blockquote>\n<p>Transformers enable AUTOSAR systems to use a data transformation mechanism to linearize and transform data.</p>\n</blockquote>\n<p>废话一条</p>\n<blockquote>\n<p>They can be concatenated to transformer chains and are executed by the RTE for inter-ECU communication which is configured to be transformed.</p>\n</blockquote>\n<p>它们可以连接到转换器链，并由用于 ECU 间通信的 RTE 执行，ECU 间通信被配置为被转换的</p>\n<blockquote>\n<p>The input of the first transformer in the chain gets the data from the RTE.Each following transformer uses the output of the preceding transformer as input.</p>\n</blockquote>\n<p>链中第一个转换器的输入从 RTE 获得数据，随后的每个转换器使用前一个转换器的输出作为输入</p>\n<blockquote>\n<p>All transformers following the first one then have a generic signature with just a byte array as IN and OUT parameter. Such an architecture could be used to design systems, where you can flexibly add functionality like safety or security protection to a serialized stream.</p>\n</blockquote>\n<p>第一个转换器之后的所有转换器都有一个通用的签名，只有字节数组作为 IN 和 OUT 参数。这样的架构可以用来设计系统，您可以在串行流中灵活地添加安全或安全保护等功能。</p>\n<blockquote>\n<p>The transformers for inter-ECU communication are configured in the System Description.</p>\n</blockquote>\n<p>用于 ECU 间通信的转换器在系统说明中配置。</p>\n<blockquote>\n<p>Furthermore the RTE can execute transformers for intra-ECU communication to transform different representations of data structures between software components or basic software modules within one ECU.</p>\n</blockquote>\n<p>此外，RTE 可以执行用于 ECU 内部通信的转换器，以转换一个 ECU 内软件组件或基本软件模块之间的不同数据结构表示。</p>\n<blockquote>\n<p>Transformers for intra-ECU communication are restricted to unqueued S/R communication. In addition no transformer chains are applicable.</p>\n</blockquote>\n<p>用于 ECU 内部通信的转换器仅限于非排队的 S/R 通信。此外，不适用转换器链。</p>\n<blockquote>\n<p>Those limitations are formulated since for the currently known use-cases there is no need for introducing this functionality.</p>\n</blockquote>\n<p>之所以制定这些限制，是因为对于目前已知的用例，没有必要引入此功能。</p>\n<blockquote>\n<p>The execution of the transformers and the necessary buffer handling is coordinated by the RTE.</p>\n</blockquote>\n<p>转换器的运行和必要的缓冲处理由 RTE 进行协调。</p>\n<h3 id=\"execution-of-transformer\"><a class=\"anchor\" href=\"#execution-of-transformer\">#</a> <strong>Execution of Transformer</strong></h3>\n<p><strong>Transformer for inter-ECU communication</strong></p>\n<p><strong>Transformer for intra-ECU communication</strong></p>\n<h3 id=\"transformer-chains\"><a class=\"anchor\" href=\"#transformer-chains\">#</a> <strong>Transformer Chains</strong></h3>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240909142712539.png\" alt=\"image-20240909142712539\"></p>\n<h3 id=\"buffer-handling\"><a class=\"anchor\" href=\"#buffer-handling\">#</a> <strong>Buffer Handling</strong></h3>\n<h3 id=\"interfaces-to-transformer\"><a class=\"anchor\" href=\"#interfaces-to-transformer\">#</a> <strong>Interfaces to Transformer</strong></h3>\n<h3 id=\"error-handling\"><a class=\"anchor\" href=\"#error-handling\">#</a> <strong>Error Handling</strong></h3>\n<h3 id=\"transformer-code-forwarding\"><a class=\"anchor\" href=\"#transformer-code-forwarding\">#</a> <strong>Transformer Code Forwarding</strong></h3>\n<blockquote>\n<p>There exist use-cases where the application software needs to influence the behavior of the sending transformer chain.</p>\n</blockquote>\n<p>存在应用软件需要影响发送转换器链的行为的用例。</p>\n<blockquote>\n<p>One prominent example is a signal to service translation application where the forwarding of E2E status information into the E2E Transformer on the sending side is required.</p>\n</blockquote>\n<p>一个突出的例子是信号到服务转换应用程序，其中需要将 E2E 状态信息转发到发送端的 E2E 转换器。</p>\n<blockquote>\n<p>In case E2E protection is to be applied for a communication path with signal to service translation on the way,</p>\n<p>then the E2E status assessed for the received data needs to be forwarded to</p>\n<p>the E2E information generated for the sending side.</p>\n</blockquote>\n<p>如果 E2E 保护应用于具有信号到服务转换的通信路径，则需要对接收到的数据进行评估的 E2E 状态需要转发到为发送方生成的 E2E 信息。</p>\n<blockquote>\n<p>Thus the application which is going to use the data can identify data exchange faults by using the standard E2E check function.</p>\n</blockquote>\n<p>因此，将要使用数据的应用程序可以使用标准的 E2E 检查功能来识别数据交换故障。</p>\n<h3 id=\"transformer-transaction-handling\"><a class=\"anchor\" href=\"#transformer-transaction-handling\">#</a> <strong>Transformer Transaction Handling</strong></h3>\n<h3 id=\"transformer-protocol-header-peeking\"><a class=\"anchor\" href=\"#transformer-protocol-header-peeking\">#</a> <strong>Transformer Protocol Header Peeking</strong></h3>\n<h3 id=\"com-based-transformer\"><a class=\"anchor\" href=\"#com-based-transformer\">#</a> <strong>COM Based Transformer</strong></h3>\n<blockquote>\n<p>The COM Based Transformer approach is an alternative transformation handling whic has several aspects:</p>\n</blockquote>\n<p>基于 COM 的转换器方法是一种可选的转换处理方法，它有以下几个方面</p>\n<blockquote>\n<ul>\n<li>the first transformer is the ’COM Based Transformer’ [24] for the ’serialization’ of data,</li>\n<li>the further transformers are invoked normally and enhance the array representation of the data element,</li>\n<li>the handling of the transformed data towards the COM Module [3] is done via a specific array based signal group API.</li>\n</ul>\n</blockquote>\n<p>第一个转换器是 “基于 COM 的 Transformer”[24] 对于数据的 “序列化 “</p>\n<p>进一步变换器被正常调用并增强数据元素的阵列表示，</p>\n<p>向 COM 模块转换数据的处理 [3] 是通过特定的基于阵列的信号组 API 来完成的。</p>\n<blockquote>\n<p>The ’COM Based Transformer’ [24] serializes the data elements into the array representation exactly as the COM module would have done it.</p>\n</blockquote>\n<p>基于 COM 的转换器 [24] 正如 COM 模块所做的那样，将数据元素序列化为数组表示形式。</p>\n<blockquote>\n<p>The System Template [8] provides means to define which data elements shall be handled by the ’COM Based Transformer’ and - via the communication matrix section - also how the data shall be serialized.</p>\n</blockquote>\n<p>系统模板 [8] 提供了定义哪些数据元素应该由 “基于 COM 的 Transformer” 处理的方法，以及 -- 通过通信矩阵部分 -- 数据应该如何序列化。</p>\n<blockquote>\n<p>This is the basis for the COM module’s configuration and ’COM Based Transformer’ behavior.</p>\n<p>The RTE interacts with the COM module via dedicated array based signal group APIs for sending and receiving the transformed data.</p>\n</blockquote>\n<p>这是 COM 模块配置和 “基于 COM 的 Transformer” 行为的基础。<br>\nRTE 通过专用的基于阵列的信号组 API 与 COM 模块交互，用于发送和接收转换数据。</p>\n<h1 id=\"5-rte-reference\"><a class=\"anchor\" href=\"#5-rte-reference\">#</a> <strong>5 RTE Reference</strong></h1>\n<blockquote>\n<p>“Everything should be as simple as possible, but no simpler.”</p>\n<p>– <em>Albert Einstein</em></p>\n</blockquote>\n<h2 id=\"51-scope\"><a class=\"anchor\" href=\"#51-scope\">#</a> <strong>5.1</strong> Scope</h2>\n<ul>\n<li>\n<p><strong>5.1.1 Programming Languages</strong></p>\n</li>\n<li>\n<p><strong>5.1.2 Generator Principles</strong></p>\n<ul>\n<li>\n<p><strong>Operating Modes</strong></p>\n<ul>\n<li>\n<p><strong>Compatibility Mode</strong></p>\n</li>\n<li>\n<p><strong>Vendor Mode</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Optimization Modes</strong></p>\n<ul>\n<li><strong>Build support</strong></li>\n<li><strong>Software Component Namespace</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>5.1.3 Generator external configuration switches</strong></p>\n<ul>\n<li><strong>Unconnected R-Port check</strong></li>\n<li><strong>Missing input configuration check</strong></li>\n<li><strong>Missing initialization values</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"52-api-principles\"><a class=\"anchor\" href=\"#52-api-principles\">#</a> <strong>5.2</strong> API Principles</h2>\n<blockquote>\n<p>The design of the RTE API has been guided by the following core principles:</p>\n<ul>\n<li>The API should be orthogonal – there should be only one way of performing a task.</li>\n<li><strong>[SWS_Rte_01314]</strong> The API shall be compiler independent. <em>(<strong>SRS_Rte_00100</strong>)</em></li>\n<li><strong>[SWS_Rte_01315]</strong> The API shall support components where the source code is available [SRS_Rte_00024] and where only object-code is available [SRS_Rte_00140].<em>(<strong>SRS_Rte_00024</strong>,</em> <em>SRS_Rte_00140</em>*)*</li>\n<li>The API shall support the multiple instantiation of AUTOSAR software components [SRS_Rte_00011] that share code [SRS_Rte_00012].</li>\n</ul>\n</blockquote>\n<p>RTE API 的设计遵循以下核心原则:</p>\n<ul>\n<li>API 应该是正交的 -- 执行任务应该只有一种方法</li>\n<li>[SWS_Rte_01314] API 应与编译器无关。(SRS_Rte_00100)</li>\n<li>[SWS_Rte_01315] API 应支持源代码可用的组件 [SRS_Rte_00024] 和只有对象代码可用的组件 [SRS Rte_00140].c (SRS Rte_00024，SRS_Rte_00140**)</li>\n<li>API 应支持共享代码「SRS Rte 00012] 的 AUTOSAR 软件组件 [SRS Rte00011] 的多个实例化。</li>\n</ul>\n<blockquote>\n<p>Two forms of the RTE API are available to software-components; direct and indirect.</p>\n</blockquote>\n<p>软件组件可以使用两种形式的 RTE API: 直接和间接。</p>\n<blockquote>\n<p>The direct API has been designed with regard to efficient invocation and includes an API mapping that can be used by an RTE generator to optimize a component’s API, for example, to permit the direct invocation of the generated API functions or even eliding the generated RTE completely.</p>\n</blockquote>\n<p>直接 API 的设计考虑了高效的调用，并包括一个 API 映射，RTE 生成器可以使用它来优化组件的 API，例如，允许直接调用生成的 API 函数，甚至完全省略生成的 RTE。</p>\n<blockquote>\n<p>The indirect API cannot be optimized using the API mapping but has the advantage that the handle used to access the API can be stored in memory and accessed, via an iterator, to apply the same API to multiple ports.</p>\n</blockquote>\n<p>间接 API 不能使用 API 映射进行优化，但它具有优势，即用于访问 API 的句柄可以存储在内存中，并通过迭代器进行访问，以将相同的 API 应用于多个端口。</p>\n<p>嗯这个真的是很常用，会将整个代码的逻辑梳理的很清晰</p>\n<p>给个例子吧</p>\n<pre><code class=\"language-C\">void (*fuck[10])(int) = {\n    PipeLine_CheckPointer,\n    PipeLine_CheckStatus,\n    PipeLine_EnterProtectionArae\n};\n\nint main(){\n    \n}\n</code></pre>\n<p>就这样吧</p>\n<h3 id=\"521-rte-namespace\"><a class=\"anchor\" href=\"#521-rte-namespace\">#</a> <strong>5.2.1</strong> RTE Namespace</h3>\n<h3 id=\"522-direct-ap\"><a class=\"anchor\" href=\"#522-direct-ap\">#</a> <strong>5.2.2</strong> Direct AP</h3>\n<h3 id=\"523-indirect-api\"><a class=\"anchor\" href=\"#523-indirect-api\">#</a> <strong>5.2.3</strong> Indirect API</h3>\n<h3 id=\"524-variableaccess-in-the-datareadaccess-and-datawriteaccess-roles\"><a class=\"anchor\" href=\"#524-variableaccess-in-the-datareadaccess-and-datawriteaccess-roles\">#</a> <strong>5.2.4</strong> VariableAccess <strong>in the</strong> <strong>dataReadAccess</strong> <strong>and</strong> <strong>dataWriteAccess</strong> <strong>roles</strong></h3>\n<h3 id=\"525-per-instance-memory\"><a class=\"anchor\" href=\"#525-per-instance-memory\">#</a> <strong>5.2.5</strong> Per Instance Memory</h3>\n<h3 id=\"526-api-mapping\"><a class=\"anchor\" href=\"#526-api-mapping\">#</a> <strong>5.2.6</strong> API Mapping</h3>\n<h3 id=\"527-unconnected-ports\"><a class=\"anchor\" href=\"#527-unconnected-ports\">#</a> <strong>5.2.7</strong> Unconnected Ports</h3>\n<h3 id=\"528-non-identical-port-interfaces\"><a class=\"anchor\" href=\"#528-non-identical-port-interfaces\">#</a> <strong>5.2.8</strong> Non-identical port interfaces</h3>\n<h3 id=\"529-return-type-std_returntype\"><a class=\"anchor\" href=\"#529-return-type-std_returntype\">#</a> <strong>5.2.9</strong> Return type Std_ReturnType</h3>\n<h2 id=\"53-rte-modules\"><a class=\"anchor\" href=\"#53-rte-modules\">#</a> <strong>5.3</strong> RTE Modules</h2>\n<h2 id=\"54-rte-data-structures\"><a class=\"anchor\" href=\"#54-rte-data-structures\">#</a> <strong>5.4</strong> RTE Data Structures</h2>\n<h2 id=\"55-api-data-types\"><a class=\"anchor\" href=\"#55-api-data-types\">#</a> <strong>5.5</strong> API Data Types</h2>\n<h3 id=\"551-std_returntype\"><a class=\"anchor\" href=\"#551-std_returntype\">#</a> <strong>5.5.1</strong> Std_ReturnType</h3>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240919111157918.png\" alt=\"image-20240919111157918\"></p>\n<h2 id=\"56-api-reference\"><a class=\"anchor\" href=\"#56-api-reference\">#</a> <strong>5.6</strong> API Reference</h2>\n<h2 id=\"57-runnable-entity-reference\"><a class=\"anchor\" href=\"#57-runnable-entity-reference\">#</a> <strong>5.7</strong> Runnable Entity Reference</h2>\n<h2 id=\"58-rte-lifecycle-api-reference\"><a class=\"anchor\" href=\"#58-rte-lifecycle-api-reference\">#</a> <strong>5.8</strong> RTE Lifecycle API Reference</h2>\n<h2 id=\"59-rte-call-backs-reference\"><a class=\"anchor\" href=\"#59-rte-call-backs-reference\">#</a> <strong>5.9</strong> RTE Call-backs Reference</h2>\n<h2 id=\"510-expected-interfaces\"><a class=\"anchor\" href=\"#510-expected-interfaces\">#</a> <strong>5.10</strong> Expected interfaces</h2>\n<h2 id=\"511-vfb-tracing-reference\"><a class=\"anchor\" href=\"#511-vfb-tracing-reference\">#</a> <strong>5.11</strong> VFB Tracing Reference</h2>\n<h1 id=\"6-basic-software-scheduler-reference\"><a class=\"anchor\" href=\"#6-basic-software-scheduler-reference\">#</a> <strong>6 Basic Software Scheduler Reference</strong></h1>\n<h1 id=\"7-rte-implementation-plug-ins-reference\"><a class=\"anchor\" href=\"#7-rte-implementation-plug-ins-reference\">#</a> <strong>7 RTE Implementation Plug-Ins Reference</strong></h1>\n<h2 id=\"711-rte-implementation-plug-ins-in-the-autosar-architecture\"><a class=\"anchor\" href=\"#711-rte-implementation-plug-ins-in-the-autosar-architecture\">#</a> <strong>7.1.1</strong> RTE Implementation Plug-Ins in the AUTOSAR Architecture</h2>\n<p><img data-src=\"../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240919113812748.png\" alt=\"image-20240919113812748\"></p>\n<h1 id=\"8-rte-ecu-configuration\"><a class=\"anchor\" href=\"#8-rte-ecu-configuration\">#</a> <strong>8 RTE ECU Configuration</strong></h1>\n<h1 id=\"2-functional-overview\"><a class=\"anchor\" href=\"#2-functional-overview\">#</a> <strong>2 Functional Overview</strong></h1>\n<blockquote>\n<p>The Run-Time Environment (RTE) is at the heart of the AUTOSAR ECU architecture. The RTE is the realization (for a particular ECU) of the interfaces of the AUTOSAR Virtual Function Bus (VFB) and thus provides the infrastructure services for communication between Application Software Components as well as facilitating access to basic software components including the OS.</p>\n</blockquote>\n<p>RTE 是 VFB 的实现，为应用软件组件之间提供通信，SWC 与 BSW 之间的交互</p>\n<h1 id=\"4-requirements-on-rte\"><a class=\"anchor\" href=\"#4-requirements-on-rte\">#</a> <strong>4 Requirements on RTE</strong></h1>\n<h2 id=\"41-functional-requirements\"><a class=\"anchor\" href=\"#41-functional-requirements\">#</a> <strong>4.1</strong> Functional Requirements</h2>\n<h3 id=\"411-interaction-with-autosar-os\"><a class=\"anchor\" href=\"#411-interaction-with-autosar-os\">#</a> <strong>4.1.1</strong> Interaction with AUTOSAR OS</h3>\n<p><strong>[SRS_Rte_00020] Access to OS</strong></p>\n<p><strong>[SRS_Rte_00099] Decoupling of interrupts</strong></p>\n<p><strong>[SRS_Rte_00036] Assignment to OS Applications</strong></p>\n<p><strong>[SRS_Rte_00049] Construction of task bodies</strong></p>\n<p><strong>[SRS_Rte_00193] Support for Runnable Entity execution chaining</strong></p>\n<p><strong>[SRS_Rte_00210] Support for inter OS application communication</strong></p>\n<h2 id=\"412-interaction-with-autosar-com\"><a class=\"anchor\" href=\"#412-interaction-with-autosar-com\">#</a> <strong>4.1.2</strong> Interaction with AUTOSAR COM</h2>\n<p><strong>[SRS_Rte_00068] Signal initial values</strong></p>\n<p><strong>[SRS_Rte_00069] Communication timeouts</strong></p>\n<p><strong>[SRS_Rte_00073] Atomic transport of Data Elements</strong></p>\n<p><strong>[SRS_Rte_00082] Standardized communication protocol</strong></p>\n<p><strong>[SRS_Rte_00091] Inter-ECU Marshalling</strong></p>\n<p><strong>[SRS_Rte_00181] Conversion between internal and network data types</strong></p>\n<p><strong>[SRS_Rte_00246] Support of Efficient COM for large data</strong></p>\n<p><strong>[SRS_Rte_00251] Array based signal group handling with Com</strong></p>\n<p><strong>[SRS_Rte_00322] Support of Metadata</strong></p>\n<h2 id=\"413-interaction-with-application-software-components\"><a class=\"anchor\" href=\"#413-interaction-with-application-software-components\">#</a> <strong>4.1.3</strong> <strong>Interaction with Application Software Components</strong></h2>\n<p><strong>[SRS_Rte_00011] Support for multiple Application Software Component instances.</strong></p>\n<p><strong>[SRS_Rte_00012] Multiple instantiated AUTOSAR software components delivered as binary code shall share code</strong></p>\n<p><strong>[SRS_Rte_00013] Per-instance memory</strong></p>\n<p><strong>[SRS_Rte_00077] Instantiation of per-instance memory</strong></p>\n<p><strong>[SRS_Rte_00017] Rejection of inconsistent component implementations</strong></p>\n<p><strong>[SRS_Rte_00134] Runnable Entity categories supported by the RTE</strong></p>\n<p><strong>[SRS_Rte_00072] Activation of Runnable Entities</strong></p>\n<p>RTE 要根据事件触发任务</p>\n<p><strong>[SRS_Rte_00160] Debounced start of Runnable Entities</strong></p>\n<p><strong>消抖，短时间内只触发一次</strong></p>\n<p><strong>[SRS_Rte_00161] Activation offset of Runnable Entities</strong></p>\n<p><strong>[SRS_Rte_00031] Multiple Runnable Entities</strong></p>\n<p><strong>[SRS_Rte_00032] Data consistency mechanisms</strong></p>\n<p><strong>数据一致性的机制</strong></p>\n<p><strong>[SRS_Rte_00046] Support for \"Executable Entity runs inside\" Exclusive Areas</strong></p>\n<p><strong>[SRS_Rte_00142] Support for InterRunnableVariables</strong></p>\n<p><strong>[SRS_Rte_00033] Serialized execution of Server Runnable Entities</strong></p>\n<p>RTE 支持运行实体的序列化执行</p>\n<p><strong>[SRS_Rte_00133] Concurrent invocation of Runnable Entities</strong></p>\n<p>可并发</p>\n<p><strong>[SRS_Rte_00143] Mode Switches</strong></p>\n<p><strong>[SRS_Rte_00176] Sharing of NVRAM data</strong></p>\n<p><strong>[SRS_Rte_00180] DataSemantics range check during runtime</strong></p>\n<p>支持一些数据的检查</p>\n<p><strong>[SRS_Rte_00182] Self Scaling Signals at Port Interfaces</strong></p>\n<p><strong>[SRS_Rte_00236] Support for ModeInterfaceMapping</strong></p>\n<p><strong>[SRS_Rte_00237] Time recurrent activation of Runnable Entities</strong></p>\n<p>可定时循环激活运行实体</p>\n<h2 id=\"414-interaction-with-basic-software-components\"><a class=\"anchor\" href=\"#414-interaction-with-basic-software-components\">#</a> <strong>4.1.4</strong> <strong>Interaction with Basic Software Components</strong></h2>\n<p><strong>[SRS_Rte_00152] Support for port-defined argument values</strong></p>\n<p><strong>[SRS_Rte_00022] Interaction with call-backs</strong></p>\n<p><strong>[SRS_Rte_00062] Local access to basic software components</strong></p>\n<p>支持本地通过 BSW，也可以远程通过其他 ECU 的 BSW</p>\n<p><strong>[SRS_Rte_00169] Map code and memory allocated by the RTE to memory sections</strong></p>\n<p><strong>[SRS_Rte_00170] Provide used memory sections description</strong></p>\n<p><strong>[SRS_Rte_00177] Support of NvBlockComponentType</strong></p>\n<p><strong>[SRS_Rte_00228] Fan-out NvBlock callback function</strong></p>\n<p><strong>[SRS_Rte_00233] Generation of the Basic Software Module Description</strong></p>\n<p><strong>[SRS_Rte_00241] Support for Local or Remote Handling of BSW Service Calls on Partitioned Systems</strong></p>\n<blockquote>\n<p>For systems where the BSW modules can be executed in multiple partitions, the RTE generator shall redirect the BSW service call from a SWC either to the local or to a remote partition based on the partition mapping(s) assigned to the BSW Module.</p>\n</blockquote>\n<p><strong>[SRS_Rte_00245] Support of Writing Strategies for NV data</strong></p>\n<h2 id=\"415-generation-of-the-bsw-scheduler\"><a class=\"anchor\" href=\"#415-generation-of-the-bsw-scheduler\">#</a> <strong>4.1.5</strong> <strong>Generation of the BSW Scheduler</strong></h2>\n<p><strong>[SRS_Rte_00211] Cyclic time based scheduling of BSW Schedulable Entities</strong></p>\n<p><strong>[SRS_Rte_00212] Activation Offset of BSW Schedulable Entities</strong></p>\n<p><strong>[SRS_Rte_00213] Mode Switches for BSW Modules</strong></p>\n<p><strong>[SRS_Rte_00214] Common Mode handling for Basic SW and Application SW</strong></p>\n<p><strong>[SRS_Rte_00215] API for Mode switch notification to the SchM</strong></p>\n<p><strong>[SRS_Rte_00216] Triggering of BSW Schedulable Entities by occurrence of External Trigger</strong></p>\n<p>支持外部的触发源</p>\n<p><strong>[SRS_Rte_00230] Triggering of BSW Schedulable Entities by occurrence of Internal Trigger</strong></p>\n<p><strong>[SRS_Rte_00217] Synchronized activation of Runnable Entities and BSW Schedulable Entities</strong></p>\n<p><strong>[SRS_Rte_00218] API for Triggering BSW modules by Triggered Events</strong></p>\n<p><strong>[SRS_Rte_00219] Support for interlaced execution sequences of Runnable Entities and BSW Schedulable Entities</strong></p>\n<p><strong>[SRS_Rte_00220] ECU life cycle dependent scheduling</strong></p>\n<p><strong>[SRS_Rte_00221] Support for \"BSW integration\" builds</strong></p>\n<p><strong>[SRS_Rte_00222] Support shared exclusive areas in BSW Service Modules and the corresponding Service Component</strong></p>\n<p><strong>[SRS_Rte_00229] Support for Variant Handling of BSW Modules</strong></p>\n<p><strong>[SRS_Rte_00243] Support for inter-partition communication of BSW modules</strong></p>\n<h2 id=\"416-support-for-measurement-and-calibration\"><a class=\"anchor\" href=\"#416-support-for-measurement-and-calibration\">#</a> <strong>4.1.6</strong> <strong>Support for Measurement and Calibration</strong></h2>\n<p><strong>[SRS_Rte_00153] Support for Measurement</strong></p>\n<p><strong>[SRS_Rte_00154] Support for Calibration</strong></p>\n<p><strong>[SRS_Rte_00156] Support for different calibration data emulation methods</strong></p>\n<blockquote>\n<p>The RTE generator shall support these data emulation methods for calibration purposes:</p>\n<p>directAccess</p>\n<p>Calibration data is stored in ROM and accessed directly. This method can be used with appropriate calibration hardware.</p>\n<p>Single pointered method</p>\n<p>Calibration data accesses are done via one indirection over a pointer table in</p>\n<p>RAM</p>\n<p>Double pointered method</p>\n<p>Calibration data accesses are done via a base pointer in RAM and over a pointer table in ROM/FLASH</p>\n<p>InitRAM parameter method</p>\n<p>RTE accesses calibration parameters located in RAM directly (without any indirection) and copies the values from ROM/FLASH during startup</p>\n<p>Methods 2-4 need SW support from RTE.</p>\n</blockquote>\n<p>要支持数据校准</p>\n<p><strong>[SRS_Rte_00157] Support for calibration parameters in NVRAM</strong></p>\n<p><strong>[SRS_Rte_00158] Support separation of calibration parameters</strong></p>\n<p><strong>[SRS_Rte_00159] Sharing of calibration parameters</strong></p>\n<p><strong>[SRS_Rte_00189] A2L Generation Support</strong></p>\n<h2 id=\"417-general-requirements\"><a class=\"anchor\" href=\"#417-general-requirements\">#</a> <strong>4.1.7</strong> <strong>General Requirements</strong></h2>\n<p><strong>[SRS_Rte_00021] Per-ECU RTE customization</strong></p>\n<blockquote>\n<p>The RTE shall be customizable (generated and/or configured) for each ECU.</p>\n<p>The RTE generator should avoid, where possible, the use of generic functions and should, instead, favor functions that are configured/generated to specifically implement the required communication patterns.</p>\n</blockquote>\n<p>RTE 应该客制化，配置化，尽量避免使用通用的 API</p>\n<p><strong>[SRS_Rte_00065] Deterministic generation</strong></p>\n<p><strong>[SRS_Rte_00028] \"1:n\" Sender-receiver communication</strong></p>\n<p><strong>[SRS_Rte_00131] \"n:1\" Sender-receiver communication</strong></p>\n<p><strong>[SRS_Rte_00029] \"n:1\" Client-server communication</strong></p>\n<blockquote>\n<p>The RTE shall support multiple-client-single-server (\"n:1\") client-server (function invocation) communication. Individual clients are independent - there is no coordination of requests between clients.</p>\n<p>Single-client-multiple-server (\"1:n\") communication is not required. Such communication raises issues about buffering and selection of results that are application dependent and therefore not considered to be the domain of the RTE.</p>\n</blockquote>\n<p>不需要单客户端多服务端</p>\n<p><strong>[SRS_Rte_00079] Single asynchronous client-server interaction</strong></p>\n<p>一次只支持单个的异步交互</p>\n<p><strong>[SRS_Rte_00080] Multiple requests of servers</strong></p>\n<p>支持多个客户端对服务端的并发请求，服务端进行请求队列排队</p>\n<p><strong>[SRS_Rte_00162] \"1:n\" External Trigger communication</strong></p>\n<p><strong>[SRS_Rte_00163] Support for InterRunnableTriggering</strong></p>\n<p><strong>[SRS_Rte_00235] Support queued triggers</strong></p>\n<p><strong>[SRS_Rte_00025] Static communication</strong></p>\n<blockquote>\n<p>The RTE shall support only those communication connections known when the RTE is generated - the source(s) and destination(s) of all communication shall be known statically</p>\n</blockquote>\n<p>也就是说，服务器端的接口都是定义好的，都是静态的。只有订阅者是动态的。</p>\n<p><strong>[SRS_Rte_00144] RTE shall support the notification of mode switches via AUTOSAR interfaces</strong></p>\n<p>定义好接口机制，在模式切换时做好 trace 函数接口</p>\n<p><strong>[SRS_Rte_00018] Rejection of invalid configurations</strong></p>\n<p><strong>[SRS_Rte_00055] RTE use of global namespace</strong></p>\n<blockquote>\n<p>All symbols use the prefix \"RTE\".</p>\n</blockquote>\n<p><strong>[SRS_Rte_00164] Ensure a unique naming of generated types visible in the global namespace</strong></p>\n<p><strong>[SRS_Rte_00165] Suppress identical \"C\" type re-definitions</strong></p>\n<p><strong>[SRS_Rte_00166] Use the AUTOSAR Standard Types in the global namespace if the AUTOSAR data type is mapped to an AUTOSAR Standard Type</strong></p>\n<p><strong>[SRS_Rte_00167] Encapsulate a Software Component local name space</strong></p>\n<p><strong>[SRS_Rte_00252] Encapsulate a BSW Module local name space</strong></p>\n<p><strong>[SRS_Rte_00126] C language support</strong></p>\n<p><strong>[SRS_Rte_00138] C++ language support</strong></p>\n<p><strong>[SRS_Rte_00051] RTE API mapping</strong></p>\n<p><strong>[SRS_Rte_00048] RTE Generator input</strong></p>\n<p><strong>[SRS_Rte_00023] RTE Overheads</strong></p>\n<p><strong>[SRS_Rte_00024] Source-code AUTOSAR software components</strong></p>\n<p><strong>[SRS_Rte_00140] Binary-code AUTOSAR software components</strong></p>\n<p><strong>[SRS_Rte_00083] Optimization for source-code components</strong></p>\n<p><strong>[SRS_Rte_00027] VFB to RTE mapping shall be semantic preserving</strong></p>\n<p><strong>[SRS_Rte_00190] Support for variable-length Data Types</strong></p>\n<p><strong>[SRS_Rte_00234] Support for Record Type sub-setting</strong></p>\n<blockquote>\n<p>4 wheel speed signals and the movement direction signal are provided in one record. If a receiver is only interested in the movement direction information all of the other information from this record does not have to be considered at this specific receiver.</p>\n</blockquote>\n<p><strong>[SRS_Rte_00098] Explicit Sending</strong></p>\n<p><strong>[SRS_Rte_00129] Implicit Sending</strong></p>\n<p><strong>[SRS_Rte_00128] Implicit Reception</strong></p>\n<p><strong>[SRS_Rte_00141] Explicit Reception</strong></p>\n<p><strong>[SRS_Rte_00092] Implementation of VFB model \"waitpoints\"</strong></p>\n<p>支持等待点，事件触发后继续执行</p>\n<p><strong>[SRS_Rte_00145] Compatibility mode</strong></p>\n<p><strong>[SRS_Rte_00146] Vendor mode</strong></p>\n<p>有一个供应商的操作模式</p>\n<p><strong>[SRS_Rte_00148] Support \"Specification of Memory Mapping\"</strong></p>\n<p><strong>[SRS_Rte_00150] Support \"Specification of Platform Types\"</strong></p>\n<p><strong>[SRS_Rte_00151] Support RTE relevant requirements of the \"General Requirements on Basic Software Modules\"</strong></p>\n<p><strong>[SRS_Rte_00171] Support for fixed and constant data</strong></p>\n<p><strong>[SRS_Rte_00178] Data consistency of NvBlockComponentType</strong></p>\n<p><strong>[SRS_Rte_00179] Support of Update Flag for Data Reception</strong></p>\n<p>有个标志位来标识是否有数据更新</p>\n<p><strong>[SRS_Rte_00184] RTE Status \"Never Received\"</strong></p>\n<p><strong>[SRS_Rte_00191] Support for Variant Handling</strong></p>\n<p><strong>[SRS_Rte_00201] Contract Phase with Variant Handling support</strong></p>\n<p><strong>[SRS_Rte_00202] Support for array size variants</strong></p>\n<p><strong>[SRS_Rte_00204] Support the selection / de-selection of SWC prototypes</strong></p>\n<p><strong>[SRS_Rte_00206] Support the selection of a signal provider</strong></p>\n<p><strong>[SRS_Rte_00207] Support N to M communication patterns while unresolved variations are affecting these communications</strong></p>\n<p><strong>[SRS_Rte_00231] Support native interface between Rte and Com for Strings and uint8 arrays</strong></p>\n<p><strong>[SRS_Rte_00232] Synchronization of runnable entities</strong></p>\n<p><strong>[SRS_Rte_00238] Allow enabling of RTE-Feature to get the activating Event of Executable Entity</strong></p>\n<p><strong>[SRS_Rte_00244] Support for bypass</strong></p>\n<p><strong>[SRS_Rte_00254] Selectable RP Preparation</strong></p>\n<p><strong>[SRS_Rte_00255] RP Memory Interface</strong></p>\n<p><strong>[SRS_Rte_00256] Conditional Bypass</strong></p>\n<p><strong>[SRS_Rte_00257] RunnableEntity Bypass</strong></p>\n<p><strong>[SRS_Rte_00258] RTE Generated Service Points</strong></p>\n<p><strong>[SRS_Rte_00259] Manually Inserted Service Points</strong></p>\n<p><strong>[SRS_Rte_00260] RP Interface Documentation</strong></p>\n<p><strong>[SRS_Rte_00247] The Rte shall execute transformer chains for SWC communication</strong></p>\n<p><strong>[SRS_Rte_00248] The Rte shall provide the buffer for the data transformation</strong></p>\n<p><strong>[SRS_Rte_00249] The Rte shall provide transformation errors to the SWCs</strong></p>\n<p><strong>[SRS_Rte_00253] The RTE shall execute data transformation for SWC/BSW communication within one ECU</strong></p>\n<p><strong>[SRS_Rte_00250] The Rte shall provide size indications of variable size arrays to SWCs</strong></p>\n<p>对可变大小的数组要指示出长度信息</p>\n<p><strong>[SRS_Rte_00261] The RTE shall support optional struct members.</strong></p>\n<h2 id=\"418-vfb-tracing\"><a class=\"anchor\" href=\"#418-vfb-tracing\">#</a> <strong>4.1.8</strong> <strong>VFB Tracing</strong></h2>\n<p><strong>[SRS_Rte_00005] The RTE generator shall support \"trace\" builds</strong></p>\n<p>支持 trace，这里会有很多接口来追踪代码</p>\n<p><strong>[SRS_Rte_00045] Standardized VFB tracing interface</strong></p>\n<p><strong>[SRS_Rte_00008] VFB tracing configuration</strong></p>\n<p><strong>[SRS_Rte_00192] Support multiple trace clients</strong></p>\n<p><strong>[SRS_Rte_00003] Tracing of sender-receiver communication</strong></p>\n<p><strong>[SRS_Rte_00004] Tracing of client-server communication</strong></p>\n<h2 id=\"419-application-software-component-initialization-and-finalization\"><a class=\"anchor\" href=\"#419-application-software-component-initialization-and-finalization\">#</a> <strong>4.1.9</strong> <strong>Application Software Component Initialization and Finalization</strong></h2>\n<p><strong>[SRS_Rte_00052] Initialization and finalization of components</strong></p>\n<p><strong>[SRS_Rte_00070] Invocation order of Runnable Entities</strong></p>\n<p><strong>[SRS_Rte_00239] Support rule-based initialization of composite DataPrototypes and compound primitive DataPrototypes</strong></p>\n<p><strong>[SRS_Rte_00240] Support of init runnables for initialization purposes</strong></p>\n<h2 id=\"4110-api\"><a class=\"anchor\" href=\"#4110-api\">#</a> <strong>4.1.10</strong> <strong>API</strong></h2>\n<p><strong>[SRS_Rte_00100] Compiler independent API</strong></p>\n<p><strong>[SRS_Rte_00168] Typing of RTE API.</strong></p>\n<p><strong>[SRS_Rte_00059] RTE API shall pass \"in\" primitive data types by value</strong></p>\n<p><strong>[SRS_Rte_00060] RTE API shall pass \"in\" composite data types by reference</strong></p>\n<blockquote>\n<p>Pass by reference is efficient for large data types.</p>\n</blockquote>\n<p><strong>[SRS_Rte_00061] \"in/out\" and \"out\" parameters</strong></p>\n<blockquote>\n<p>The RTE API shall pass ‘in/out’ and \"out\" formal parameters by reference.</p>\n</blockquote>\n<p><strong>[SRS_Rte_00115] API for data consistency mechanism</strong></p>\n<p><strong>[SRS_Rte_00075] API for accessing per-instance memory</strong></p>\n<p><strong>[SRS_Rte_00107] Support for INFORMATION_TYPE attribute</strong></p>\n<p><strong>[SRS_Rte_00108] Support for INIT_VALUE attribute</strong></p>\n<p><strong>[SRS_Rte_00109] Support for RECEIVE_MODE attribute</strong></p>\n<p><strong>[SRS_Rte_00110] Support for BUFFERING attribute</strong></p>\n<p><strong>[SRS_Rte_00111] Support for CLIENT_MODE attribute</strong></p>\n<p><strong>[SRS_Rte_00121] Support for FILTER attribute</strong></p>\n<p><strong>[SRS_Rte_00147] Support for communication infrastructure time-out notification</strong></p>\n<p><strong>[SRS_Rte_00078] Support for Data Element Invalidation</strong></p>\n<p><strong>[SRS_Rte_00122] Support for Transmission Acknowledgement</strong></p>\n<p><strong>[SRS_Rte_00094] Communication and Resource Errors</strong></p>\n<p><strong>[SRS_Rte_00084] Support infrastructural errors</strong></p>\n<p><strong>[SRS_Rte_00123] The RTE shall forward application level errors from server to client</strong></p>\n<p><strong>[SRS_Rte_00124] API for application level errors during Client Server communication</strong></p>\n<p><strong>[SRS_Rte_00089] Independent access to interface elements</strong></p>\n<p><strong>[SRS_Rte_00137] API for mismatched ports</strong></p>\n<p><strong>[SRS_Rte_00139] Support for unconnected ports</strong></p>\n<p><strong>[SRS_Rte_00200] Support of unconnected R-Ports</strong></p>\n<p><strong>[SRS_Rte_00155] API to access calibration parameters</strong></p>\n<p><strong>[SRS_Rte_00183] RTE Read API returning the dataElement value</strong></p>\n<p><strong>[SRS_Rte_00185] RTE API with Rte_IFeedback</strong></p>\n<p><strong>[SRS_Rte_00203] API to read system constant</strong></p>\n<p><strong>[SRS_Rte_00242] Support for Cross-Core Exclusive Areas</strong></p>\n<h2 id=\"4111-cc-api\"><a class=\"anchor\" href=\"#4111-cc-api\">#</a> <strong>4.1.11</strong> C/C++ API</h2>\n<p><strong>[SRS_Rte_00087] Software Module Header File generation</strong></p>\n<h2 id=\"4112-initialization-and-finalization-operation\"><a class=\"anchor\" href=\"#4112-initialization-and-finalization-operation\">#</a> <strong>4.1.12</strong> <strong>Initialization and Finalization Operation</strong></h2>\n<p><strong>[SRS_Rte_00116] RTE Initialization and finalization</strong></p>\n<h2 id=\"4113-partition-restarting-and-termination\"><a class=\"anchor\" href=\"#4113-partition-restarting-and-termination\">#</a> <strong>4.1.13</strong> <strong>Partition Restarting and Termination</strong></h2>\n<p><strong>[SRS_Rte_00196] Inter-partition communication consistency</strong></p>\n<h2 id=\"4114-fault-operation\"><a class=\"anchor\" href=\"#4114-fault-operation\">#</a> <strong>4.1.14</strong> <strong>Fault Operation</strong></h2>\n<h2 id=\"4115-rte-implementation-plug-ins\"><a class=\"anchor\" href=\"#4115-rte-implementation-plug-ins\">#</a> <strong>4.1.15</strong> <strong>RTE Implementation Plug-Ins</strong></h2>\n<p><strong>[SRS_Rte_00318] Modular Runtime Environment</strong></p>\n<p><strong>[SRS_Rte_00300] RTE Implementation Plug-Ins for explicit communication</strong></p>\n<blockquote>\n<p>The RTE shall support to implement for explicit communication following subfunctionality</p>\n<p><em>•</em> getting a semaphore</p>\n<p><em>•</em> releasing a semaphore</p>\n<p><em>•</em> implementation of the semaphore</p>\n<p><em>•</em> accessing the global copy of the data</p>\n<p><em>•</em> invocation of transformers</p>\n<p><em>•</em> APIs to enable the communication across different ASIL levels</p>\n<p><em>•</em> APIs to enable the communication between Software Clusters</p>\n<p>via RTE Implementation Plug-Ins outside the RTE Generator. This includes port based communication as well as Inter Runnable Variables.</p>\n</blockquote>\n<p><strong>[SRS_Rte_00301] RTE Implementation Plug-Ins for implicit communication</strong></p>\n<p><strong>[SRS_Rte_00320] RTE Implementation Plug-Ins for implicit communication II</strong></p>\n<p><strong>[SRS_Rte_00302] RTE Implementation Plug-Ins for exclusive areas</strong></p>\n<p><strong>[SRS_Rte_00303] RTE Implementation Plug-Ins for global copy instantiation</strong></p>\n<p><strong>[SRS_Rte_00304] Multiple RTE Plug-Ins</strong></p>\n<p><strong>[SRS_Rte_00305] Graduated validation strategy</strong></p>\n<p><strong>[SRS_Rte_00306] Standardized interfaces for RTE Implementation Plug-Ins</strong></p>\n<p><strong>[SRS_Rte_00307] RTE Implementation Plug-Ins for cross core communication</strong></p>\n<p><strong>[SRS_Rte_00309] RTE Implementation Plug-Ins for cross safety partition communication</strong></p>\n<p><strong>[SRS_Rte_00310] Shared mode queue</strong></p>\n<p><strong>[SRS_Rte_00311] Core synchronous transitions for mode switches</strong></p>\n<p><strong>[SRS_Rte_00312] RTE Implementation Plug-Ins for transformers in client server communication</strong></p>\n<p><strong>[SRS_Rte_00317] RTE Implementation Plug-Ins for transformers in trigger communication</strong></p>\n<p><strong>[SRS_Rte_00319] RTE Implementation Plug-Ins for parameter communication</strong></p>\n<p><strong>[SRS_Rte_00313] Description of RTE Implementation Plug-in properties</strong></p>\n<p><strong>[SRS_Rte_00314] Avoid nesting of critical sections</strong></p>\n<p><strong>[SRS_Rte_00315] Protection of mode machine instance access</strong></p>\n<p><strong>[SRS_Rte_00321] RTE Implementation Plug-Ins for mode communication</strong></p>\n<p><strong>[SRS_Rte_00316] RTE Implementation Plug-Ins for compatibility mode</strong></p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "AUTOSAR",
                "AUTOSAR"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/3c8f29a7.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/3c8f29a7.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（2）嵌入式操作系统概述",
            "date_published": "2024-10-20T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列四-嵌入式系统软件基础知识2嵌入式操作系统概述\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列四-嵌入式系统软件基础知识2嵌入式操作系统概述\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（2）嵌入式操作系统概述</h1>\n<h1 id=\"嵌入式操作系统\"><a class=\"anchor\" href=\"#嵌入式操作系统\">#</a> 嵌入式操作系统</h1>\n<p>(Embedded Operating System，EOS) 是一种支持嵌入式系统应用的操作系统软件，它是嵌入式开发中极为重要的组成部分，通常包括与硬件相关的底层驱动软件、系统内核、设备驱动接口、通信协议、图形界面、标准化浏览器等。与通用操作系统相比，嵌入式操作系统在系统实时高效性、硬件的相关依赖性、软件固态化以及应用的专用性等方面具有较为突出的特点。</p>\n<p>在 20 世纪 60 年代，嵌入式操作系统首先出现在国防系统中，并于 20 世纪 70~80 年代逐渐进入工业控制领域。经过几十多年的发展，目前已广泛应用在工业、交通、能源、通信、医疗卫生、国防、日常生活等诸多领域。</p>\n<p>与通用的操作系统一样，可以从两个方面来描述嵌入式操作系统的功能。</p>\n<h2 id=\"1从软件开发的角度\"><a class=\"anchor\" href=\"#1从软件开发的角度\">#</a> (1) 从软件开发的角度，</h2>\n<p>可以把 EOS 看成是一种扩展机或虚拟机。它把底层的硬件细节封装起来，为运行在它上面的软件 (如中间件软件和各种应用软件) 提供了一个抽象的编程接口。软件的开发不是直接在机器硬件的层面上进行，而是在这个编程接口的层面上进行。</p>\n<h2 id=\"2从系统管理的角度\"><a class=\"anchor\" href=\"#2从系统管理的角度\">#</a> (2) 从系统管理的角度，</h2>\n<p>可以把 EOS 看成是系统资源的管理者，负责管理系统当中的各种软硬件资源，如处理器、内存、各种 IO 设备、文件和数据等等，使得整个系统能够高效、可靠地运转。</p>\n<p>EOS 除了具有通用操作系统的基本功能之外，还有一些与嵌入式系统密切相关的特点:</p>\n<ul>\n<li>其目标是为了完成某一项或有限项功能，而非通用型的操作系统；</li>\n<li>在性能和实时性方面可能有严格的限制；</li>\n<li>能源、成本和可靠性通常是影响设计的重要因素；</li>\n<li>占用资源少，适合在有限存储空间运行；</li>\n<li>系统功能可针对需求进行裁剪、调整，以便满足最终产品的设计要求。</li>\n</ul>\n<p>对于不同的嵌入式操作系统，它们所包含的组件可能各不相同，但是一般来说，所有的操作系统都会有一个内核。所谓的内核，是指系统当中的一个组件，它包含了 OS 的主要功能，即 OS 的各种特性及其相互之间的依赖关系。这些功能包括：任务管理、存储管理、输入 / 输出设备管理和文件系统管理。</p>\n<p>操作系统在计算机系统中处于系统软件的核心地位，是用户和计算机系统的界面。每个用户都是通过操作系统来使用计算机的。每个程序都要通过操作系统获得必要的资源以后才能执行。例如，程序执行前必须获得内存资源才能装入：程序执行要依靠处理机；程序在执行时需要调用子程序或者使用系统中的文件；执行过程中可能还要使用外部设备输入 / 输出数据。操作系统将根据用户的需要，合理而有效地进行资源分配。</p>\n<p>一个计算机系统可以分为如下的四个层次：硬件层、操作系统层、系统软件和应用软件层，如图 4-8 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-21%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20241015211343465.png\" alt=\"image-20241015211343465\"></p>\n<p>每一层都表示一组功能和一个界面，表现为一种单向服务的关系，即上一层的软件必须以事先约定的方式使用下一层软件或者硬件提供的服务。</p>\n<p>为了提高计算机系统的效率，增强系统的处理能力，最大限度地提高资源利用率，并方便用户使用，现代操作系统广泛采用了并行操作技术使硬件和软件并行工作。因此，以多道程序为基础的现代操作系统具有以下特征。</p>\n<h2 id=\"1-并发性\"><a class=\"anchor\" href=\"#1-并发性\">#</a> 1、并发性</h2>\n<p>并发是两个或两个以上的事件在同一时间间隔内发生。对于程序而言，并发也就是多道程序在同一时间间隔内同时执行。对于单处理机系统而言，程序并发执行实际上是多道程序在一个很小的时间段内交替执行。而宏观上看，它们似乎是在同时进行，即并发执行。实现并发性，使操作系统变得复杂。因为要考虑如何从一个程序转到另一个程序，如何保护一个程序不受另一个程序侵扰，以及如何实现相互制约等。单处理机系统中，每一时刻只能执行一道程序，因此微观上这些程序是交替执行的。</p>\n<h2 id=\"2-共享性\"><a class=\"anchor\" href=\"#2-共享性\">#</a> 2、共享性</h2>\n<p>共享性就是资源共享，即计算机系统中的硬、软件资源供所有授权程序或用户共同使用。实际上，由于系统中的资源有限，当多道程序并发执行时，必然要共享系统中的硬、软件资源。因此，程序并发执行必然依赖于资源共享机制的支持，如图 4-9 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-21%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20241015211626047.png\" alt=\"image-20241015211626047\"></p>\n<h2 id=\"3-虚拟性\"><a class=\"anchor\" href=\"#3-虚拟性\">#</a> 3、虚拟性</h2>\n<p>所谓虚拟，是采用某种方法把一个物理实体映射为一个或者多个逻辑实体。前者是客观存在的，后者只是在感觉或效果上存在。例如在多道程序系统中，虽然只有一个 CPU, 每次只能执行一道程序；但是采用多道程序技术后，在一段时间内，宏观上看有多个程序在运行，似乎是多个 CPU 在运行各自的程序。也就是说，一个物理上的 CPU 虚拟为多个逻辑上的 CPU，即虚拟处理机。类似的还有虚拟存储器、虚拟外围设备等。</p>\n<p>与其他类型的操作系统相比，嵌入式操作系统具有以下一些特点。</p>\n<h2 id=\"1体积小\"><a class=\"anchor\" href=\"#1体积小\">#</a> (1) 体积小。</h2>\n<p>嵌入式系统大多使用闪存作为存储介质，因此只能运行在有限的内存中，不能使用虚拟内存，中断的使用也受到限制。因此，嵌入式操作系统必须结构紧凑，体积微小。</p>\n<h2 id=\"2实时性\"><a class=\"anchor\" href=\"#2实时性\">#</a> (2) 实时性。</h2>\n<p>大多数嵌入式系统都是实时系统，而且多是强实时多任务系统，要求相应的嵌入式操作系统也必须是实时操作系统，重点解决实时多任务调度算法和可调度性、死锁解除等问题。</p>\n<h2 id=\"3特殊的开发调试环境\"><a class=\"anchor\" href=\"#3特殊的开发调试环境\">#</a> (3) 特殊的开发调试环境。</h2>\n<p>一个完整的嵌入式系统集成开发环境一般包括编译 / 连接器、内核调试 / 跟踪器和集成图形界面开发平台，其中的集成图形界面开发平台包括编辑器、调试器、软件仿真器和监视器等。</p>\n<h1 id=\"一-嵌人式操作系统的分类\"><a class=\"anchor\" href=\"#一-嵌人式操作系统的分类\">#</a> 一、嵌人式操作系统的分类</h1>\n<p>操作系统的分类有多种方法，常见的有按照所提供的功能分类、按照系统的类型分类、按照响应时间分类、按照软件结构分类等。</p>\n<h2 id=\"1-按提供的功能分类\"><a class=\"anchor\" href=\"#1-按提供的功能分类\">#</a> 1、按提供的功能分类</h2>\n<p>按照操作系统所提供的功能进行分类是最常见的方式，可以分为以下几类。</p>\n<h2 id=\"1单用户操作系统\"><a class=\"anchor\" href=\"#1单用户操作系统\">#</a> (1) 单用户操作系统。</h2>\n<p>其主要特征是，在一个计算机系统内，一次只能支持运行一个用户程序。此用户独占计算机系统的全部硬件、软件资源。早期的微机操作系统例如 DOS 是这样的操作系统。</p>\n<h2 id=\"2批处理操作系统\"><a class=\"anchor\" href=\"#2批处理操作系统\">#</a> (2) 批处理操作系统。</h2>\n<p>用户把要计算的问题、数据、作业说明书等一起交给系统操作员，系统操作员将一批算题输入计算机，然后由操作系统控制执行。采用这种批处理作业技术的操作系统称为批处理操作系统。这类操作系统又分为批处理单道系统和批处理多道系统。</p>\n<h2 id=\"3实时操作系统\"><a class=\"anchor\" href=\"#3实时操作系统\">#</a> (3) 实时操作系统。</h2>\n<p>“实时” 是 “立即” 的意思。典型的实时操作系统包括过程控制系统、信息查询系统和事务处理系统。实时系统是较少有人为干预的监督和控制系统。其软件依赖于应用的性质和实际使用的计算机的类型。实时系统的基本特征是事件驱动设计，即当接到某种类型的外部信息时，由系统选择相应的程序去处理。</p>\n<h2 id=\"4分时操作系统\"><a class=\"anchor\" href=\"#4分时操作系统\">#</a> (4) 分时操作系统。</h2>\n<p>这是一种使用计算机为一组用户服务，使每个用户仿佛自己有一台支持自己请求服务的计算机的操作系统。分时操作系统的主要目的是对联机用户的服务和相应，具有同时性、独立性、及时性、交互性。分时操作系统中，分时是指若干道程序对 CPU 的分时，通过设立一个时间分享单位即时间片来实现。分时操作系统与实时操作系统的主要差别在交互能力和响应时间上。分时系统交互行强，而实时系统响应时间要求高。</p>\n<h2 id=\"5网络操作系统\"><a class=\"anchor\" href=\"#5网络操作系统\">#</a> (5) 网络操作系统。</h2>\n<p>提供网络通信和网络资源共享功能的操作系统称为网络操作系统。它是负责管理整个网络资源和方便网络用户的软件的集合。网络操作系统除了一般操作系统的五大功能之外，还应具有网络管理模块。后者的主要功能是，提供高效而可靠的网络通信能力；提供多种网络服务，如远程作业录入服务、分时服务、文件传输服务等。</p>\n<h2 id=\"6分布式操作系统\"><a class=\"anchor\" href=\"#6分布式操作系统\">#</a> (6) 分布式操作系统。</h2>\n<p>分布式系统是由多台微机组成且满足如下条件的系统：系统中任意两台计算机可以通过通信交换信息；系统中的计算机无主次之分；系统中的资源供所有用户共享：一个程序可以分布在几台计算机上并行地运行，互相协作完成一个共同的任务。用于管理分布式系统资源的操作系统称为分布式操作系统，</p>\n<p>嵌入式操作系统也可以按照不同的标准来进行分类，例如，可以按照系统的类型、响应时间和软件结构来分类。</p>\n<h2 id=\"2-按系统的类型分类\"><a class=\"anchor\" href=\"#2-按系统的类型分类\">#</a> 2、按系统的类型分类</h2>\n<p>按照系统的类型，可以把嵌入式操作系统分为三大类：商用系统、专用系统和开源系统</p>\n<h2 id=\"1商用系统\"><a class=\"anchor\" href=\"#1商用系统\">#</a> (1) 商用系统。</h2>\n<p>商业化嵌入式操作系统特点是功能强大、性能稳定、应用范围相对较广，而且辅助软件工具齐全，可以胜任许多不同的应用领域。但商用系统的价格通常比较昂贵，如果用于一般的产品会提高产品的成本从而失去竞争力。其典型代表是风河公司 (Wind River) 的 VxWorks、微软公司的 Windows CE、Palm 公司的 PalmOs 等</p>\n<h2 id=\"2专用系统\"><a class=\"anchor\" href=\"#2专用系统\">#</a> (2) 专用系统。</h2>\n<p>一些专业厂家为本公司产品特制的嵌入式操作系统，这种系统一般不提供给应用开发者使用。</p>\n<h2 id=\"3开源系统\"><a class=\"anchor\" href=\"#3开源系统\">#</a> (3) 开源系统。</h2>\n<p>开放源代码的嵌入式操作系统是近年来发展迅速的一类操作系统，其典型代表是 μC/OS 和各类嵌入式 Linux 系统。开源系统具有免费、开源、性能优良、资源丰富、技术支持强等优点，在信息家电、移动通信、网络设备和工业控制等领域得到越来越广泛的应用。</p>\n<h2 id=\"3-按响应时间分类\"><a class=\"anchor\" href=\"#3-按响应时间分类\">#</a> 3、按响应时间分类</h2>\n<p>按照系统对响应时间的敏感程度，可以把嵌入式操作系统分为两大类：实时操作系统和非实时操作系统。</p>\n<p>顾名思义，实时操作系统就是对响应时间要求非常严格的系统。当某一个外部事件或请求发生时，相应的任务必须在规定的时间内完成相应的处理。实时系统的正确性不仅依赖于系统计算的逻辑结果，还依赖于产生这些结果所需要的时间。</p>\n<p>实时操作系统可以分为硬实时和软实时两种情形。</p>\n<h2 id=\"1硬实时系统\"><a class=\"anchor\" href=\"#1硬实时系统\">#</a> (1) 硬实时系统。</h2>\n<p>系统对响应时间有严格的要求，绝不允许响应时间不能满足，否则可能会引起系统的崩溃或致命的错误。</p>\n<h2 id=\"2软实时系统\"><a class=\"anchor\" href=\"#2软实时系统\">#</a> (2) 软实时系统。</h2>\n<p>系统对响应时间有要求，如果响应时间不能满足，将带来额外的代价，不过这种代价通常能够接受。</p>\n<p>非实时系统在响应时间上没有严格的要求，如分时操作系统，它是基于公平性原则各个进程分享处理器，获得大致相同的运行时间。当一个进程在进行 O 操作时，会交出处理器，让其他的进程运行。</p>\n<h2 id=\"4-按软件结构分类\"><a class=\"anchor\" href=\"#4-按软件结构分类\">#</a> 4、按软件结构分类</h2>\n<p>按照软件的体系结构，可以把嵌入式操作系统分为三大类：单体结构、分层结构和微内核结构。它们之间的差别主要表现在两个方面：一是内核的设计，即在内核中包含了哪些功能组件；二是在系统中集成了哪些其他的系统软件 (如设备驱动程序和中间件)。</p>\n<h2 id=\"1单体结构\"><a class=\"anchor\" href=\"#1单体结构\">#</a> (1) 单体结构</h2>\n<p><img data-src=\"../../../img.assets/24-10-21%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20241015212757946.png\" alt=\"image-20241015212757946\"></p>\n<p>在单体结构的操作系统中，中间件和设备驱动程序通常就集成在系统内核当中。整个系统通常只有一个可执行文件，里面包含了所有的功能组件 (如图 4-10 所示)。系统的结构就是无结构，整个操作系统由一组功能模块组成，这些功能模块之间可以相互调用。例如，嵌入式 Linux 操作系统、Jbed RTOS、μC/OS-I 和 PDOS 都属于单体内核系统。</p>\n<p>单体结构的优点是性能较好，系统的各个模块之间可以相互调用，通信开销比较小。它的缺点是操作系统具有体积庞大、高度集成和相互关联等特点，因而在系统剪裁、修改和调试等方面都较为困难。</p>\n<h2 id=\"2分层结构\"><a class=\"anchor\" href=\"#2分层结构\">#</a> (2) 分层结构</h2>\n<p><img data-src=\"../../../img.assets/24-10-21%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20241015212819018.png\" alt=\"image-20241015212819018\"></p>\n<p>在分层结构中，一个操作系统被划分为若干个层次，各个层次之间的调用关系是单向的，即某一层上的代码只能调用比它低层的代码。与单体结构相似，分层结构的操作系统也是只有一个大的可执行文件，其中包含有设备驱动程序和中间件。由于采用了层次结构，所以系统的开发和维护都较为简单。但是，这种结构要求在每个层次上都要提供一组 API 接口函数，这就会带来额外的开销，从而影响到系统的规模和性能。图 4-11 所示为 MS-DOS 的结构，这是一个有代表性的、良好组织的分层结构。</p>\n<h2 id=\"3微内核结构\"><a class=\"anchor\" href=\"#3微内核结构\">#</a> (3) 微内核结构</h2>\n<p><img data-src=\"../../../img.assets/24-10-21%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%882%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20241015212857692.png\" alt=\"image-20241015212857692\"></p>\n<p>微内核结构或者客户 - 服务器结构的操作系统是指在内核中将操作系统的大部分功能都剥离出去，只保留最核心的功能单元 (如进程管理和存储管理)，微内核结构的特点就是内核非常小，大部分的系统功能都位于内核之外，例如设备驱动程序，所有的设备驱动程序都被置于内核之外，如图 4-12 所示。</p>\n<p>在微内核操作系统中，新的功能组件可以被动态地添加进来，所以它具有易于扩展、调试方便等特点。另外，由于大部分的系统功能被放置在内核之外，而且客户单元和服务器单元的内存地址空间是相互独立的，因此系统的安全性更高。它还有一个优点就是移植方便。但是，与其他类型的操作系统相比 (如单体内核)，微内核操作系统的运行速度可能会慢一些，这是因为核内组件与核外组件之间的通信方式是消息传递，而不是直接的函数调用。另外，由于它们的内存地址空间是相互独立的，所以在切换的时候，也会增加额外的开销。许多嵌入式操作系统采用的都是微内核的方式，如 OS-9、CExecutive、VxWorks、CMX-RTX、Nucleus Plus 和 ONX 等。</p>\n<h1 id=\"二-常见的嵌人式操作系统\"><a class=\"anchor\" href=\"#二-常见的嵌人式操作系统\">#</a> 二、常见的嵌人式操作系统</h1>\n<p>随着嵌入式系统在各个领域的广泛应用，嵌入式操作系统也得到了蓬勃的发展。从早期的实模式进化到保护模式，从微内核技术进化到超微内核技术，从支持单处理器发展到支持多处理器、分布式和实时网络，嵌入式操作系统已经成为操作系统研究领域中的一个重要分支。目前，国内外已经有数十家公司在从事相关方面的研究，开发了数以百计的各具特色的嵌入式操作系统产品，其中比较有影响的系统包括：VxWorks、嵌入式 Linux、Windows CE、uC/OS-II 和 PalmOS 等。<br>\n近年来，国内开发的自主操作系统包括：天脉操作系统、天操作系统、翼辉操作系统、锐华操作系统、道操作系统等。</p>\n<h2 id=\"1vxworks\"><a class=\"anchor\" href=\"#1vxworks\">#</a> (1)VxWorks</h2>\n<p>VxWorks 是美国 WindRiver System 公司开发的一款嵌入式实时操作系统，具有良好的可靠性和卓越的实时性，是目前嵌入式系统领域中使用最广泛、市场占有率最高的商业系统。VxWorks 支持各种主流的 32 位处理器，如 x86、Motorola MC68xxx、Coldfire、PowerPC、MIPS、ARM、i960 等。它基于微内核的体系结构，整个系统由 400 多个相对独立、短小精炼的目标模块组成，用户可以进行裁减和配置，根据自己的需要来选择适当的模块。VxWorks 采用 GNU 的编译和调试器，它的大多数 API 函数都是专有的。</p>\n<p>VxWorks 操作系统主要由以下几个功能模块组成:</p>\n<ul>\n<li>高效的实时微内核：这是 VxWorks 的核心，它包括基于优先级的任务调度、任务间的通信、同步和互斥、中断处理、定时器和内存管理机制等。</li>\n<li>IO 处理系统：VxWorks 提供了一个快速灵活的与 ANSIC 兼容的 IO 系统，包括 UNIX 标准的缓冲 I/O 和 POSIX 标准的异步 IO。</li>\n<li>文件系统：VxWorks 提供了适合于实时应用的文件系统，主要包括与 MS-DOS 兼容的文件系统、与 RT-11 兼容的文件系统、Raw Disk 文件系统和 SCSI 磁带设备。</li>\n<li>网络处理模块：能与许多运行其他协议的网络进行通信，如 TCP/IP、NFS、UDPSNMP、FTP 等。</li>\n<li>虚拟内存模块 VxVMI: 主要用于对指定内存区的保护，以加强系统的安全性。</li>\n<li>板级支持包 BSP: 是系统用来管理硬件的功能模块，对各种板卡的硬件功能提供了统一的接口，它由初始化和驱动程序两部分组成。</li>\n</ul>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c2149edd.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c2149edd.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（1）嵌入式软件基础",
            "date_published": "2024-10-18T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列四-嵌入式系统软件基础知识1嵌入式软件基础\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列四-嵌入式系统软件基础知识1嵌入式软件基础\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（1）嵌入式软件基础</h1>\n<p>随着技术发展，物理的计算、处理、存储等硬件资源越来越 “透明”、成熟和标准化，人们越来越关注人机界面和被控对象的软件控制规律。本章简要介绍嵌入式系统软件相关基础知识。</p>\n<h1 id=\"一-嵌入式软件基础\"><a class=\"anchor\" href=\"#一-嵌入式软件基础\">#</a> 一、嵌入式软件基础</h1>\n<p>嵌入式软件是指应用在嵌入式计算机系统当中的各种软件。在嵌入式系统的发展初期，软件的种类很少，规模也很小，基本上都是硬件的附属品。随着嵌入式系统应用的发展，特别是随着后 PC 时代的来临，嵌入式软件的种类和规模都得到了极大的发展，形成了一个完整、独立的体系。</p>\n<h2 id=\"1-嵌入式系统\"><a class=\"anchor\" href=\"#1-嵌入式系统\">#</a> 1、嵌入式系统</h2>\n<p>嵌入式计算机系统是与特定功能的设备集成在一起、且隐藏在这个功能系统内部为预定任务而设计的计算机系统。该计算机可对设备的状态进行采集，包括操作者的命令和受控对象的状态，按照设备所要求的、预先设定的特定规律进行计算，计算结果作为命令输出到设备的某些部件，控制某些操作，同时将人所关心的信息显示给操作者。个典型的嵌入式系统如图 4-1 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014072511664.png\" alt=\"image-20241014072511664\"></p>\n<p>上述嵌入式系统的输入、处理、输出的各个部分，一般情况下都是通过软件运行完成的。因此嵌入式软件是嵌入式系统的重要组成部分，而且体现了系统的思想、方法和规律。</p>\n<p>在当今社会中，嵌入式系统已经和我们的生活息息相关，人们每时每刻都离不了嵌入式系统，如图 4-2 所示。</p>\n<p>嵌入式系统一般是实时系统，《牛津计算机字典》对实时系统解释是:“系统的输入对应于一个外部物理世界的运动，而系统输出对应着另外一个物理世界的运动，而这两个运动的时间差必须在可接受的足够小的范围内，实时性就体现在从输入到形成输出所需的时间。” 实时系统又进一步定义为硬实时系统和软实时系统两种，如表 4-1 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014072613264.png\" alt=\"image-20241014072613264\"></p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014072648666.png\" alt=\"image-20241014072648666\"></p>\n<p>般认为，嵌入式计算机相对于个人计算机或超级计算机，在软件或硬件上的资源是有限的，硬件资源体现在处理速度、功耗、存储空间等方面，软件资源指有限的应用、有限的操作系统支持、应用代码量少等方面。</p>\n<p>第一款大批量生产的嵌入式系统是美国 1961 年发布的民兵 I 型导弹内嵌的 D-17 自动制导计算机。</p>\n<p>随着 20 世纪 60 年代早期应用开始，嵌入式系统的价格迅速降低，同时处理功能和能力获得快速提高。以第一款单片机 Intel 4004 为例，在存储器和外围芯片的配套使用下实现了计算器和其他小型系统。1978 年，美国国家工程制造商协会发布了可编程单片机的 “标准”，涵盖了几乎所有以计算机为基础的控制器，如单板计算机、数控设备以及基于事件的控制器，使得微处理器得到了快速发展。</p>\n<p>无一例外，不断发展中的嵌入式计算功能的实现都通过用户需求驱动、顶层定义、硬件定义开始，但核心是软件的算法处理，实际上类似硬件功能通过不同软件的控制就可以实现不同用户所需要的嵌入式功能，如图 4-3 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014072757130.png\" alt=\"image-20241014072757130\"></p>\n<p>当基础硬件接口、计算和存储资源、总线与网络乃至各种传感器、作动器、液压等以模块化、通用化、组合化等变得越来越成熟，他们就可以方便地组合成硬件平台。而软件却恰恰相反，基本是为满足人类某种新的设想或应用要求开始进行新的设计。这些设计从诸如领域、实现功能、性能、可靠性、安全性等方面，可以是全新理念设备、或是适应性修改升级等途径，都会导致软件有不同程度的差异。</p>\n<h2 id=\"嵌入式系统具有以下特征\"><a class=\"anchor\" href=\"#嵌入式系统具有以下特征\">#</a> 嵌入式系统具有以下特征:</h2>\n<h2 id=\"1嵌入式系统的时间敏感性\"><a class=\"anchor\" href=\"#1嵌入式系统的时间敏感性\">#</a> (1)<strong> 嵌入式系统的时间敏感性</strong>。</h2>\n<p>嵌入式实时系统对时间响应都是有要求的。例如对于一个设备的运动控制系统，从操作指令发出，嵌入式计算机根据指令和外部条件计算并输出到动作器的动作，要保证在所有的条件下、在确定的时间内产生所需的输出。这对于设计者来说，一般的实时系统都会围绕这个关键需求进行系统设计。另外为了满足时间敏感性要求，确保在最复杂行为和最大延时情况下，系统操作不发生延迟，要求处理器的利用率要有 40% 左右的余量。有时为满足某些强实时嵌入式系统的应答时间限定在毫秒级或更低，需要在高级语言中嵌入低级语言编程实现。</p>\n<h2 id=\"2嵌入式系统的可靠性和安全性\"><a class=\"anchor\" href=\"#2嵌入式系统的可靠性和安全性\">#</a> (2)<strong> 嵌入式系统的可靠性和安全性</strong>。</h2>\n<p>嵌入式计算机系统的失效带来的可能是个人娱乐系统故障的微小损失，可能是铁路信号失效的巨额经济损失，也可能是战略武器控制等经济损失以及重大的社会政治影响等。所以在某种设计缺陷被诱发后，对于不同的系统需要采取不同的策略，例如对具有重大影响的系统，要求计算机或计算机软件对设计缺陷、制造缺陷等失效采取 “永不放弃” 的安全性设计技术，将损失控制在可接受的范围内。在有人为输入情况下，嵌入式系统还需考虑最大可能地减少人为失误所引起的系统失效。这些算法或机制可以是输入有效性合理性检查、硬件容错、软件容错、错误后的系统缓慢降级、系统进入安全模式等。</p>\n<h2 id=\"3嵌入式软件的复杂性\"><a class=\"anchor\" href=\"#3嵌入式软件的复杂性\">#</a> <strong>(3) 嵌入式软件的复杂性。</strong></h2>\n<p>软件复杂度取决于问题规模和复杂度。简单问题的软件可由个人完成，甚至可以进行软件正确性证明；即使过程中更换人员，花费少许时间就可掌握和维护。但如汽车控制、飞机控制等大型复杂软件，其需要根据复杂的外部输入、按照多变量物理规律和人们的预期，实现预定的功能。软件需要根据系统的外部事件及其组合，考虑各种处理、逻辑、时序、边界、超出边界的鲁棒性等进行详细算法和策略研究。还需要考虑如安全性、可靠性、维护性等质量要求。更困难的是大规模软件需要团队联合定义、并行开发、持续维护，同时考虑处理平台限制条件。</p>\n<h1 id=\"二-嵌入式软件\"><a class=\"anchor\" href=\"#二-嵌入式软件\">#</a> 二、嵌入式软件</h1>\n<p>软件实际上是客观世界问题空间与解空间的具体实现，也是人类知识的提炼、抽象和固化。软件是计算机相关的:</p>\n<p>(1) 完成预定功能和性能的可执行的指令 (计算机程序) 序列。</p>\n<p>(2) 程序操作的信息或数据结构。</p>\n<p>(3) 描述程序操作、数据和使用的文档。</p>\n<p>嵌入式软件是为完成某特定用途而开发的、驻留在预先定义的嵌入式计算机平台上的软件。随着微电子技术飞速发展带来的智能化需求的不断扩展，嵌入式软件无处不在，规模也越来越大。</p>\n<p>近三十年来，随着现代化战争信息化程度的不断提高，随着装备由机械化向信息化的战略转型，军用软件已经渗透到军事应用的各个方面，成为装备及其体系中不可或缺的组成部分，其发展和应用水平代表着一个国家的装备实力。美国国防部在 2002 年的《国防科学技术领域计划》中就把军用软件设计和改进作为重要研究领域，制定了军用软件发展的近、中、远期目标。2011 年，美国政府、国防部、海陆空三军、洛克希德・马丁公司等 26 个组织组成工作组，专题研究军事装备中软件研制和部署存在的问题，形成《美国国防部与国防工业领域软件工程的重大问题报告》，对军用软件的发展提出建议。这些都说明了军用软件在现代化战争中的重要地位和作用。</p>\n<p>随着飞机机载计算机的广泛使用，机载软件从无到有、规模从小到大、复杂度从低到高。软件负责数据的采集、存储和处理。实时进行各种逻辑判断、数学运算、行为推导、状态转换等处理，帮助飞行员优化各种操作，实现飞行航路计算、姿态控制、环境控制、燃油输送、任务计算、状态监控、信息显示报警、人机界面控制等功能，不夸张地说，飞行员每一个操作、飞机的每一个动作的完成都离不开软件运行。</p>\n<h2 id=\"而软件的复杂性-重要性还体现在\"><a class=\"anchor\" href=\"#而软件的复杂性-重要性还体现在\">#</a> 而软件的复杂性、重要性还体现在:</h2>\n<p>(1) 从计算机理论和技术发展趋势来说，硬件和软件没有明确界限，原来使用硬件实现的功能在尽可能地向软件迁移，技术进步越来越显现在软件方面。</p>\n<p>(2) 软件直接和飞机安全功能相关，而且这种相关性越来越高，如电传飞控软件。</p>\n<p>(3) 软件的特殊性导致了需要有特殊的规则保证系统的安全性、可靠性。</p>\n<p>与硬件不同，软件至今尚未摆脱手工方式。更严重的是，软件在开发过程中涉及到了各行各业的工作人员，其中包括业务定义人员、系统分析员、系统设计人员、软件架构师、软件工程师、软件测试工程师以及质量工程师等。实际上这些人员中只有软件工程师是专业软件开发人员，其他人员都需要同时具备软件和其他行业的背景。因此与其</p>\n<h2 id=\"他行业比较软件行业具有以下鲜明的特点\"><a class=\"anchor\" href=\"#他行业比较软件行业具有以下鲜明的特点\">#</a> 他行业比较，软件行业具有以下鲜明的特点:</h2>\n<p>(1) 抽象性：软件直接反映了人的思维逻辑实体，同时几乎没有具体物理实体，且没有明显的制造过程。</p>\n<p>(2) 客观问题越来越复杂，软件也随之越来越复杂，而且软件技术的进步速度落后于需求增长的速度。</p>\n<p>(3) 相对于通用硬件，软件开发成本昂贵，随着问题规模的加大、成本急剧增加。</p>\n<p>(4) 软件运行和使用没有磨损或老化现象。</p>\n<p>(5) 软件对硬件和环境有着不同程度的依赖性。</p>\n<p>(6) 大多数软件是新开发的，通过已有构件组装技术尚不成熟。</p>\n<p>(7) 软件工作结果涉及到许多社会因素。</p>\n<p>以上特点使得软件开发进展情况较难衡量，软件质量不易评价，从而使软件产品的生产管理、过程控制及质量保证都相当困难。</p>\n<h2 id=\"对于嵌入式软件而言它除了具有通用软件的一般特性同时还具有一些与嵌入式系统密切相关的特点-这些特点包括\"><a class=\"anchor\" href=\"#对于嵌入式软件而言它除了具有通用软件的一般特性同时还具有一些与嵌入式系统密切相关的特点-这些特点包括\">#</a> 对于嵌入式软件而言，它除了具有通用软件的一般特性，同时还具有一些与嵌入式系统密切相关的特点。这些特点包括:</h2>\n<p>(1) 软件受资源的限制。由于嵌入式系统的资源一般比较有限，所以嵌入式软件必须尽可能地精简，才能适应这种状况。</p>\n<p>(2) 开发难度大。嵌入式软件的运行环境和开发环境一般比较复杂，从而加大了它的开发难度。首先，由于硬件资源有限，使得嵌入式软件在时间和空间上都受到严格的限制，但要想开发出运行速度快、存储空间少、维护成本低的软件，需要开发人员对编程语言、编译器和操作系统有深刻的了解。其次，嵌入式软件一般都要涉及到底层软件的开发，应用软件的开发也是直接基于操作系统的，这就需要开发人员具有扎实的软、硬件基础，能灵活运用不同的开发手段和工具，具有较丰富的开发经验。最后，对于嵌入式软件来说，它的开发环境与运行环境是不同的。嵌入式软件是在目标系统上运行，但开发工作要在另外的开发系统中进行，当编程人员将应用软件调试无误后，再把它放到目标系统上去。</p>\n<p>(3) 实时性和可靠性要求高。实时性是嵌入式系统的一个重要特征，许多嵌入式系统要求具有实时处理的能力，这种实时性主要是靠软件层来体现的。软件对外部事件做出反应的时间必须要快，在某些情况下还要求是确定的、可重复实现的，不管系统当时的内部状态如何，都是可以预测的。同时，对于事件的处理一定要在限定的时间期限之前完成，否则就有可能引起系统的崩溃。例如，火箭飞行控制系统就是实时的，它对飞行数据采集和燃料喷射时机的把握要求非常的准确，否则就难以达到精确控制的目的，从而导致飞行控制的失败。</p>\n<p>与实时性相对应的是可靠性，因为实时系统往往应用在一些比较重要的领域，如航天控制、核电站、工业机器人等等，如果软件出了问题，那么后果是非常严重的，所以要求这种嵌入式软件的可靠性必须非常高。</p>\n<p>(4) 要求固化存储。为了提高系统的启动速度、执行速度和可靠性，嵌入式系统中的软件一般都固化在存储器芯片或单片机本身中，而不是像通常的计算机系统那样，存储在磁盘等载体中。</p>\n<h1 id=\"三-嵌人式软件分类\"><a class=\"anchor\" href=\"#三-嵌人式软件分类\">#</a> 三、嵌人式软件分类</h1>\n<p>按通常的分类方法，嵌入式软件可以分为三大类:</p>\n<ul>\n<li>系统软件、\n<ul>\n<li>系统软件：控制和管理嵌入式系统资源，为嵌入式应用提供支持的各种软件，如设备驱动程序、嵌入式操作系统、嵌入式中间件等。</li>\n</ul>\n</li>\n<li>应用软件和\n<ul>\n<li>应用软件：嵌入式系统中的上层软件，它定义了嵌入式设备的主要功能和用途，并负责与用户进行交互。应用软件是嵌入式系统功能的体现，一般面向于特定的应用领域，如飞行控制软件、手机软件、MP3 播放软件、电子地图软件等。</li>\n</ul>\n</li>\n<li>支撑软件。\n<ul>\n<li>支撑软件：辅助软件开发的工具软件，如系统分析设计工具、在线仿真工具、交叉编译器、源程序模拟器和配置管理工具等。</li>\n</ul>\n</li>\n</ul>\n<p>在嵌入式系统当中，由于它的硬件配置一般比较低，无法运行太多、太复杂的软件。因此，对于系统软件和应用软件来说，它们是运行在目标平台，即嵌入式设备上。而对于各种软件开发工具来说，它们大部分都运行在开发平台上。本章主要讨论的是运行在嵌入式设备上的软件，即系统软件和应用软件。</p>\n<h1 id=\"四-嵌入式软件体系结构\"><a class=\"anchor\" href=\"#四-嵌入式软件体系结构\">#</a> 四、嵌入式软件体系结构</h1>\n<h2 id=\"1-无操作系统的情形\"><a class=\"anchor\" href=\"#1-无操作系统的情形\">#</a> 1、无操作系统的情形</h2>\n<p>在嵌入式系统的发展初期，由于硬件的配置比较低，而且系统的应用范围也比较有限，主要集中在控制领域，对于是否有系统软件的支持，要求还不是很强烈。所以在那个阶段，嵌入式软件的设计主要是以应用为核心，应用软件直接建立在硬件上，没有专门的操作系统，软件的规模也较小，基本上属于硬件的附属品。在具体实现上，无操作系统的嵌入式软件主要有两种实现方式：循环轮转和前后台系统。</p>\n<h2 id=\"1循环轮转方式\"><a class=\"anchor\" href=\"#1循环轮转方式\">#</a> <strong>1) 循环轮转方式</strong></h2>\n<p>如图 4-4 所示，循环轮转方式的基本思路是：把系统的功能分解为若于个不同的任务，然后把它们包含在一个循环语句当中，按照顺序逐一执行。当执行完一轮循环后，又回到循环体的开头重新执行。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014074043999.png\" alt=\"image-20241014074043999\"></p>\n<p>循环轮转方式的优点是简单、直观、开销小、可预测。软件的开发就是一个典型的基于过程的程序设计问题，可以按照自顶向下、逐步求精的方式，将系统要完成的功能逐级划分成若干个小的功能模块，像搭积木一样搭起来。由于整个系统只有一条执行流程和一个地址空间，不需要任务之间的调度和切换，因此系统的管理开销很少。循环轮转方式的缺点是过于简单，所有的代码都必须按部就班地顺序执行，无法处理异步事件，缺乏并发处理的能力。另外，这种方案没有硬件上的时间控制机制，无法实现定时功能。</p>\n<h2 id=\"2前后台系统\"><a class=\"anchor\" href=\"#2前后台系统\">#</a> 2) 前后台系统</h2>\n<p>前后台系统就是在循环轮转方式的基础上，增加了中断处理功能，如图 4-5 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014074132692.png\" alt=\"image-20241014074132692\"></p>\n<p>图 4-5 中的中断服务程序负责处理异步事件，这部分可以看成是前台程序。而后台程序一般是一个无限的循环，负责掌管整个嵌入式系统软、硬件资源的分配、管理以及任务的调度，是一个系统管理调度程序。在系统运行时，后台程序会检查每个任务是否具备运行条件，通过一定的调度算法来完成相应的操作。而对于实时性要求特别严格的操作通常由中断来完成。为了提高系统性能，大多数的中断服务程序只做一些最基本的操作，例如，把来自于外设的数据拷贝到缓冲区、标记中断事件的发生等，其余的事情会延迟到后台程序去完成。</p>\n<p>实际上，前后台系统的实时性比预计的要差。这是因为前后台系统认为所有的任务具有相同的优先级别，而且任务的执行又是通过先进先出的队列排队，因而对那些实时性要求很高的任务不能立刻得到处理。但由于这类系统的结构比较简单，几乎不需要额外开销，因而在一些简单的嵌入式应用中被广泛地使用，如微波炉、电话机、电子玩具等。</p>\n<h2 id=\"2-有操作系统的情形\"><a class=\"anchor\" href=\"#2-有操作系统的情形\">#</a> 2、有操作系统的情形</h2>\n<p>从 20 世纪 80 年代开始，嵌入式软件进入了操作系统的阶段。这一阶段的标志是操作系统出现在嵌入式系统上，程序员在开发应用程序的时候，不是直接面对嵌入式硬件设备，而是在操作系统的基础上编写，嵌入式软件开发环境也得到了一定的应用。如今，嵌入式操作系统在嵌入式应用中使用得越来越广泛，尤其是在功能复杂、系统庞大的应用中显得愈来愈重要。这种开发方式主要有以下三个优点:</p>\n<p>(1) 提高了系统的可靠性。在控制系统中，出于安全方面的考虑，要求系统起码不能崩溃，而且还要有自愈能力。这就需要在硬件设计和软件设计这两个方面来提高系统的可靠性和抗干扰性，尽可能地减少安全漏洞和不可靠的隐患。</p>\n<p>(2) 提高了系统的开发效率，降低了开发成本，缩短了开发周期。</p>\n<p>在嵌入式操作系统环境下，开发一个复杂的应用程序，通常可以按照软件工程的思想，将整个程序分解为多个任务模块。每个任务块的调试、修改几乎不影响其他模块，而且商业软件一般都提供了良好的多任务调试环境，这样就大大提高了系统的开发效率</p>\n<p>(3) 有利于系统的扩展和移植。</p>\n<p>在嵌入式操作系统环境下开发应用程序具有很大的灵活性，操作系统本身可以剪裁外设、相关应用也可以配置，软件可以在不同的应用环境、不同的处理器芯片之间移植，软件构件可复用。</p>\n<p>嵌入式软件的体系结构如图 4-6 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014074655639.png\" alt=\"image-20241014074655639\"></p>\n<p>在如图 4-6 所示的嵌入式软件体系结构中，</p>\n<ul>\n<li>最底层是嵌入式硬件，包括嵌入式微处理器、存储器和键盘、输入笔、LCD 显示器等输入 / 输出设备。</li>\n<li>硬件层之上是设备驱动层，它负责与硬件直接打交道，并为上层软件提供所需的驱动支持。</li>\n<li>设备驱动层的上面是操作系统层，它可以分为基本部分和扩展部分。前者是操作系统的核心，负责整个系统的任务调度、存储管理、时钟管理和中断管理等功能，这一部分是基础和必备的；后者则是系统为用户提供的一些扩展功能，包括网络、文件系统、图形用户界面 GU、数据库等，这一部分的内容可以根据系统的需要来进行裁剪。</li>\n<li>在操作系统的上面，是中间件软件，</li>\n<li>再上面就是各种应用软件了，如网络浏览器、MP3 播放器、文本编辑器、电子邮件客户端、电子游戏等。对于嵌入式系统的用户来说，就是通过这些应用软件来跟系统交互。</li>\n</ul>\n<h1 id=\"五-设备驱动层\"><a class=\"anchor\" href=\"#五-设备驱动层\">#</a> 五、设备驱动层</h1>\n<p>大多数的嵌入式硬件设备都需要某种类型的软件进行初始化和管理，这部分工作是由设备驱动层来完成的，它负责直接与硬件交互，对硬件进行管理和控制，并为上层软件提供所需的驱动支持。</p>\n<h2 id=\"1-板级支持包\"><a class=\"anchor\" href=\"#1-板级支持包\">#</a> 1、板级支持包</h2>\n<p>设备驱动层也称为板级支持包 (Board Support Package，BSP)，它包含了嵌入式系统中所有与硬件相关的代码。BSP 的基本思想是将嵌入式操作系统与具体的硬件平台隔离开来。也就是说，在 BSP 当中，把所有与硬件相关的代码都封装起来，并向上提供一个虚拟的硬件平台，而操作系统就运行在这个虚拟的硬件平台上，它使用一组定义好的编程接口来与 BSP 进行交互，并通过 BSP 来访问真正的硬件。BSP 在嵌入式系统中的角色，类似于 PC 系统中的 BIOS 和驱动程序。</p>\n<p>对于一个成熟的商用操作系统而言，为了在业界得到广泛应用，就必须要能够支持种类众多的硬件平台，并实现应用程序的硬件无关性。一般来说，这种无关性是由操作系统来实现的。但是对于嵌入式系统来说，它没有像 PC 那样具有广泛使用的各种工业标准和统一的硬件结构。变化众多的硬件环境就决定了无法完全由操作系统来实现上层软件与底层硬件之间的无关性。因此各种商用的嵌入式操作系统都采用了分层设计的思想将系统中与硬件直接相关的一层软件独立出来，称之为板级支持包。</p>\n<p>对于不同的嵌入式操作系统，BSP 的具体结构和组成也各不相同。一般来说，BSP 主要包括两个方面的内容：引导加载程序 BootLoader 和设备驱动程序。</p>\n<h2 id=\"1引导加载程序\"><a class=\"anchor\" href=\"#1引导加载程序\">#</a> 1) 引导加载程序</h2>\n<p>引导加载程序 BootLoader 是嵌入式系统加电后第一时间运行的软件代码。在桌面 PC 中的引导加载程序是由位于只读存储器 ROM 中的 BIOS 和位于硬盘的主引导记录 (Master Boot Record，MBR) 中的 BootLoader 引 | 导程序 (如 LILO 和 GRUB) 两部分代码组成的。BIOS 在完成硬件检测和资源分配后，将硬盘 MBR 中的引导程序读到系统的内存当中，然后由 MBR 负责启动操作系统。但是在嵌入式系统当中，通常没有像 BIOS 那样的固件程序，因此整个系统的加载启动任务就完全由 BootLoader 来完成。例如，在一个基于 ARM7TDM 内核的嵌入式系统中，系统在上电或复位时一般都从地址 0x00000000 处开始执行，而在这个地址处安排的通常就是系统的 BootLoader 程序。</p>\n<p>简单地说，BootLoader 就是在操作系统内核运行之前运行的一小段程序。通过这段程序，可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境配置为定的状态，以便为最终调用操作系统内核做好准备。</p>\n<p>在嵌入式系统中，BootLoader 的实现高度依赖于具体的硬件平台，对于不同的 CPU 体系结构和板级设备配置，需要不同的 BootLoader。因此，要想建立一个通用的 BootLoader 几乎是不可能的。但是，一般来说，它主要包含以下基本功能:</p>\n<p>(1) 片级初始化。片级初始化主要完成微处理器的初始化，包括设置微处理器的核心寄存器和控制寄存器，微处理器的核心工作模式及其局部总线模式等。片级初始化把微处理器从上电时的缺省状态逐步设置成系统所要求的工作状态。</p>\n<p>(2) 板级初始化。通过正确地设置各种寄存器的内容来完成微处理器以外的其他硬件设备的初始化。例如，初始化 LCD 显示设备，初始化定时器，设置中断控制寄存器等。</p>\n<p>(3) 加载内核。将操作系统和应用程序的映像从 Flash 硬盘拷贝到系统的内存当中，然后跳转到系统内核的第一条指令处继续执行。</p>\n<h2 id=\"2设备驱动程序\"><a class=\"anchor\" href=\"#2设备驱动程序\">#</a> 2) 设备驱动程序</h2>\n<p>在一个嵌入式系统当中，设备驱动程序是必不可少的。所谓的设备驱动程序，就是 - 组库函数，用来对硬件进行初始化和管理，并向上层软件提供良好的访问接口。对于不同的硬件设备来说，设备驱动程序也是不一样的。但是一般来说，设备驱动程序都会具备以下的基本功能。</p>\n<p>(1) 硬件启动：在开机上电或系统重启的时候，对硬件进行初始化。</p>\n<p>(2) 硬件关闭：将硬件设置为关机状态。</p>\n<p>(3) 硬件停用：暂停使用这个硬件。</p>\n<p>(4) 硬件启用：重新启用这个硬件。</p>\n<p>(5) 读操作：从硬件中读取数据。</p>\n<p>(6) 写操作：往硬件中写入数据。</p>\n<p>除了以上这些普遍适用的功能之外，设备驱动程序还可能有很多额外的、特定的功能。在具体实现的时候，这些功能一般是用函数的形式来实现的。这些函数主要有两种组织结构，即分层结构和混合结构，如图 4-7 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-19%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E5%9B%9B%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/image-20241014075238182.png\" alt=\"image-20241014075238182\"></p>\n<p>所谓分层结构，就是把设备驱动程序当中的所有函数分为两种类型，一种是直接跟硬件交互，直接去操纵和控制硬件设备的，这些函数称为硬件接口；另一种是跟上层软件交互，作为上层软件的调用接口。分层结构的优点是：把所有与硬件有关的细节都封装在硬件接口当中，硬件升级时，只需要改动硬件接口当中的函数，而上层接口当中的函数不用做任何的修改。</p>\n<p>所谓混合结构，就是在设备驱动程序当中，上层接口和硬件接口的函数是混在一起、相互调用的，它们之间没有明确的层次关系。无论是分层结构还是混合结构，它们给上层软件提供的调用接口都应该是明确而稳定的，即便设备驱动程序的内部有任何的变化，也不会影响到上层软件，这样，在移植操作系统和应用程序的时候，就非常方便。</p>\n<h1 id=\"六-嵌入式中间件\"><a class=\"anchor\" href=\"#六-嵌入式中间件\">#</a> 六、嵌入式中间件</h1>\n<p>近年来，在嵌入式系统中，处理器的性能不断提高，系统的功能更为复杂，嵌入式软件对可靠性、实时性的要求越来越高，因此，中间件技术也被引入到嵌入式系统的设计当中，并与实时多任务操作系统紧密结合。这种全新的软件设计方法，可以使用户把精力集中到系统功能的实现上，从而真正实现嵌入式系统的软硬件协同设计。当然，在一个实际的嵌入式系统当中，对于是否要采用嵌入式中间件，这完全取决于具体的应用需求。</p>\n<p>所谓嵌入式中间件，简单地说，就是在操作系统内核、设备驱动程序和应用软件之外的所有系统软件。嵌入式中间件的基本思路是：把原本属于应用软件层的一些通用的功能模块抽取出来，形成独立的一层软件，从而为运行在它上面的那些应用软件提供一个灵活、安全、移植性好、相互通信、协同工作的平台。这样，就可以有效地实现软件的可重用，降低应用软件的复杂性，提高系统的开发效率，缩短系统的开发周期，节约开发成本和维护费用，同时还保证了系统的高伸缩性、易升级性和稳定性。当然如果在嵌入式系统中引入中间件，将会带来额外的开销，可能会对系统的性能造成定的影响。</p>\n<p>嵌入式中间件可以分为不同的类型，如</p>\n<ul>\n<li>消息中间件、</li>\n<li>对象中间件、</li>\n<li>远程过程调用、数据库访问中间件、</li>\n<li>安全中间件等。</li>\n</ul>\n<p>有些嵌入式系统较为复杂，单个的中间件可能无法满足应用的需求，这时就需要将多种中间件集成在一起。这样的集成解决方案如 Sun 公同的嵌入式 Java、<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1nNXQ1MTJjMHRyLk5FVA==\">微软的.NET</span> Compact Framework、OMG (Object Management Group) 的嵌入式 CORBA 等。</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/6bbd33c4.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/6bbd33c4.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（3）CadencePCB系统设计",
            "date_published": "2024-10-16T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计3cadencepcb系统设计\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计3cadencepcb系统设计\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（3）CadencePCB 系统设计</h1>\n<p>Cadence 公司的 PCB 系统设计提供了从原理图设计输入、分析、PCB 设计、PCB 制造文件输出等一整套工具，为嵌入式系统硬件设计的准确性和高效提供了基础，其设计流程如图 3-16 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-17%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%883%EF%BC%89CadencePCB%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-20241014071449115.png\" alt=\"image-20241014071449115\"></p>\n<h1 id=\"一-原理图设计输入工具\"><a class=\"anchor\" href=\"#一-原理图设计输入工具\">#</a> 一、原理图设计输入工具</h1>\n<p>Cadence 公司的 PCB 系统设计提供了两种原理图输入工具，Concept HDL 和 CaptureCIS，Concept HDL, 提供了一个高度集成的规则驱动的设计流程，与约束管理器整合提供了整个设计流程中管理电器约束的统一环境，支持团队设计、并发设计、设计重用等。Concept HDL 提供了传统的平面设计方法和先进的分层次的设计方法，设计者可以根据自己的需要选择合适的设计流程和方法。</p>\n<h2 id=\"1分层次的设计\"><a class=\"anchor\" href=\"#1分层次的设计\">#</a> 1) 分层次的设计</h2>\n<p>Concept HDL 支持自顶向下和自底向上两种设计方法。自顶向下的设计方法就是先创建系统的方框图，分成若干子模块，然后再设计子模块，子块又可以再往下细分成子模块或者绘制平面原理图。反过来就是自底向上的方法，先创建最底层的原理图，然后将原理图生成各个模块，各个模块又可以组合形成更高层的模块，最后形成一个系统设计。模块和原理图是可以混用的，并且可以分很多层。每个模块可以单独打包 (Package, 这里所说的打包，即将逻辑从原理图传递到 Allegro) 到 Alegro 中，这样多个 PC 设计工程师就可以同时进行布局布线。图形化的分层和配置管理工具加上功能块编辑功能使得分层次设计的实现很容易。同时这些模块又是可以复制的，并且可以标注不同的属性，这样就保证了原理图之下只有一份拷贝，并且当变更模块的原理图时，会将所有的调用全部更新。</p>\n<h2 id=\"2模块化设计-设计重用\"><a class=\"anchor\" href=\"#2模块化设计-设计重用\">#</a> 2) 模块化设计 -- 设计重用</h2>\n<p>市场压力和设计趋势推进电子产品向着模块化、多功能等级和核心功能派生的方向发展。但是同时维护同一基础设计的多个版本既耗时又费力，也容易出错。Concept HDI 可以让设计者将与 Allegro 版图有关的原理图完整地作为一个元件 (cell) 保存到库中，可以像调用一个元件那样使用，省去了重新创建和重复拷贝的麻烦。例如电源电路和时钟电路在一个系统或者多个系统中通常会采用相同的解决方案，就可以采用这些方法来实现，这样就可以提高整体的设计效率。</p>\n<h2 id=\"3并行设计方法\"><a class=\"anchor\" href=\"#3并行设计方法\">#</a> 3) 并行设计方法</h2>\n<p>PCB 设计专家提供了真正的并行设计过程。例如在布局时，设计者需要改变连线或者添加元件，在 Alegro 或者 Concept HDL 中都可以实现设计同步，可以帮助用户分析原理图和 PCB 的不同，并且产生一个分层的 ECO 报告自动更新选择的文档。</p>\n<h2 id=\"4导入物理布局和原理图\"><a class=\"anchor\" href=\"#4导入物理布局和原理图\">#</a> 4) 导入物理布局和原理图</h2>\n<p>Allegro Expert 和 Concept HDL 可以通过 IFF 接口自动导入安捷伦 ADS 物理布局和原理图。导入后，安捷伦 ADS 的设计就如同一个模块，其组件映射到 Allegro 库中。可以选择锁定避免编辑，也可以解锁进行编辑，即使处于锁定状态，模块仍然允许将其连接到设计的其他部分。</p>\n<h2 id=\"5功能强大的原理图输入方法\"><a class=\"anchor\" href=\"#5功能强大的原理图输入方法\">#</a> 5) 功能强大的原理图输入方法</h2>\n<ul>\n<li><strong>参数化</strong>。如果原理图中需要放置 20 个旁路电容，可以只放置一个电容，然后给这个电容设置参数 size-20，这样就可以减少原理图的篇幅，提高设计的效率，并且原理图看起来更加清晰、整洁。</li>\n<li><strong>对上下文敏感的菜单</strong>。这个功能与 Windows 的功能差不多，当选中一个对象时，右击，就会弹出一个菜单，菜单包含了与当前和上下文有关的命令。</li>\n<li><strong>群组操作</strong>。如果需要对某类元件进行替换或者某些元件需要修改某个属性，可以将这些对象生成一个群组，然后一次替换或者修改这个属性时，节省很多时间。</li>\n<li><strong>分割元件图形</strong>。某些元件管脚非常多，有几百个管脚的元件是非常普遍的，有些都有 1000 多个管脚了，在一页原理图中显示这么多管脚是不切实际的。ConcepHDL, 的建库工具 (Part Developer) 可以将这样的元件分为几个图形符号来制作，并且这些符号可以放在不同的原理图页面上。在打包到 Alegro 中时，仍然可以将这些符号打包成一个元件。</li>\n<li><strong>SKILL 和 CAE Views</strong>。设计者根据需要写 SKIL 程序来定制 Concept HDL，并且可以共享，全局导航、查找和替换。无论是平面设计还是层次设计，都可以轻松地按几下鼠标键即可找到任何元件或网络。</li>\n<li><strong>元件列表文件 (PPT)</strong>。元件列表文件可以让设计者将不同的物理元件映射到同样的原理图符号上。例如常用的电阻和电容等元件，元件原理图的图形是完全一样的，只是封装、标称值等不一样。在建库时，可将一类元件全部输入列表文件中在原理图中通过选择不同的元件属性来调用它们。</li>\n<li><strong>脚本 (script) 和非图形化的 Concept HDL</strong>。设计者可以为经常执行的命令设置批处理，在设计过程中调用。Concept HDL, 也可以运行在非图形化的样式，这种模式一般用于自动运行模式。</li>\n</ul>\n<h2 id=\"6其他功能和特点\"><a class=\"anchor\" href=\"#6其他功能和特点\">#</a> 6) 其他功能和特点</h2>\n<ul>\n<li>高性能的图形界面，可以动态移动定制的用户界面，可以命令行输入，热键输入和执行 STROKE (手绘) 命令。</li>\n<li>自动生成 BOM (料单)。Concept HDL 的这个功能方便设计者自动生成料单。料单的格式按照需要也可以定制，并且可以将非电气元件另外生成一个料单与电气元件的料单连接起来。</li>\n<li>可以进行电气规则检查和生成网表报告。</li>\n<li>归档。一般原理图中并没有将原理图库信息全部调入，如果将原理图转移到其他计算机上进行编辑，就会出现找不到库的麻烦，归档功能提供可以将原理图所用的组件归档到本地的功能，不用的库就不会拷贝过来。</li>\n<li>与 Allegro 整合。Concept HDL 不仅仅是一个原理图编辑器，它的作用类似于完整设计环境中的 HUB，无缝地与 Allegro PCB 设计系统和其他仿真工具整合。例如在布局时，设计者可以通过在 Concept HDL, 中选中组件而在 Allegro 中放置，也可以一次就放置所有的组件。</li>\n<li>项目管理器。在项目管理器中，设计者可以启动所有的工具、改变启动工具的设置。</li>\n<li>与约束管理器整合。Concept HDL 也是设计流程中管理电气约束的统一环境的 - 部分，所以在 Concept HDL, 中也可以利用约束驱动过程传递正确的设计给 Allegro, 或者反过来传递给 Concept HDL。</li>\n</ul>\n<h1 id=\"二-pcb-设计系统\"><a class=\"anchor\" href=\"#二-pcb-设计系统\">#</a> 二、PCB 设计系统</h1>\n<p>PCB 设计系统可以实现复杂、多层电路板图的创建和编辑，可以方便地输出生产数据，其特点包括:</p>\n<p>(1) 灵活的驱动布局功能。Allegro Expert 提供约束驱动自动和交互结合的布局模式，可以让工具自动布局，也可以手工调整，在放置元件时高速约束和物理设计规则可以动态地检查元件的放置有没有违反规则，并报告出来。QuickPlace 可以让设计者对组件进行过滤和预分纽，在 PCB 外形图框周围放置他们。Ailegro Expert 使用统一的约束管理器在布局阶段提供互连线延时的实时图形反馈，使工程师最优化地仿真元件，保证了设计的正确性。</p>\n<p>(2) 交互式布线编辑器。Alegro 提供基于形状、任意角度和推挤 (push/shove) 的布线方式，对于有高速规则约束的网络在走线时还可以实时显示还有多少时序裕量。</p>\n<p>(3) 多种生产加工数据的输出。可以输出多种生产加工数据，包括标准的 Gerber 文件、多种光绘机文件、D 码表、装配图、裸板测试数据等，还能输出 ODB++ 数据格式。</p>\n<p>(4) 丰富的平面操作功能。Allegro Expert 提供了功能最强的电源平面创建和编辑功能，包括用户定义分割面、中间层面正片显示以及用户定义部分覆铜区域的功能选项。该电源平面设计工具可以使设计者像观察正片一样显示所见即所得的电源层负片。</p>\n<p>(5) 高级 SKILL 语言。使用高级 SKILL 语言，设计者可以正确地集成和定义自己需要或喜爱的工具箱。</p>\n<h1 id=\"三-自动和交互布线工具\"><a class=\"anchor\" href=\"#三-自动和交互布线工具\">#</a> 三、自动和交互布线工具</h1>\n<p>Cadence 公司的 PCB 系统设计中的自动布线工具是一流的，针对高密度 PCB 和复杂 I℃ 封装的自动和交互式互连线布线工具，具体包含 SPECCTRA 布局编辑器、SPECCTRA 交互布线编辑器、SPECCTRA 自动布线器 3 个工具。</p>\n<h2 id=\"1specctra-布局编辑器\"><a class=\"anchor\" href=\"#1specctra-布局编辑器\">#</a> 1) SPECCTRA 布局编辑器</h2>\n<p>SPECCTRA 布局编辑器可以方便快捷地帮助设计者完成布局，可以对单个和一组元件进行诸如翻转、旋转、推挤、对齐和移动等操作。SPECCTRA 布局编辑器提供指导布局模式，帮助设计者自动计算出最佳布局位置，设计者也可以调整。SPECCTRA 布局编辑器还提供密度分析功能，以图形方式显示布线阻塞情况，帮助设计者调整布局，提高布通率。</p>\n<h2 id=\"2specctra-交互布线编辑器\"><a class=\"anchor\" href=\"#2specctra-交互布线编辑器\">#</a> 2) SPECCTRA 交互布线编辑器</h2>\n<p>SPECCTRA 交互布线编辑器提供的推挤功能可以自动按照间距要求移动附近的连线和过孔。当移动连线或过孔时，编辑器会自动推挤它周围的连线并动态地显示出来。设计者也可以通过多级操作放弃所做的动作。</p>\n<p>SPECCTRA 交互布线编辑器还提供自动帮助放置过孔、拷贝连线等功能。</p>\n<h2 id=\"3specctra-自动布线器\"><a class=\"anchor\" href=\"#3specctra-自动布线器\">#</a> 3) SPECCTRA 自动布线器</h2>\n<p>SPECCTRA 自动布线器使用高效的基于形状的布线算法，可以充分利用布线空间。SPECCTRA 自动布线器还提供了电气参数规则控制和电流承载能力的要求。</p>\n<p>SPECCTRA 自动布线器还可以提供盲埋孔、焊盘下过孔等的处理，是当今高密度 PCB 设计必需的功能。</p>\n<h1 id=\"四-库管理\"><a class=\"anchor\" href=\"#四-库管理\">#</a> 四、库管理</h1>\n<p>Cadence 公司的 PCB 系统设计的库管理提供 3 个工具，分别是 PCB 库专家、PCB 库、库浏览。</p>\n<h2 id=\"1pcb-librarian-expertpcb-库专家\"><a class=\"anchor\" href=\"#1pcb-librarian-expertpcb-库专家\">#</a> 1) PCB Librarian ExpertPCB 库专家</h2>\n<p>PCB 库专家提供了原理图和 PCB 库的创建、封装和验证功能。它包含了几个工具，原理图库的创建是由 Librarian Expert 和 Part Developer 这两个工具来实现的。PartDeveloper 用来创建原理图符号、物理引脚与封装的对应和其他关键属性。Padstack Editor 是图形编辑器，用来创建、修改焊盘。Alegro Librarian 用来创建 PCB 封装符号，可以用手工和向导两种方法来实现。</p>\n<h2 id=\"2pcb-librarianpcb库\"><a class=\"anchor\" href=\"#2pcb-librarianpcb库\">#</a> 2) PCB LibrarianPCB 库</h2>\n<p>PCB Librarian 包含手工创建库的工具，包括 Library Export 和 Part Developer 原理图创建工具，还有创建 PCB 库的 Allegro Librarian 工具，可以完成库的创建和校验。虽然 PCB Librarian 和 PCB Librarian Expert 包含的工具是一样的，但是在 PCB Librarian 中只能使用工具的部分功能，一些高级功能不能实现。</p>\n<h2 id=\"3part-browser-库浏览\"><a class=\"anchor\" href=\"#3part-browser-库浏览\">#</a> 3) Part Browser-- 库浏览</h2>\n<p>Part Browser 是基于 Web 的检索和放置元件的工具。库的验证通过 Part Browser 来实现。这个工具可以提供多个方法来检索元件列表 (PTF) 的内容，并且可以被集成到 MRP/ERP 系统中提供其他商业信息。</p>\n<h1 id=\"五-约束管理器\"><a class=\"anchor\" href=\"#五-约束管理器\">#</a> 五、约束管理器</h1>\n<p>约束管理是 PCB 系统设计的核心，提供基于电子数据表格式的约束信息，具有实时显示高速规则和状态的功能，并且可以在设计流程的任意阶段调用。仿真设计人员在做仿真之后，形成了高速约束规则，这些规则一旦加入约束管理器，就可以用来驱动布局布线了。约束管理器包括两个视图，一个视图让设计者观察数据库中不同的电子约束集合相关的约束值；另一个视图提供系统中不同网络以及它们要遵守的约束集名称，并且实时显示约束值的分析结果，通过改变分析结果的颜色来标明成功和失败，一目了然。</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/3b468ee7.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/3b468ee7.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（2）电子电路设计",
            "date_published": "2024-10-14T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计2电子电路设计\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计2电子电路设计\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（2）电子电路设计</h1>\n<h1 id=\"一-电子电路设计基础知识\"><a class=\"anchor\" href=\"#一-电子电路设计基础知识\">#</a> 一、电子电路设计基础知识</h1>\n<h2 id=\"1-电子电路设计原理\"><a class=\"anchor\" href=\"#1-电子电路设计原理\">#</a> 1、电子电路设计原理</h2>\n<p>电路设计主要分三个步骤：设计电路原理图、生成网络表、设计印制电路板。在典型的电子电路设计中，其某本步骤如下。</p>\n<p>(1) 充分了解设计任务的具体要求，如性能指标、内容及要求，明确设计任务</p>\n<p>(2) 方案选择：根据掌握的知识和资料，针对设计提出的任务、要求和条件，设计合理、可靠、经济、可行的设计框架，对其优缺点进行分析。</p>\n<p>(3) 根据设计框架进行电路单元设计，具体设计时可以模仿成熟的电路进行改进和<br>\n创新，需要特别注意信号之间的关系和限制。</p>\n<p>(4) 根据电路工作原理和分析方法，进行参数的估计与计算。</p>\n<p>(5) 元器件选择时，元器件的工作、电压、频率和功耗等参数应满足电路指标要求，元器件的极限参数必须留有足够的裕量，一般应大于额定值的 1.5 倍，电阻和电容的参数应选择计算值附近的标称值。</p>\n<p>(6) 电路原理图的绘制，电路原理图是组装、焊接、调试和检修的依据，绘制电路图时布局必须合理、排列均匀、清晰、便于看图、有利于读图：信号的流向一般从输入端或信号源画起，由左至右或由上至下按信号的流向依次画出单元电路，反馈通路的信号流向则与此相反；图形符号和标准，并加适当的标注；连线应为直线，并且交叉和折弯应最少，互相连通的交叉处用圆点表示，地线用接地符号表示。</p>\n<h2 id=\"2-电子电路设计方法及步骤\"><a class=\"anchor\" href=\"#2-电子电路设计方法及步骤\">#</a> 2、电子电路设计方法及步骤</h2>\n<p>电子电路设计的第一步是电路原理图设计，设计电子电路是后续步骤的基石。电子电路设计的过程如图 3-7 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013212203398.png\" alt=\"image-20241013212203398\"></p>\n<p>在原理图设计过程中，首先是建立元器件库，其次是元器件布局和布线连接，然后需要进行电路分析与仿真，进而生成网表，最终得到设计完整的原理图。在整个设计过程中，需要不断的检查与校对，以保证各个环节的正确性。</p>\n<p><strong>1) 建立元器件库中没有的元器件</strong></p>\n<p>一般使用的 CAD 软件都会预置一些常用的电路元器件。但是这些元器件并不一定会满足电路原理图的设计需求，而元器件厂家也不会提供元器件库。因此要想设计原理图，第一步是使用 CAD 软件，对有关元器件建立元器件库，同时对元器件库中已有但是不满足要求的元器件进行修改。</p>\n<p>一般来说，采用片上系统的设计与传统方式下采用逻辑关系的设计方法并不相同。建立元器件的原理图时需要基于实际的元器件，参考元器件的数据手册建立。原理图中的标识要简明清晰，同时保证逻辑上的电气特性与实际数据手册所描述的元器件相符，在进行元器件建库时需要注意以下标准:</p>\n<ul>\n<li>元器件引脚序号与封装库相应元器件应交序号应当保持一一对应；</li>\n<li>分立元器件要注意元器件的标号与引脚的对应关系，例如多组绕组电感要注意主次绕阻和同名端的标示及引脚序号对应关系；</li>\n<li>二脚有极性，如二极管，默认以 1 表示正极，2 表示负极；</li>\n<li>多脚元器件如晶体管、芯片等，引脚序号应该与封装的引脚序号保持对应关系，且芯片引脚的序号为逆时针逻辑；</li>\n<li>通常元器件的引线引脚长度为 5 个单位。</li>\n</ul>\n<p><strong>2) CAD 设置</strong></p>\n<p>根据实际的电路及其复杂程度选择对应的元器件库，设置 CAD 图示相关属性，配置 CAD 中设计规则，并建立有关工程。</p>\n<p><strong>3) 放置元器件</strong></p>\n<ul>\n<li>根据设计电路图的需求，将所使用的元器件有选择地放置在合适的位置，并进行修改。同时利用 CAD 自动编号功能为元器件编号，并选择实际印刷电路所使用的封装。</li>\n<li>原理图的视图要整体清晰，元器件的放置会影响到原理图整体的美观性和可读性。设计合理的原理图会使后续工作的难度与复杂度降低，同时可维护性与可读性增强。</li>\n<li>元器件的放置需要依照主信号流向的方向和规律安排，功能类似或者接近的电路元器件应当摆放在一起，并且符合原理图设计规范。原理图中使用的元器件、表示等要采用国际标准的符号。对于一些特殊情况可以使用非国际标准的符号、标示，但是需要在恰当的位置标注其中含义。</li>\n<li>摆放元器件的时候，如果元器件无法在一张原理图中放置，则需要酌情将原理图分割成多张原理图或者采用 “子 - 母” 原理图的方式将原理图进行分割。在这个过程中，所有操作都需要确保原理图的逻辑正确性。</li>\n<li>如果将完成功能相近的元器件摆放在一起时，元器件的方向要一致，字符位号要保持与对应元器件最近距离，整齐划一，方向一致，以达到读图时美观、拓扑结构清晰、电气逻辑规范的效果。</li>\n<li>此外，摆放的元器件要放置在原理图的标准模板框中。统一元器件不能使用不同的符号表示出现在原理图上。有极性的元器件应标识正确、清楚、易识别电感的同名端要标识正确、清楚，同一原理图上的电感的同名端标识要统一。</li>\n</ul>\n<p><strong>4) 原理图连接</strong></p>\n<p>根据原理图需要，将原理图上的各个元器件按照需求设计将对应引脚通过合适的方式进行连接，即可形成完整的原理图。</p>\n<ul>\n<li>通常主功率路线及大电流连线需要加粗表示，</li>\n<li>其他的信号线则使用细线表示。</li>\n<li>对于原理图中有电气连接的导线是不可以弯曲的，</li>\n<li>应当以垂直或者平行的线进行表示，尽量减小大幅度的跨接。</li>\n<li>没有逻辑连接的不可以有电气结点。</li>\n</ul>\n<p><strong>5) 检查校对</strong></p>\n<p>根据系统需求与电路功能对所设计的电路图进行校验，保证原理图符合电器规则，同时布局较为清晰、简明、美观。对元器件、导线位置、连接等进行检查修改。</p>\n<p><strong>6) 电路分析与仿真</strong></p>\n<p>利用 CAD 软件提供的分析仿真功能或者使用专用行业软件对检录进行分析，分析之后对电路进行仿真，检查电路是否符合需求设计与相关设计指标。</p>\n<p><strong>7) 生成网络表</strong></p>\n<p>使用 CAD 软件生成原理图的网络表。电路会以结点、元器件和连线组成的网络表示。PCB 设计中，布线或者自动布线会依赖这些数据。对于 CAD 软件，网络表是原理图与印刷电路中间的接口。</p>\n<p>当人工创建网络表时，应根据原理图设计工具的特性，结合原理图设计一同排除错误，保证网络表的正确性和完整性。</p>\n<p><strong>8) 保存与输出</strong></p>\n<p>将设计的电路所在工程存储并提交至版本控制系统中，等待下一步操作或者审阅人员审阅，审阅完成后才可进行输出。</p>\n<p>此外对于电路的原理图来说，还需要及时填写标准模板框中的相关信息，包括：所适用的产品型号、版本号、修改记录、绘制者、修改者、审核者批准者、日期等关键信息。</p>\n<h2 id=\"3-电子电路可靠性设计\"><a class=\"anchor\" href=\"#3-电子电路可靠性设计\">#</a> 3、电子电路可靠性设计</h2>\n<p>电子设备的可靠性设计可以保证在绝大部分情况下电子设备能够稳定可靠地工作，同时在发生故障时可以将损失降到最低。在电子电路可靠性设计中，涉及可靠性定义故障衡量、可靠性成本、可靠性设计和设计故障等概念。</p>\n<p><strong>1) 可靠性定义</strong></p>\n<p>可靠性的严格定义如下:“在规定的时间和环境条件下系统无故障运行的概率”。这个概率受到三个控制量的影响:</p>\n<ul>\n<li><strong>故障的规定</strong>：许多系统在运行中可能出现不同级别的故障，有些故障可能导致整个嵌入式系统物理上的损毁，有些则可能对系统根本没有影响。</li>\n<li><strong>工作寿命</strong>：嵌入式系统不可能永远运行，不同使用年限的电子器件、设备发生故障的概率也不同。</li>\n<li><strong>实际环境</strong>：温度、适度、腐蚀性气液体、灰尘、震动、冲击、电源、磁场、名类辐射射线等对于设备的正常工作都会有一定的影响。实际环境的限制最终对于可靠性的评价有着实际意义的限制。</li>\n</ul>\n<p><strong>2) 故障衡量</strong></p>\n<p>对于大多数电子设备来说，故障率是一个常数。一般来说，嵌入式设备的故障率会在设备运行初期较高，然后随着易损元器件被非易损替换，故障率会逐步下降。随着设备运行，并逐渐接近使用寿命，元器件会开始损耗，同时腐蚀率会升高，从而导致故障率会再次升高。所以通常会用某一方式衡量可靠性。</p>\n<p>在确定时间内的故障率的倒数就是通常所指的<strong>平均故障间隔时间 (Mean Time Betveen Failures，MTBF)</strong>。一般用小时表示，而故障率使用每个小时故障的次数进行表示。MTBF 通常与运行周期无关，可以方便地表示可靠性。</p>\n<p>MTBF 通常描述可以修复的设备的可靠性，而对不可以修复的设备，则无法使用该指标衡量。因此对于不可修复设备，一般使用平均失效时间 (Mean Time To Failure,MTTF) 来表示可靠性。一般的工厂生产该类设备时，会使用抽样调查的方式进行寿命测试，以此来估算 MTTF。</p>\n<p>对于可靠性，还有一个评价指标是可用性，表示系统工作的总时长中，正常可用的时间所占的比例，即一个设备正常服务的时间与正常和故障总时间的比值。通常可表示为 U/(U+D)，其中 U 表示正常运行的时间，D 表示故障的时间。</p>\n<p><strong>3) 可靠性成本</strong></p>\n<p>嵌入式系统可靠性的提高需要一个团队人力、物力的大量投入。总的来说，投入的金钱与人月会随着可靠性的提升而先降低再提高，而维护成本则是先提升再降低。通过建立数学模型可以确定的是，将大量的资源投入提高很少的可靠性是不值当的。</p>\n<p><strong>4) 可靠性设计</strong></p>\n<p>嵌入式系统硬件相关的可靠性设计往往是为 “在有限的资源下尽可能提高可靠性”。因此可靠性设计通常需要考虑如下因素，以平衡不同因素对可靠性的影响:</p>\n<ul>\n<li>有效的散热，降低高温对系统的危害:</li>\n<li>尽量减少高敏感元器件的使用:</li>\n<li>更多的使用可靠度高、质量好的元器件</li>\n<li>指定采用屏蔽性好或者内嵌的测试方法:</li>\n<li>使用最少的元器件设计出来简单的电路:</li>\n<li>在电子元器件级别进行几余。</li>\n</ul>\n<p>温度是影响所有电子元器件的重要因素之一，而所有元器件都会产生热量。过高的温度会对元器件造成不可逆转的损伤，并阻碍电流流动。而且高温也是元器件损害的最主要的原因。同时过低温也会损坏电子设备。一般来说设备需要工作在所设计的环境中，不同级别的设备会对不同环境的耐受级别不同，因此根据不同用途要选择合适的设备，同时使用适当的散热或者保温措施。</p>\n<p>重要的是，元器件工作在标称额定值 (环境) 以内对电子设备的可靠性会有较大的提升。对于电容、电阻等元器件和各类芯片，都会对电压、电阻、功率、频率等有着严格的规定。保证电子元器件、电路工作在合理的环境中可以有效的保护元器件、降低故障发生的可能，提高可用性。此外选用高可靠的元器件也可以有效地提高可靠性。在选用可靠的元器件并对环境做出保证后，还应当进行选和老化实验保证元器件的一部分不合格元器件筛除。</p>\n<p>根据概率论的相关知识，若假设所有元器件出错的概率为 p, 而 n 个元器件中任意元器件出错都会导致系统崩溃，则整个系统出错的概率为 1-(1-p)\"。当 n 增加时，出错的概率会以指数形式增长。因此，降低元器件个数、简化设计可以有效地降低故障发生的概率从而提高可靠性。当一个部件的故障率为 p 而同时有 n 个冗余部件时，其整体故障的概率为 p\"。可以看出，当冗余元器件增多的时候，整体的故障概率会成指数形式降低。因此，有效的几余设计可以保证系统的可靠性提高。</p>\n<p><strong>5) 设计故障</strong></p>\n<p>正如 “设计故障” 字面意思所揭示的，许多故障是由设计者人为设计的，一个最极端的例子将电源两端使用电阻连接，但是使用的是 0 欧姆电阻。所以可靠性设计中对于经验的依赖十分重要，由于设计者本身的经验缺乏或者其他问题造成的系统可靠性降低是不容易解决的，但是又不容易避免。因此，设计审查是必不可少的环节，“设计故障” 在实际的生产过程中应该极力避免。</p>\n<h1 id=\"二-pcb设计基础知识\"><a class=\"anchor\" href=\"#二-pcb设计基础知识\">#</a> 二、PCB 设计基础知识</h1>\n<h2 id=\"1-pcb设计原理\"><a class=\"anchor\" href=\"#1-pcb设计原理\">#</a> 1、PCB 设计原理</h2>\n<p>在原理图设计完成并生成网络之后，就可以着手设计印刷电路板了，也就是常说的 PCB (Printed Circuit Board)。现在所有电子设备都离不开 PCB，PCB 承载着形形色色的电子元器件，作为电子系统的基石。PCB 的出现与发展使得电子产品生产可以更加工业化，同时伴随着工业化使得 PCB 的生产更加标准化、规模化、自动化。此外 PCB 技术的发展还使得电子电路与电子产品的体积不断缩小，从而降低成本，同时可靠性与稳定性还能够得以提高，并且使得装配与维修变得十分简单。</p>\n<p>PCB 是由印刷电路、基板、元器件组合而成的。下面简要介绍一些 PCB 相关的基础知识。</p>\n<ul>\n<li><strong>PCB 印刷</strong>：PCB 印刷是按照设计将电路印刷到基板上，然后重复多次得到多层 PCB，最后添加过孔、阻焊层等；</li>\n<li><strong>PCB</strong> 由基板、铜层、阻焊层、字符层等组成；</li>\n<li><strong>印制线路</strong>是指采用诸如刻蚀之类的方法的印制电路，包括导线和焊盘；</li>\n<li><strong>印制元器件</strong>是指通过丝印等手段将元器件符号等文字印刷至电路上的描述；</li>\n<li><strong>PCB 贴片</strong>是指使用专用贴片机自动贴片或者使用钢网手工贴片，然后通过各类加热方式或者回流焊接方式将元器件焊接的过程；</li>\n<li><strong>电镀</strong>：通常会使用锡或者金对暴露的焊盘等进行电镀处理，</li>\n</ul>\n<p>对于 PCB，有许多分类方式。</p>\n<ul>\n<li>按照 PCB 的层数，一般可分为\n<ul>\n<li>单面板、</li>\n<li>双面板和</li>\n<li>多层板。</li>\n</ul>\n</li>\n<li>按照机械性能来区分，可以分为\n<ul>\n<li>刚性板和</li>\n<li>柔性版。</li>\n</ul>\n</li>\n<li>按照基板材质可以分为\n<ul>\n<li>纸基板、</li>\n<li>玻璃基板、</li>\n<li>复合材料基板和</li>\n<li>特征材料基板。</li>\n</ul>\n</li>\n</ul>\n<p>目前主流的 PCB 多为树脂刚性基板。</p>\n<h2 id=\"2-pcb-设计方法及步骤\"><a class=\"anchor\" href=\"#2-pcb-设计方法及步骤\">#</a> 2、PCB 设计方法及步骤</h2>\n<p>PCB 设计的主要任务是根据电路原理图对 PCB 进行合理的结构与布线布局设计，典型过程如图 3-8 所示，其主要过程是依据网表中的设计进行布局、布线连接，并通过 PCB 仿真来判断设计是否正确，最终得到 PCB 设计输出。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013214033467.png\" alt=\"image-20241013214033467\"></p>\n<p><strong>1) 建立封装库中没有的元器件</strong></p>\n<p>通常的 CAD 只有一些常见、常用元器件的封装，但是设计 PCB 时，很多元器件并没有对应的封装。因此需要使用 CAD 补全缺失的封装。</p>\n<p><strong>2) 规划电路板</strong></p>\n<p>在封装库准备好之后，设计 PCB 的第一步骤是规划电路板。规划包括如下内容：设置习惯性的环境参数与文档参数，例如选择层面、外形尺标大小等。</p>\n<p>首先需要根据 PCB 的结构与设计确定 PCB 的尺寸，同时创建 PCB 的设计文件。</p>\n<p>然后确定 PCB 设计的坐标原点。PCB 板通常需要将板框的四周进行倒圆角的操作，一般的倒角半径是 5mm。</p>\n<p>根据结构图设置板框尺寸，按结构要素布置安装孔、接插件等需要定位的元器件，并给这些元器件赋予不可移动属性。按工艺设计规范的要求进行尺寸标注。根据结构和生产加工时所需的夹持边设置印制板的禁止布线区、禁止布局区域。根据某些元器件的特殊要求，设置禁止布线区。</p>\n<p><strong>3) 载入网络和元器件封装</strong></p>\n<p>载入之前电路原理设计得到的网络表和有关元器件的封装，并将元器件的摆放到预定位置。</p>\n<p><strong>4) 布置元器件封装</strong></p>\n<p>采用 CAD 自动布置或者手动布置元器件封装的位置。将元器件放置到恰当的方便布线的位置，同时还能满足整齐美观的效果，</p>\n<h2 id=\"3-pcb-布局要求\"><a class=\"anchor\" href=\"#3-pcb-布局要求\">#</a> 3、PCB 布局要求</h2>\n<p>通常 PCB 元器件的布局遵照 “<strong>先大后小，先难后易</strong>” 的布置原则，即重要的单元电路、核心元器件应当优先布局。布局中应参考原理框图，根据单板的主信号流向规律安排主要元器件。</p>\n<p><strong>布局应尽量满足以下要求:</strong></p>\n<ul>\n<li>总的连线尽可能短，关键信号线最短；</li>\n<li>高电压、大电流信号与小电流、低电压的弱信号完全分开；</li>\n<li>拟信号与数字信号分开；</li>\n<li>高频信号与低频信号分开；</li>\n<li>高频元器件的间隔要充分。</li>\n</ul>\n<p>相同结构电路部分，尽可能采用 “对称式” 标准布局，按照均分布、重心平衡、版面美观的标准优化布局。器件布局栅格的设置，一般 I℃ 元器件布局时，栅格应为 50~100 mil，小型表面安装元器件，如表面贴装元器件布局时，栅格设置应不少于 25mil。PCB 的整体布局应按照信号流程安排各个功能电路单元的位置，使整体布局便于信号流通，而且使信号保持一致的方向，各功能单元电路的布局应以主要元器件为中心，在实际布局中应围绕这个中心进行布局。</p>\n<p><strong>通常来说元器件布局有如下要求:</strong></p>\n<ul>\n<li>元器件的摆放不重叠；</li>\n<li>元器件的摆放不影响其他元器件的插拔和贴焊；</li>\n<li>元器件的摆放符合限高要求，不会影响其他元器件、外壳的贴焊及安装，如电解电容由立放改为卧放，从而满足高度要求；</li>\n<li>元器件离板边的距离符合工艺要求，距离不够时加工艺附边，附边上没定位孔时的宽度为 3mm，有定位孔时的宽度为 5mm;</li>\n<li>有极性元器件的摆放方向要尽可能一致，同一板上最多允许两种朝向；</li>\n<li>安装孔的禁布区内无元器件和走线 (不包括安装孔自身的走线和铜)。</li>\n</ul>\n<p><strong>1) 对于采用通孔回流焊的元器件布局要求</strong></p>\n<ul>\n<li>对于非传送边尺寸大于 300mm 的 PCB, 较重的元器件尽量不要布置在 PCB 的中间，以减轻由于插装元器件的重量在焊接过程对 PCB 变形的影响，以及插装过程对板上已经贴放的元器件的影响；</li>\n<li>为方便插装，推荐将元器件布置在靠近插装操作侧的位置；</li>\n<li>对于尺寸较长的元器件 (如内存条插座等)，其长度方向推荐与传送方向一致；</li>\n<li>通孔回流焊元器件的焊盘边缘与连接器及所有的 BGA 的丝印之间的距离大于 10mm，与其他表面贴装元器件间距离大于 2mm;</li>\n<li>通孔回流焊元器件本体间距离大于 10mm，有夹具扶持的插针焊接不做要求。</li>\n</ul>\n<p><strong>2) 对于插件元器件的布局要求</strong></p>\n<p>对于插件元器件的布局，通常要求端子的尺寸、位置要符合结构设计的要求，并达到最佳结构安装。此外过波峰焊的插件元器件焊盘间距大于 1.0mm，为保证过波峰焊时不连锡，过波峰焊的插件元器件焊盘边缘间距应大于 1.0mm (包括元器件本身引脚的焊盘边缘间距); 优选插件元器件引脚间距大于 2.0mm，焊盘边缘间距大于 1.0mm; 在元器件本体不相互干涉的前提下，相邻元器件焊盘边缘间距满足如图 3-9 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215048777.png\" alt=\"image-20241013215048777\"></p>\n<p><strong>3) 焊盘要求</strong></p>\n<p>当插件元器件引脚较多，以焊盘排列方向平行于进板方向布置元器件时，当相邻焊盘边缘间距为 0.6~1.0mm 时，推荐采用椭圆形焊盘或加偷锡焊盘，如图 3-10 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215112564.png\" alt=\"image-20241013215112564\"></p>\n<p>可调元器件、可插拔元器件周围应该留有足够的空间供调试和维修，在实际设计中应根据系统或模块的 PCBA 安装布局以及可调元器件的调测方式来综合考虑可调元器件的排布方向、调测空间，可插拔元器件周围空间预留应根据邻近元器件的高度决定。</p>\n<p>所有的插装磁性元器件一定要有坚固的底座，禁止使用无底座插装电感。</p>\n<p>有极性的变压器的引脚尽量不要设计成对称形式，要考虑防呆工艺，以免插件时机械性出错。</p>\n<p>裸跳线不能贴板跨越板上的导线或铜皮，以避免和板上的铜皮短路，绿油不能作为有效的绝缘。</p>\n<p>电缆的焊接端尽量靠近 PCB 的边缘布置以便插装和焊接，否则 PCB 上别的元器件会阻碍电缆的插装焊接或被电缆碰歪。</p>\n<p>多个引脚在同一直线上的元器件，像连接器、DIP 封装元器件、TO-220 封装元器件，布局时应使其轴线和波峰焊方向平行。</p>\n<p>较轻的元器件如二极管和 1/4W 电阻等，布局时应使其轴线和波峰焊方向垂直。这样能防止过波峰焊时因一端先焊接凝固而使元器件产生浮高现象。</p>\n<p>电缆和周围元器件之间要留有一定的空间，否则电缆的折弯部分会压迫并损坏周围元器件及其焊点。</p>\n<p><strong>4) 贴片元器件的布局要求</strong></p>\n<p>对于贴片元器件而言，一般有着如下的要求。</p>\n<p>两面过回流焊的 PCB 的 BOTTOMLAYER 面要求无大体积、太重的表贴元器件，需两面都过回流焊的 PCB，第一次回流焊接元器件重量限制如表 3-1 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215417008.png\" alt=\"image-20241013215417008\"></p>\n<p>若有超重的元器件必须布在底层面上，并应通过试验验证可行性。焊接面元器件高度不能超过 2.5mm，若超过此值，应把超高元器件列表通知装备工程师，以便特殊处理。需波峰焊加工的单板背面元器件不形成阴影效应的安全距离应考虑波峰焊工艺的贴片元器件距离，相同类型元器件布局如图 3-11 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215507568.png\" alt=\"image-20241013215507568\"></p>\n<p>相同类型元器件的封装尺寸与距离关系如表 3-2 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215531795.png\" alt=\"image-20241013215531795\"></p>\n<p>不同类型元器件在布局时的距离示意图如图 3-12 所示</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215603879.png\" alt=\"image-20241013215603879\"></p>\n<p>不同类型元器件的封装尺寸与距离关系见表 3-3 (单位:mm)</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013215629258.png\" alt=\"image-20241013215629258\"></p>\n<h2 id=\"4-pcb-布线\"><a class=\"anchor\" href=\"#4-pcb-布线\">#</a> 4、PCB 布线</h2>\n<p>在放置完封装之后，可以使用 CAD 自动布线或者手动布线。对于自动布线则需要将自动布线失败或者不满足需求的地方手工重新布线。</p>\n<p>布线的优先次序一般是:<strong> 电源</strong>、<strong>模拟小信号</strong>、<strong>高速信号</strong>、<strong>时钟信号</strong>和<strong>同步信号</strong>等关键信号优先布线。</p>\n<p>应遵循密度优先原则，即从单板上连接关系最复杂的元器件着手布线。从单板上连线最密集的区域开始布线</p>\n<p>自动布线在布线质量满足设计要求的情况下，可使用自动布线器以提高工作效率。</p>\n<p>在自动布线前应准备自动布线控制文件，该文件是为了更好地控制布线质量，一般在运行前详细定义布线规则，这些规则可以在软件的图形界面内进行定义，但软件提供了更好的控制方法，即针对设计情况，写出自动布线控制文件，软件在该文件控制下运行。</p>\n<p>电源走线和地线走线之间的电磁兼容性环境较差，应避免布置对干扰敏感的信号。接地系统的结构由系统地、屏蔽地、数字地和模拟地构成：数字地和模拟地要分开，即分别与电源地相连。</p>\n<p><strong>环路最小规则</strong>，即信号线与其回路构成的环面积要尽可能小，环面积越小，对外的辐射越少，接收外界干扰也越小。针对这一规则，在地平面分割时，要考虑到地平面与重要信号走线的分布，防止由于地平面开槽等带来的问题：在双层板设计中，</p>\n<ul>\n<li>在为电源留下足够空间的情况下，应该将留下的部分用参考地填充，且增加一些必要的孔，将双面地信号有效连接起来，</li>\n<li>对一些关键信号尽量采用地线隔离，</li>\n<li>对一些频率较高的设计，需特别考虑其地平面信号回路问题，建议采用多层板为宜。</li>\n</ul>\n<p><strong>具体原则包括:</strong></p>\n<p>(1) 有阻抗控制要求的网络应布置在阻抗控制层上。</p>\n<p>(2) 各种印制板走线要在容许的空间短而粗，线条要均匀。</p>\n<p>(3) 串扰控制，串扰是指 PCB 上不同网络之间因较长的平行布线引起的相互干扰，主要是由于平行线间的分布电容和分布电感的作用。克服串扰的主要措施包括:</p>\n<ul>\n<li>加大平行布线的间距，遵循 3W 规则；</li>\n<li>在平行线间插入接地的隔离线；</li>\n<li>减小布线层与地平面的距离。</li>\n</ul>\n<p>(4) 最外沿信号线与禁止布线层和机械边缘保持最小 0.7mm 距离</p>\n<p>(5) 印制板布线和覆铜拐角尽量使用 45° 折线或折角，PCB 设计中应避免产生锐角和直角而不用 90°。</p>\n<p>(6) 对于经常插拔或更换的焊盘，要适当增加焊盘与导线的连接面积 (泪滴焊盘)，特别是对于单面板的焊盘，以增加机械强度，避免过波峰焊接时将焊盘拉脱、机械损耗性脱落等。</p>\n<p>(7)<strong> 任何信号都不要形成环路</strong>，如不可避免，让环路区尽量小。</p>\n<p>(8)<strong> 对噪声敏感的元器件下面不要走线</strong>。</p>\n<p>(9) 高频线与低频线要保持规定要求间距，以防止出现串扰。</p>\n<p>(10) 多层板走线应尽量避免平行、投影重叠，以垂直为佳，以减小分布电容对整机的影响。</p>\n<p>(11) 大面积覆铜需将铜箔制作成网状覆铜工艺，以防止 PCB 在高温时会出现气泡而导致铜箔脱落的现象。</p>\n<p>(12) 尽量加粗地线，可通过三倍的允许电流。</p>\n<p>(13) 布板时考虑放置测试点，方便生产线调试，测试点统一为八角形</p>\n<p>(14) 同一尺寸板上布不同机种时，两端端子位置尽量保持一致，方便生产线制作工具。</p>\n<p>通常情况下，布局基本确定后，应用 PCB 设计工具的统计功能，报告网络数量，网<br>\n络密度，平均管脚密度等基本参数，以便确定所需要的信号布线层数。布线层设置在高速数字电路设计中，电源与地层应尽量靠在一起，中间不安排布线。所有布线层都尽量靠近一平面层，优选地平面为走线隔离层。为了减少层间信号的电磁干扰，相邻布线层的信号线走向应取垂直方向。</p>\n<p>可以根据需要设计 1~2 个阻抗控制层，如果需要更多的阻抗控制层，应与 PCB 产家协商。阻抗控制层应按要求标注清楚。将单板上有阻抗控制要求的网络布线分布在阻抗控制层上 (单面板不用考虑)。</p>\n<p>线宽和线间距的设置要考虑的因素:</p>\n<ul>\n<li>单板的密度。板的密度越高，倾向于使用更细的线宽和更窄的间隙。</li>\n<li>信号的电流强度。当信号的平均电流较大时，应考虑布线宽度所能承载的电流，线宽可参考以下数据。</li>\n<li>电路工作电压。线间距的设置应考虑其介电强度。</li>\n</ul>\n<h2 id=\"5-设计规则检查\"><a class=\"anchor\" href=\"#5-设计规则检查\">#</a> 5、设计规则检查</h2>\n<p>按照 PCB 设计规则，检査 PCB 设计是否合乎规范。对于元器件、铜线、过孔、覆铜等按照一定规则检查。例如，元器件不可以重叠，布线间距不合乎规范。一般可使用 CAD 对电路进行检查，将不符合规范的设计与未连接的部分查找出来。</p>\n<p>PCB 设计检查还应当着重检查热设计要求。PCB 布局时要考虑将高热元器件放在出风口或利于空气对流的位置。较高的元器件应考虑放于出风口，且不阻挡风路，散热器的放置应考虑利于空气对流。</p>\n<p>对温度敏感器等元器件应考虑远离热源，对于自身温升高于 30℃的热源，一般要求:</p>\n<ul>\n<li>在风冷条件下，电解电容等温度敏感元器件离热源距离要求大于或等于 2.5mm;</li>\n<li>自然冷条件下，电解电容等温度敏感元器件离热源距离要求大于或等于 4.0mm;</li>\n<li>若因为空间的原因不能达到要求距离，则应通过温度测试保证温度敏感元器件的。温升在降额范围内。</li>\n</ul>\n<p>大面积铜箔要求用隔热带与焊盘相连，为了保证透锡良好，在大面积铜上的元器件的焊盘要求用隔热带与焊盘相连，对于需过 5A 以上大电流的焊盘不能采用隔热焊盘，如图 3-13 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013220358049.png\" alt=\"image-20241013220358049\"></p>\n<p>如果使用回流焊的方式，0805 以及封装小于 0805 以下的片式元器件两端焊盘的散热对称性为了避免元器件过回流焊后出现偏位、立碑现象，焊盘与印制导线的连接部宽度不应大于 0.3mm (对于不对称焊盘)。</p>\n<p>高热元器件的安装方式及是否考虑带散热器，确定高热元器件的安装方式易于探作和焊接，原则上当元器件的发热密度超过 0.4W/cm?，单靠元器件的引线腿及元器件本身不足以充分散热。应采用散热网、汇流条等措施来提高过电流能力，汇流条的支脚应采用多点连接，尽可能采用铆接后过波峰焊或直接过波峰焊接，以利于装配、焊接；对于较长汇流条的使用，应考虑过波峰时受热汇流条与 PCB 热膨胀系数不匹配造成的 PCB 变形：为了保证搪锡易于操作，锡道宽度应不大于等于 2.0mm，锡道边缘间距大于 1.5mm。</p>\n<p>贴片元器件之间的最小间距满足如下要求。</p>\n<ul>\n<li>机贴元器件距离要求，如图 3-14 所示。</li>\n</ul>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241013220511135.png\" alt=\"image-20241013220511135\"></p>\n<ul>\n<li>同种元器件间距大于 0.3mm</li>\n<li>异种元器件间距大于 0.13xh+0.3mm (h 为周围近邻元器件最大高度差)。</li>\n<li>只能手工贴片的元器件之间距离要求大于 1.5mm。</li>\n</ul>\n<h2 id=\"6-pcb-仿真分析\"><a class=\"anchor\" href=\"#6-pcb-仿真分析\">#</a> 6、PCB 仿真分析</h2>\n<p>使用 CAD 软件对 PCB 进行仿真分析，确定 PCB 达到需求与设计目标。</p>\n<h2 id=\"7-保存输出\"><a class=\"anchor\" href=\"#7-保存输出\">#</a> 7、保存输出</h2>\n<p>将设计工程保存，并且导出相关文件以便于 PCB 加工。</p>\n<h2 id=\"8-多层-pcb-设计的注意事项及布线原则\"><a class=\"anchor\" href=\"#8-多层-pcb-设计的注意事项及布线原则\">#</a> 8、多层 PCB 设计的注意事项及布线原则</h2>\n<p>在多层 PCB 布线时应注意以下事项:</p>\n<p>(1) 高频信号线一定要短，不可以有尖角 (90° 直角)，两根线之间的距离不宜平行过近，否则可能会产生寄生电容。</p>\n<p>(2) 如果是两面板，一面的线布成横线，另一面的线布成竖线，尽量不要布成斜线</p>\n<p>(3) 如果使用自动布线无法完成所有布线，建议设计者首先手工将比较复杂的线布好，将布好的线锁定后，再使用自动布线功能，一般就可以完成全部布线。</p>\n<p>(4) 一般来说，线宽一般为 0.3mm，间隔也为 0.3mm。但是电源线或者大电流线应</p>\n<p>该有足够宽度。焊盘一般应为 64mil。如果是单面板，必须考虑焊盘，否则一般来说生产单面板的工艺都很差，所以单面板的焊盘尽量做得大一些，线要尽量粗一些，表 3-4 给出的是常见的焊盘尺寸。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241014065513522.png\" alt=\"image-20241014065513522\"></p>\n<p>(5) 做好屏蔽，铜膜线的地线应该在电路板的周边，同时将电路上可以利用的空间全部使用铜箔做地线，增强屏蔽能力，并且防止寄生电容。多层板因为内层做为电源层和地线层，一般不会有屏蔽的问题。大面积敷铜应改用网格状，以防止焊接时板子产生气泡和因为热应力作用而弯曲。</p>\n<p>(6) 焊盘的内孔尺寸必须从元器件引线直径、公差尺寸、镀层厚度、孔径公差及孔金属化电镀层厚度等方面考虑，通常情况下以金属引脚直径加上 0.2mm 作为焊盘的内孔直径。例如，电阻的金属引脚直径为 0.5mm, 则焊盘孔直径为 0.7mm。当焊盘直径为 1.5mm 时，为了增加焊盘的抗剥离强度，可采用方形焊盘。对于孔直径小于 0.4mm 的焊盘，焊盘外径 / 焊盘孔直径为 0.5~3mm。对于孔直径 2mm 的焊盘，焊盘外径 / 焊盘孔直径为 1.5~2mm。焊盘一般应该补成泪滴状，这样线与焊盘的连接强度会大大增强。</p>\n<p>(7) 地线的共阻抗干扰。电路图上的地线表示电路中的零电位，并用作电路中其他各点的公共参考点。在实际电路中由于地线 (铜膜线) 阻抗的存在，必然会带来共阻抗干扰，因此在布线时，不能将具有地线符号的点随便连接在一起，这可能引起有害的耦合而影响电路的正常工作。</p>\n<h2 id=\"9-丝印设计\"><a class=\"anchor\" href=\"#9-丝印设计\">#</a> 9、丝印设计</h2>\n<p>丝印设计是 PCB 设计中容易被忽视但又十分重要的一个环节。容易被忽视是由于 PCB 并不会因为缺少丝印而不能工作，说其十分重要是因为丝印是 PCB 设计的一个缩影。</p>\n<p>丝印有效的标记元器件、安装孔、定位孔等 PCB 上关键的元素。一般丝印设计要求所有元器件、安装孔、定位孔都有对应的丝印标号，PCB 上的安装孔丝印可用 H (Hole)，H，…，H” 进行标识。同时 PCB 上元器件的标识符必须和 BOM 清单中的标识符号一致。</p>\n<p>PCB 板有高压和大电流处，要加上相应的警示标识，并且要保证标识的醒目、清晰、易辨识。同时丝印字符要在元器件本体以外，以避免元器件安装后本体遮住丝印</p>\n<p>字符而降低元器件插装和维修效率。丝印字符要与对应元器件保持最近距离，若空间不足，可采用箭头方式在尽可能距离近的位置进行丝印字符标识。丝印字符方向遵循从左至右、从上往下的原则，对于电解电容、二极管等极性的元器件在每个功能单元内尽量保持方向一致。</p>\n<p>为了保证元器件的焊接可靠性，要求元器件焊盘上无丝印；为了保证锡的锡道连续性，要求需搪锡的锡道上无丝印；丝印不能压在导通孔、焊盘上，以免开阻焊窗时造成部分丝印丢失，影响识别：丝印间距应大于 0.254mm。丝印字符大小在同一板子上要保持一致，参考尺寸为：字高是 1.5mm 字径 (笔划的线宽) 为 0.2mm，字体是 sans serif</p>\n<h2 id=\"10-pcb-的可靠性设计\"><a class=\"anchor\" href=\"#10-pcb-的可靠性设计\">#</a> 10、PCB 的可靠性设计</h2>\n<p>目前电子器材用于各类电子设备和系统时仍然以 PCB 为主要装配方式。实践证明，即使电路原理图设计正确，PCB 设计不当，也会对电子设备的可靠性产生不利影响。例如，<strong>若 PCB 两条细平行线靠得很近</strong>，则会形成信号波形的<strong>延迟</strong>，在传输线的终端形成<strong>反射噪声</strong>。</p>\n<p>因此，在设计 PCB 的时候，应注意采用正确的方法，具体的一些参考性设计要点描述如下。</p>\n<p><strong>1) 地线设计</strong></p>\n<p>在电子设备中，接地是控制干扰的重要方法。如能将接地和屏蔽正确结合起来使用，可解决大部分干扰问题。电子设备中地线结构大致有系统地、机壳地 (屏蔽地)、数字地 (逻辑地) 和模拟地等。在地线设计中应注意以下几点:</p>\n<ul>\n<li>(1)<strong> 正确选择单点接地与多点接地</strong>。在低频电路中，信号的工作频率小于 1MHz 其布线和元器件间的电感影响较小，而接地电路形成的环流对干扰影响较大，因而应采用一点接地。当信号工作频率大于 10MHz 时，地线阻抗变得很大，此时应尽量降低地线阻抗，应采用就近多点接地。当工作频率在 1~10MHz 时，如果采用一点接地，其地线长度不应超过波长的 1/20，否则应采用多点接地法。</li>\n<li>(2)<strong> 将数字电路与模拟电路分开</strong>。电路板上既有高速逻辑电路，又有线性电路，应使它们尽量分开，两者的地线不要相混，分别与电源端地线相连，要尽量加大线性电路的接地面积。</li>\n<li>(3)<strong> 尽量加粗接地线</strong>。若接地线很细，接地电位则随电流的变化而变化，致使电子设备的定时信号电平不稳，抗噪声性能变差。因此应将接地线尽量加粗，使它能通过三倍于 PCB 的允许电流。如有可能，接地线的宽度应大于 3mm。</li>\n<li>(4)<strong> 将接地线构成闭环路</strong>。设计只由数字电路组成的 PCB 的地线系统时，将接地线做成闭环路可以明显提高抗噪声能力。其原因在于：PCB 上有很多集成电路元器件，尤其遇有耗电多的元器件时，因受接地线粗细的限制，会在接地结构上产生较大的电位差。引起抗噪声能力下降，若将接地结构成环路，则会缩小电位差值，提高电子设备的抗声能力。</li>\n</ul>\n<p><strong>2) 电磁兼容性设计</strong></p>\n<p>电磁兼容性是指电子设备在各种电磁环境中仍能够协调有效地进行工作的能力。电磁兼容性设计的目的是使电子设备既能抑制各种外来的干扰，使电子设备在特定的电磁环境中能够正常工作，又能减少电子设备本身对其他电子设备的电磁干扰。</p>\n<ul>\n<li>\n<p>(1)<strong> 选择合理的导线宽度</strong>。由于瞬变电流在印制线条上所产生的冲击干扰主要是由印制导线的电感成分造成的，因此应尽量减小印制导线的电感量。印制导线的电感与其长度成正比，与其宽度成反比，因而短而精细的导线对抑制干扰是有利的。时钟引线、行驱动器或总线驱动器的信号线常常载有大的瞬变电流，印制导线要尽可能地短。对于分立元器件电路，印制导线宽度在 1.5mm 左右时，即可完全满足要求；对于集成电路，印制导线宽度可在 0.2~1.0mm 之间选择。</p>\n</li>\n<li>\n<p>(2)<strong> 采用正确的布线策略</strong>。采用平行走线可以减少导线电感，但导线之间的互感和分布电容增加，如果布局允许，最好采用井字形网状布线结构。具体做法是 PCB 的一面横向布线，另一面纵向布线，然后在交叉孔处用金属化孔相连，</p>\n</li>\n<li>\n<p>为了抑制 PCB 导线之间的串扰，在设计布线时应尽量避免长距离的平行走线，尽可能拉开线与线之间的距离，信号线与地线及电源线尽可能不交叉。在一些对干扰十分敏感的信号线之间设置一根接地的印制线，可以有效地抑制串扰。</p>\n</li>\n<li>\n<p>为了避免高频信号通过印制导线时产生的电磁辐射，在 PCB 布线时，还应注意以下几点:</p>\n<ul>\n<li>\n<p>尽量减少印制导线的不连续性，例如导线宽度不要突变，导线的拐角应大于 90°，禁止环状走线等；</p>\n</li>\n<li>\n<p>时钟信号引线最容易产生电磁辐射干扰，走线时应与地线回路相靠近，驱动器应紧挨着连接器；</p>\n</li>\n<li>\n<p>总线驱动器应紧挨其欲驱动的总线。对于那些离开 PCB 的引线，驱动器应紧紧挨着连接器；</p>\n</li>\n<li>\n<p>数据总线的布线应每两根信号线之间夹一根信号地线。最好是紧紧挨着最不重要的地址引线放置地回路，因为后者常载有高频电流。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>(3)<strong> 抑制反射干扰</strong>。为了抑制出现在印制线条终端的反射干扰，除了特殊需要之外，应尽可能缩短印制线的长度和采用慢速电路。必要时可加终端匹配，即在传输线的末端对地和电源端各加接一个相同阻值的匹配电阻。根据经验，对一般速度较快的 TT 电路，其印制线条长于 10cm 以上时就应采用终端匹配措施。匹配电阻的阻值应根据集成电路的输出驱动电流及吸收电流的最大值来决定。</p>\n</li>\n</ul>\n<p><strong>3) 去耦电容配置</strong></p>\n<p>在直流电源回路中，负载的变化会引起电源噪声。例如在数字电路中，当电路从一个状态转换为另一种状态时，就会在电源线上产生一个很大的尖峰电流，形成瞬变的噪声电压。配置去耦电容可以抑制因负载变化而产生的噪声，是印制电路板可靠性设计的 - 种常规做法，一般配置原则如下:</p>\n<ul>\n<li>电源输入端跨接一个 10~100HF 的电解电容器，如果 PCB 的位置允许，采用 100HF 以上的电解电容器的抗干扰效果会更好；</li>\n<li>为每个集成电路芯片配置一个 0.01F 的陶瓷电容器。如遇到 PCB 空间小而装不下时，可每 4~10 个芯片配置一个 1~10F 钽电解电容，这种元器件的高频阻抗特别小，在 50kHz~20MHz 范围内阻抗小，而且漏电流很小 (0.5nA 以下);</li>\n<li>对于噪声能力弱、关断时电流变化大的元器件和 ROM、RAM 等存储型元器件，应在芯片的电源线和地线间直接接入去耦电容；</li>\n<li>去耦电容的引线不能过长，特别是高频旁路电容不能带引线。</li>\n</ul>\n<p><strong>4) PCB 的尺寸与元器件的布置</strong></p>\n<p>PCB 大小要适中，过大时印制线条长，阻抗增加，不仅抗噪声能力下降，成本也高；</p>\n<p>过小则散热不好，同时易受临近线条干扰。在元器件布置方面与其他逻辑电路一样，应把相互有关的元器件尽量放得靠近些这样可以获得较好的抗噪声效果，如图 3-15 所示。时钟发生器、品振和 CPU 的时钟输入端都易产生噪声，要相互靠近些。易产生噪声的元器件、小电流电路、大电流电路等应尽量远离逻辑电路，如有可能，应另做 PCB。</p>\n<p><img data-src=\"../../../img.assets/24-10-15%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/image-20241014070701210.png\" alt=\"image-20241014070701210\"></p>\n<p><strong>5) 散热设计</strong></p>\n<p>从有利于散热的角度出发，PCB 最好是直立安装，板与板之间的距离一般不应小于 2cm，而且元器件在 PCB 上的排列方式应遵循一定的规则:</p>\n<ul>\n<li>对于采用自由对流空气冷却的设备，最好是将集成电路 (或其他元器件) 按纵长方式排列；对于采用强制空气冷却的设备，最好是将集成电路 (或其他元器件) 按横长方式排列；</li>\n<li>同一块 PCB 上的元器件应尽可能按其发热量大小及散热程度分区排列，发热量小或耐热性差的元器件 (如小信号品体管、小规模集成电路、电解电容等) 放在冷却气流的最上游 (入口处)，发热量大或耐热性好的元器件 (如功率晶体管、大规模集成电路等) 放在冷却气流最下游；</li>\n<li>在水平方向上，大功率元器件尽量靠近 PCB 边沿布置，以便缩短传热路径：在重直方向上，大功率元器件尽量靠近 PCB 上方布置，以便减少这些元器件工作时对其他元器件温度的影响:</li>\n<li>对温度比较敏感的元器件最好安置在温度最低的区域 (如设备的底部)，千万不要将它放在发热元器件的正上方，多个元器件最好是在水平面上交错布局；</li>\n<li>设备内 PCB 的散热主要依靠空气流动，所以在设计时要研究空气流动路径，合理配置元器件或 PCB。空气流动时总是趋向于阻力小的地方流动，所以在 PCB 上配置元器件时，要避免在某个区域留有较大的空域。整机中多块 PCB 的配置也应注意同样的问题。</li>\n</ul>\n<p>大量实践经验表明，采用合理的元器件排列方式，可以有效地降低印制电路的温升，从而使元器件及设备的故障率明显下降。</p>\n<p>以上所述只是 PCB 可靠性设计的一些通用原则，PCB 可靠性与具体电路有着密切的关系，在设计中还需根据具体电路进行相应处理，才能最大限度地保证 PCB 的可靠性。</p>\n<h1 id=\"三-电子电路测试基础知识\"><a class=\"anchor\" href=\"#三-电子电路测试基础知识\">#</a> 三、电子电路测试基础知识</h1>\n<h2 id=\"1-电子电路测试方法\"><a class=\"anchor\" href=\"#1-电子电路测试方法\">#</a> 1、电子电路测试方法</h2>\n<p>电子电路测试包括内部测试、功能测试、边界扫描与 JTAG。</p>\n<p>1) 内部测试电路测试的第一步是在 PCB 装配完成之后对板上各个元器件进行检查：是否正确安装、型号与数值是否正确、焊接是否合格。无论是手工还是机器加工的 PCB 都可能出现错误，因此对 PCB 的检查十分重要。</p>\n<p>然后进行的电路内部测试则是使用自动测试与测试程序。PCB 上每个结点都需要进行探测，使用探针床测试夹进行 PCB 测试。自动化工具可以通过 PCB 设计自动计算 PCB 测试工具的设计与各个结点正确的状态，并以此进行测试。</p>\n<p>然而这样的测试并不能保证整个系统不会故障，电路的内部测试效果也比较有限，只能保证基本的正确性而无法保证整个系统按照设计运行，因此需要使用功能测试。</p>\n<p>2) 功能测试</p>\n<p>功能测试是在接通电源、激励或者特殊测试信号与输入 / 输出线之后，测试装配好电路板的功能。使用各类仪器对电路相关部分进行测试，同时进行校准和调整。对于嵌入式系统，一般需要按照一定流程制订专门的测试步骤。而功能测试可以使用自动化设备进行测试，以简化人工成本。</p>\n<p>3) 边界扫描与 JTAG 通常来说，数字电路的测试会较为复杂。由于许多数字电路本身太过于复杂，常规的测试无法有效的进行。成百上千个测试点，外加各类 IC 复杂的逻辑与状态无法使用简单的电气特性测试来测试，因此边界扫描和 JTAG 能够较为有效地进行测试。边界测试是常见的硬件测试方式，而 JTAG 则是嵌入式中最常用的方式，它利用与 IC 芯片内部调试模块进行通信的方式进行调试与测试。</p>\n<h2 id=\"2-硬件可靠性测试\"><a class=\"anchor\" href=\"#2-硬件可靠性测试\">#</a> 2、硬件可靠性测试</h2>\n<p>以行业标准或者国家标准为基础的可靠性测试包括电磁兼容试验、气候类环境试验机械类环境试验和安规试验等。</p>\n<p>由于网络产品的功能千差万别，应用场合可能是各种各样的，而与可靠性测试相关的行业标准、国家标准一般情况下只给出了某类产品的测试应力条件，并没有指明被测设备在何种工作状态或配置组合下接受测试，因此在测试设计时可能会遗漏某些测试组合。例如机框式产品，线卡种类、线卡安装位置、报文类型、系统电源配置均可灵活搭配，这里涉及到的测试组合会较多，这些测试组合中必然会存在比较极端的测试组合。再如验证该机框的系统散热性能，最差的测试组合是在散热条件机框上满配最大功率的线卡板。如果考虑其某线卡板低温工作性能，比较极端的组合是在散热条件最好的机框上配置最少的单板且配置的单板功耗最小，并且把单板放置在散热最好的槽位上。</p>\n<p>总之，在做测试设计时，需要跳出传统测试规格和测试标准的限制，以产品应用的角度进行测试设计，保证产品的典型应用组合、满配置组合或者极端测试组合下的每一个硬件特性、硬件功能都充分暴露在各种测试应力下。这个环节的测试保证了，产品的可靠性才得到保证。</p>\n<p>针对不同的产品形态，硬件可靠性测试项目可能有所差异，但是其测试的基本思想是一致的，其基本的思路都是完备分析测试对象可能的应用环境，在可能的应用环境下会承受可能工作状态包括极限工作状态，在实验室环境下制造各种应力条件、改变设备工作状态，设法让产品的每一个硬件特性、硬件功能都一一暴露在各种极限应力下，遗漏任何一种测试组合必然会影响到产品的可靠性。</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式电源系统是集成在嵌入式系统中，为嵌入式设备提供直流基础电能的电源设备，是一种安全、可靠、高性能的供电系统。一般来说，嵌入式电源的输入都为交流市电，输出是常见直流 12V、5V、3.3V，是一类二次电源设备。</p>\n<p><strong>交流电源</strong>是嵌入式系统较为重要的电能来源之一。嵌入式系统的电能由该类电源直接或者间接提供。通常使用市电作为输入，通过一系列变化、转化操作将交流高压电转变为低压直流电。</p>\n<p><strong>电池</strong>是许多嵌入式系统直接供电的电源，诸如手机、传感器，都会使用电池供电。电池的供电设备往往是功耗相对较小，而连续工作时间较长的设备，因此嵌入式系统的功耗有着较为严格的要求，在不同的应用场景需求下可能会增加电池的容量。</p>\n<p><strong>稳压器</strong>则是常见配合交流电源与电池使用的一种元器件。由于嵌入式系统中往往需要多种电压，因此在嵌入式系统中会使用稳压器将电压降至所需范围。</p>\n<h1 id=\"一-电源管理\"><a class=\"anchor\" href=\"#一-电源管理\">#</a> 一、电源管理</h1>\n<p>嵌入式系统的一个典型的硬性需求是降低功耗，许多嵌入式设备往往使用电池供电，并且常年无人看管，因此功耗问题非常重要。而在电池容量有限或者设备数量较大的时候，系统的功耗就变得至关重要。</p>\n<p>首先绝大多数嵌入式系统都会包含基础电源管理功能以降低功耗。</p>\n<h2 id=\"1系统上电行为\"><a class=\"anchor\" href=\"#1系统上电行为\">#</a> (1)<strong> 系统上电行为</strong></h2>\n<p>嵌入式系统的组件往往在系统正常启动之后才能进入低功耗模式，因此在上电的时候通常会以较高的功率来运行。而上电期间很多设备并不需要工作，因此在上电启动的时候需要有效管理这些设备以减小功耗。</p>\n<h2 id=\"2空闲模式\"><a class=\"anchor\" href=\"#2空闲模式\">#</a> (2)<strong> 空闲模式</strong></h2>\n<p><strong>CMOS 电路有效的功耗是在电路时钟工作的时候产生的</strong>，因此可以通过关闭不需要的时钟来降低功耗。而现代嵌入式系统所使用的元器件往往都提供了通过外部事件唤醒的功能，因此在不使用某些模块的期间内，可以通过主处理器向相关元器件发送 “睡眠” 指令，以指示其进入低功耗状态。当需要重新触发器件进入工作时，通过特定的触发事件进行元器件唤醒。</p>\n<h2 id=\"3断电\"><a class=\"anchor\" href=\"#3断电\">#</a> (3)<strong> 断电</strong></h2>\n<p>由于逆向偏压泄露，电路元器件在低功耗模式下依然会损耗电能，因此对于低功耗模式消耗电能较大或者长期不使用的元器件，可以做断电处理以减少功耗。</p>\n<h2 id=\"4电压与频率缩放\"><a class=\"anchor\" href=\"#4电压与频率缩放\">#</a> (4)<strong> 电压与频率缩放</strong></h2>\n<p>有效功率与切换频率成线性比例，但与电源电压平方成正比。经常以较低的频率运行于全时钟频率，然后转入闲置，并不能节约很多功率。在此种情况下，可以<strong>通过降低电压来节约功率</strong>。</p>\n<h1 id=\"例如\"><a class=\"anchor\" href=\"#例如\">#</a> 例如</h1>\n<p>某嵌入式系统数字电路部分需要支流电源供电，输入电压为 220V 交流电，电源管理模块首先采用的开关电源将 220V 的交流电转换为直流电压，再利用低压线性稳压器为各个子模块供电，对应的实现框图如图 3-1 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013210849978.png\" alt=\"image-20241013210849978\"></p>\n<p>在电源产生电路中，为了避免模拟信号与数字信号地之间的相互干扰，将输入的 220V 交流电压转换为两个独立的直流电源，再分别为模拟电路和数字电路的电源供电。例如该项目设计中需要 12V、24V、5V、8V、-8V、3.3V 等不同电压，对应的电源管理系统拓扑结构如图 3-2 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013210936078.png\" alt=\"image-20241013210936078\"></p>\n<h2 id=\"具体实现如下\"><a class=\"anchor\" href=\"#具体实现如下\">#</a> 具体实现如下:</h2>\n<h2 id=\"1-12v-转8v\"><a class=\"anchor\" href=\"#1-12v-转8v\">#</a> ① +12V 转 + 8V</h2>\n<p>采用的是 LM7808，这是一款三端集成的稳压电路，能够准确的降压到 + 8V，输入要保证为 12V 直流电源，保证输入比输出稳压值 8V 高出一定压差，即可实现 8V 稳压，设计时需要注意电流不要超载。在具体设计时，<strong>电路两端的电容作用都为滤波，用来平滑电压与提高抗干扰能力</strong>。其中输出端可并联 220HF/25V 的电解电容，其白谐频率小，能够起到储能滤波的功能，消除低频干扰。但是由于<strong>大电容的电解电容自身存在一定的电感</strong>，对于高频信号以及脉冲干扰信号无法有效滤除，<strong>因此，设计中一般会并联一个或几个容值比较小的陶瓷电容，以达到滤除高频干扰信号的作用</strong>，对应的设计如图 3-3 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013211134986.png\" alt=\"image-20241013211134986\"></p>\n<h2 id=\"2-12v-转-8v\"><a class=\"anchor\" href=\"#2-12v-转-8v\">#</a> ② +12V 转 - 8V</h2>\n<p>采用 NE555 芯片，这是一款将模拟功能和逻辑功能很好地结合在一起的芯片，该款芯片为 8 脚集成电路，大约在 1971 年由 Signetics 公司发布，在当时是唯一非常快速且商业化的芯片，在之后的 40 余年中被普遍使用，且延伸出许多的应用电路，后来则是基于 CMOS 技术版本的芯片 (如 Motorola 的 MC1455) 被大量使用，但原规格的 NE555 依然正常供应，尽管新版 IC 在功能上有部分改善，但其脚位功能并没变化，所以到目前都可直接的代用应用的范围十分广泛，其实现的典型电源转换电路如图 3-4 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013211325750.png\" alt=\"image-20241013211325750\"></p>\n<p>在其设计中，当 NE555 的第三脚输出高电平，通过 D1 向 C1 充电，电压可达 11V。当 NE555 输出为低电平时，D1 被 C2 反偏截止。C2 向 C3 转移电荷，重复多次后 C3 电压达 8V，相对地线则输出视为 - 8V。</p>\n<h2 id=\"3-12v-转5v\"><a class=\"anchor\" href=\"#3-12v-转5v\">#</a> ③ +12V 转 + 5V</h2>\n<p>采用的是开关型集成稳压芯片 LM2596，它内含固定频率振荡器以及基准稳压器，并具备完善的保护电路、热关断电路、电流限制等。LM2596 是降压型电源管理单片集成电路的开关电压调节器，能够输出 3A 的驱动电流，同时具有很好的线性和负载调节特性。固定输出版本有 3.3V、5V、12V，可调版本可以输出小于 37V 的各种电压。使用 LM2596 进行 + 12V 转 + 5V 的典型电路图如图 3-5 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013211627791.png\" alt=\"image-20241013211627791\"></p>\n<h2 id=\"4-5v-转33v\"><a class=\"anchor\" href=\"#4-5v-转33v\">#</a> ④ +5V 转 + 3.3V</h2>\n<p>采用 LM1117-3.3，这也是一款<strong>低压差线性稳压器</strong>，输入电压只要在允许范围内，它的输出电压都可以稳定在一个电压，使用 工 M1117-3.3 来进行 + 5V 转 + 3.3V 的电路如图 3-6 所示。</p>\n<p><img data-src=\"../../../img.assets/24-10-13%E5%B0%8F%E6%9F%B4%E5%86%B2%E5%88%BA%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/image-20241013211730308.png\" alt=\"image-20241013211730308\"></p>\n<h2 id=\"5-24v-转5v\"><a class=\"anchor\" href=\"#5-24v-转5v\">#</a> ⑤ +24V 转 + 5V</h2>\n<p>直接采用 WD5-24S5，DC-DC 电源模块 WD5 系列具有 5W 输出功率、宽电压输入、输入 / 输出隔离、小型化封装等特性。</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        },
        {
            "id": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "url": "https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c3251f5b.html",
            "title": "小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理",
            "date_published": "2024-10-12T16:00:00.000Z",
            "content_html": "<html><head></head><body><p></p><div class=\"links\"><div class=\"item\" title=\"【知乎】flechazo\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=\">【知乎】flechazo</span>\n          <p class=\"desc\">https://www.zhihu.com/people/jiu_sheng</p>\n          </div></div></div><p></p>\n<p></p><div class=\"links\"><div class=\"item\" title=\"【CSDN】小柴带你学AutoSar总目录\" style=\"--block-color:#21d4fd;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\" data-background-image=\"https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=\">【CSDN】小柴带你学AutoSar总目录</span>\n          <p class=\"desc\">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p>\n          </div></div></div><p></p>\n<p>Autosar 系列教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==\">小柴带你学 AutoSar 总目录</span></p>\n<h1 id=\"小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\"><a class=\"anchor\" href=\"#小柴冲刺软考中级嵌入式系统设计师系列三-嵌入式硬件设计1嵌入式系统电源管理\">#</a> 小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</h1>\n<p>嵌入式</p>\n</body></html>",
            "tags": [
                "技术教程🎃",
                "嵌入式系统设计师",
                "嵌入式系统设计师"
            ]
        }
    ]
}