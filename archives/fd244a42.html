<!-- build time:Mon Feb 10 2025 22:46:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><script src="http://echarts.baidu.com/dist/echarts.common.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/map/js/china.min.js"></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="yandex-verification" content="fadb7324b0f3dbe2"><link rel="alternate" type="application/rss+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/atom.xml"><link rel="alternate" type="application/json" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="AUTOSAR,嵌入式,软件开发"><link rel="canonical" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html"><title>小柴带你学AutoSar系列三、标准和规范篇（4）RTE - AUTOSAR - 技术教程🎃 | flechazo = 我在人间贩卖黄昏，只为收集世间温柔遇见你. = 有幸来到人间的旅人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">小柴带你学AutoSar系列三、标准和规范篇（4）RTE</h1><div class="meta"><span class="item" title="创建时间：2024-11-01 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-11-01T00:00:00+08:00">2024-11-01</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">flechazo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/archives/fd244a42.html../../../wallpaper/4.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/" itemprop="item" rel="index" title="分类于 技术教程🎃"><span itemprop="name">技术教程🎃</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/AUTOSAR/" itemprop="item" rel="index" title="分类于 AUTOSAR"><span itemprop="name">AUTOSAR</span></a><meta itemprop="position" content="2"></span></div><article itemscope="" itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="flechazo"><meta itemprop="description" content="有幸来到人间的旅人, 我在人间贩卖星光"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="我在人间贩卖黄昏，只为收集世间温柔遇见你."></span><div class="body md" itemprop="articleBody"><p></p><div class="links"><div class="item" title="【知乎】flechazo" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=">【知乎】flechazo</span><p class="desc">https://www.zhihu.com/people/jiu_sheng</p></div></div></div><p></p><p></p><div class="links"><div class="item" title="【CSDN】小柴带你学AutoSar总目录" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">【CSDN】小柴带你学AutoSar总目录</span><p class="desc">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p></div></div></div><p></p><p>Autosar 系列教程：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==">小柴带你学 AutoSar 总目录</span></p><h1 id="小柴带你学autosar系列三-标准和规范篇4rte"><a class="anchor" href="#小柴带你学autosar系列三-标准和规范篇4rte">#</a> 小柴带你学 AutoSar 系列三、标准和规范篇（4）RTE</h1><h1 id="1-introduction"><a class="anchor" href="#1-introduction">#</a> <strong>1 Introduction</strong></h1><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801140814168.png" alt="image-20240801140814168"></p><blockquote><p>This document contains the software specification of the AUTOSAR Run-Time Environment (<em>RTE</em>) and the <em>Basic Software Scheduler</em>. Basically, the RTE together with the OS, AUTOSAR COM and other Basic Software Modules is the implementation of the Virtual Functional Bus concepts (<em>VFB</em>, [1]). The RTE implements the AUTOSAR Virtual Functional Bus interfaces and thereby realizes the communication between AUTOSAR software-components.</p></blockquote><p>RTE 是通信的接口</p><blockquote><p>This document describes how these concepts are realized within the RTE. Further more, the Application Programming Interface (<em>API</em>) of the RTE and the interaction of the RTE with other basic software modules is specified.</p><p>The <em>Basic Software Scheduler</em> offers concepts and services to integrate Basic Software Modules Hence, the <em>Basic Software Scheduler</em></p><ul><li>embed <em>Basic Software Module</em> implementations into the AUTOSAR OS context</li><li>trigger main processing functions of the <em>Basic Software Module</em>s</li><li>apply data consistency mechanisms for the <em>Basic Software Module</em>s</li><li>to communicate modes between <em>Basic Software Module</em>s</li></ul></blockquote><p>在 OS 中嵌入基础软件</p><p>触发主处理函数</p><p>数据一致性的机制</p><p>基础软件之间的通信模式</p><h1 id="2-rte-overview"><a class="anchor" href="#2-rte-overview">#</a> <strong>2 RTE Overview</strong></h1><h2 id="21-the-rte-in-the-context-of-autosar"><a class="anchor" href="#21-the-rte-in-the-context-of-autosar">#</a> 2.1 The RTE in the Context of AUTOSAR</h2><blockquote><p>In principle the RTE can be logically divided into two sub-parts realizing:</p><ul><li>the communication between software components</li><li>the scheduling of the software components</li></ul></blockquote><p>软件组件的通信</p><p>软件组件的调度</p><h2 id="22-autosar-concepts"><a class="anchor" href="#22-autosar-concepts">#</a> <strong>2.2</strong> AUTOSAR Concepts</h2><h3 id="221-autosar-software-components"><a class="anchor" href="#221-autosar-software-components">#</a> <strong>2.2.1</strong> AUTOSAR Software-components</h3><blockquote><p>In AUTOSAR, “application” software is conceptually located above the AUTOSAR RTE and consists of “AUTOSAR application software-components” that are ECU and location independent and “AUTOSAR sensor-actuator components” that are dependent on ECU hardware and thus not readily relocatable for reasons of performance/efficiency.</p><p>This means that, subject to constraints imposed by the system designer, an AUTOSAR software-component can be deployed to any available ECU during system configuration. The RTE is then responsible for ensuring that components can communicate and that the system continues to function as expected wherever the components are deployed.</p></blockquote><p>也就是说为了解耦，软件组件可以部署到任意位置，耦合的地方由 RTE 实现通信 / 调度。</p><h3 id="222-basic-software-modules"><a class="anchor" href="#222-basic-software-modules">#</a> <strong>2.2.2</strong> Basic Software Modules</h3><blockquote><p>As well as “AUTOSAR software-components” an AUTOSAR ECU includes basic software modules. Basic software modules can access the ECU abstraction layer as well as other basic software modules directly and are thus neither ECU nor location independent.</p></blockquote><p>BSW 可以访问 ECU 抽象以及其他模块的硬件抽象。</p><blockquote><p>An “AUTOSAR software-component” <em>cannot</em> directly access basic software modules – all communication is via AUTOSAR interfaces and therefore under the control of the RTE. The requirement to not have direct access applies to all <em>Basic Software Modules</em> including the operating system [SRS_Rte_00020] and the communication service.</p></blockquote><p>SWC 不可以直接访问 BSW，需要通过 RTE</p><h3 id="223-communication"><a class="anchor" href="#223-communication">#</a> <strong>2.2.3</strong> Communication</h3><p>通信是通过 port 来进行的，具体请看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83MDk5OTU4NTE=">二、VFB 虚拟功能总线</span></p><blockquote><p>The RTE provides different paradigms for the communication between software component instances: sender-receiver (signal passing), client-server (function invocation), mode switch, and NvBlockSwComponentType interaction.</p></blockquote><h4 id="支持的通信方式"><a class="anchor" href="#支持的通信方式">#</a> 支持的通信方式</h4><ul><li>sender-receiver (signal passing)</li><li>client-server (function invocation)</li><li>mode switch</li><li>NvBlockSwComponentType interaction</li></ul><h4 id="communication-paradigms"><a class="anchor" href="#communication-paradigms">#</a> <strong>Communication Paradigms</strong></h4><blockquote><p>Inter-Partition communication occurs between runnable entities in components mapped to different partitions of the same ECU and therefore involve a context switch and crossing a protection boundary (memory protection, timing protection, isolation on a core). Inter-ECU communication occurs between runnable entities in components that have been mapped to different ECUs and so is inherently concurrent and involves potentially unreliable communication.</p></blockquote><p>要作到可靠的通信会涉及几个问题</p><ul><li>memory protection</li><li>timing protection</li><li>isolation on a core</li></ul><h4 id="communication-modes"><a class="anchor" href="#communication-modes">#</a> <strong>Communication Modes</strong></h4><blockquote><p>The RTE supports two modes for sender-receiver communication:</p><ul><li><strong>Explicit</strong> — A component uses explicit RTE API calls to send and receive data elements [SRS_Rte_00098].</li><li><strong>Implicit</strong> — The RTE automatically reads a specified set of data elements before a runnable is invoked and automatically writes (a different) set of data elements after the runnable entity has terminated [SRS_Rte_00128] [SRS_Rte_00129]. The term “implicit” is used here since the runnable does not actively initiate the reception or transmission of data.</li></ul></blockquote><p>分两种一种显式、一种隐式。</p><p>显式就是由 API<strong> 主动调用</strong>的发送或接收数据</p><p>隐式就是类似<strong>回调函数</strong>这样被自动调用的发送或接收数据</p><h4 id="static-communication"><a class="anchor" href="#static-communication">#</a> <strong>Static Communication</strong></h4><p>预先配置的通信链路</p><h4 id="multiplicity"><a class="anchor" href="#multiplicity">#</a> <strong>Multiplicity</strong></h4><ul><li>sender-receiver communication<ul><li>支持 1:n</li><li>支持 n:1</li></ul></li><li>client-server communications<ul><li>仅支持 n:1</li></ul></li></ul><h3 id="224-concurrency"><a class="anchor" href="#224-concurrency">#</a> <strong>2.2.4</strong> Concurrency</h3><p>并发</p><h2 id="23-the-rte-generator"><a class="anchor" href="#23-the-rte-generator">#</a> <strong>2.3</strong> The RTE Generator</h2><blockquote><p>The RTE generator is one of a set of tools5 that create the realization of the AUTOSAR virtual function bus for an ECU based on information in the ECU Configuration Description. The RTE Generator is responsible for creating the AUTOSAR software component API functions that link AUTOSAR software-components to the OS and manage communication between AUTOSAR software-components and between AUTOSAR software-components and basic software modules.</p></blockquote><p>RTE 生成器是创建 VFB 的工具，负责上下层的交互</p><h2 id="24-design-decisions"><a class="anchor" href="#24-design-decisions">#</a> <strong>2.4</strong> Design Decisions</h2><h1 id="3-rte-generation-process"><a class="anchor" href="#3-rte-generation-process">#</a> <strong>3 RTE Generation Process</strong></h1><blockquote><p>The RTE Generator is used in different roles for the following phases:</p><ul><li>RTE Contract Phase</li><li>Basic Software Scheduler Contract Phase</li><li>PreBuild Data Set Contract Phase</li><li>Basic Software Scheduler Generation Phase</li><li>RTE Generation Phase</li><li>PreBuild Data Set Generation Phase</li><li>PostBuild Data Set Generation Phase</li></ul></blockquote><h2 id="rte-generator-for-software-components"><a class="anchor" href="#rte-generator-for-software-components">#</a> <strong>RTE Generator for Software-Components</strong></h2><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20241101233232600.png" alt="image-20241101233232600"></p><p>很显然</p><ul><li>先描述 ECU</li><li>然后通过配置工具配置，接着生成代码</li><li>最后编译为可执行文件</li></ul><p>下面是一些 log 信息</p><p>The following list is a collection of proposed information items in particular applicable</p><p>to log files used for exchanging information about errors.</p><ul><li><strong>ErrorCode</strong> – A symbolic name for the message text</li><li><strong>StandardErrorCode</strong> – The reference to the AUTOSAR error code</li><li><strong>ConstraintCode</strong> – Reference to the semantic constraint mentioned in the AUTOSAR template specification.</li><li><strong>Signature</strong> – Signature of the message for duplicate checks</li><li><strong>Timestamp</strong> – A time stamp for the message</li><li><strong>ShortName</strong> – A unique identification which allows to refer to particular error messages This can also be used to establish references between error messages, e.g. for screening and also to trace back to root cause</li><li><strong>Desc</strong> – The human readable message text</li><li><strong>Component</strong> – Such information item may help the user to locate the problem in the model</li><li><strong>BaseUrl</strong> – An url for a base directory which can be used as basis for file references in a log file. This is typically the root direactory of a project structure.</li><li><strong>ColumNumber</strong> – The column of the error position</li><li><strong>LineNumber</strong> – The line number of the error position</li><li><strong>LongName</strong> – The title of the error message</li><li><strong>ObjectCategory</strong> – The category of for example the involved ApplicationPrimitve DataType (e.g.VALUE)</li><li><strong>PrimaryErrorReference</strong> – Reference to the root cause if applicable</li><li><strong>ScopeEntryReference</strong> – Reference to a scoping message if applicable</li><li><strong>Object</strong> – The shortName based reference to the AUTOSAR element which caused the error</li><li><strong>ToolName</strong> – The name of the tool which reported the error</li><li><strong>ToolVersion</strong> – The version of the tools which reported the error</li><li><strong>IncidentUrl</strong> – The Url which refers to the artifact in which the error occurs</li><li><strong>Value</strong> – The actual found value which caused the problem</li></ul><h2 id="rte-generator-for-basic-software-scheduler"><a class="anchor" href="#rte-generator-for-basic-software-scheduler">#</a> <strong>RTE Generator for Basic Software Scheduler</strong></h2><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240731162912897.png" alt="image-20240731162912897"></p><ul><li><strong>Contract Phase</strong><ul><li><strong>RTE Contract Phase</strong></li><li><strong>Basic Software Scheduler Contract Phase</strong></li></ul></li><li><strong>PreBuild Data Set Contract Phase</strong></li><li><strong>Edit ECU Configuration of the RTE</strong></li><li><strong>Generation Phase</strong><ul><li><strong>Basic Software Scheduler Generation Phase</strong></li><li><strong>RTE Generation Phase</strong></li><li><strong>Cluster Generation Phase</strong></li><li><strong>Basic Software Module Description generation</strong><ul><li><strong>Bsw Module Description</strong></li><li><strong>Bsw Internal Behavior</strong></li><li><strong>Bsw Implementation</strong></li></ul></li><li><strong>Com and LdCom usage</strong><ul><li><strong>Com user generation</strong></li><li><strong>LdCom user generation</strong></li></ul></li></ul></li><li><strong>PreBuild Data Set Generation Phase</strong></li><li><strong>PostBuild Data Set Generation Phase</strong></li><li><strong>RTE Configuration interaction with other BSW Modules</strong><ul><li>The generated RTE interacts heavily with other AUTOSAR Basic Software Modules like Com, LdCom and Os. 会和这三个模块有大量的交互</li></ul></li></ul><p>规范这块感觉有点过于细节了</p><p>我是没耐心看完哈哈哈</p><p>可能只有做 RTE 生成的工具需要仔细研究</p><p>小柴就偷个懒吧</p><h1 id="4-rte-functional-specification"><a class="anchor" href="#4-rte-functional-specification">#</a> <strong>4 RTE Functional Specification</strong></h1><h2 id="41-architectural-concepts"><a class="anchor" href="#41-architectural-concepts">#</a> <strong>4.1</strong> Architectural concepts</h2><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801140814168.png" alt="image-20240801140814168"></p><p><strong>RTE and Data Types</strong></p><p><strong>RTE and AUTOSAR Software-Components</strong></p><blockquote><p>The description of an AUTOSAR software-component is divided into the sections</p><ul><li>hierarchical structure</li><li>ports and interfaces</li><li>internal behavior</li><li>implementation</li></ul></blockquote><p>AUTOSAR 的组件描述分为一下几个</p><ul><li>层次结构</li><li>端口和接口</li><li>内部行为</li><li>实现</li></ul><h2 id="42-rte-and-basic-software-scheduler-implementation-aspects"><a class="anchor" href="#42-rte-and-basic-software-scheduler-implementation-aspects">#</a> <strong>4.2</strong> RTE and Basic Software Scheduler Implementation Aspects</h2><blockquote><p>This section describes some specific implementation aspects of an AUTOSAR RTE and the Basic Software Scheduler. It will mainly address</p><ul><li>the mapping of logical concepts (e.g., Runnable Entities, BSW Schedulable Entities) to technical architectures (namely, the AUTOSAR OS)</li><li>the decoupling of pending interrupts (in the Basic Software) and the notification of AUTOSAR software components</li><li>data consistency problems to be solved by the RTE</li></ul></blockquote><p>支持这种链式的 task</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801144825065.png" alt="image-20240801144825065"></p><p>RTE 事件类型</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801145237116.png" alt="image-20240801145237116"></p><blockquote><p>According to the meta model each kind of RTEEvent can either</p><p><strong>ACT</strong> activate a RunnableEntity, or</p><p><strong>WUP</strong> wakeup a RunnableEntity at its WaitPoints</p></blockquote><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801145505813.png" alt="image-20240801145505813"></p><h3 id="这里task有几种不同的触发方式"><a class="anchor" href="#这里task有几种不同的触发方式">#</a> 这里 task 有几种不同的触发方式</h3><h4 id="without-osevent"><a class="anchor" href="#without-osevent">#</a> <strong>Without</strong> <strong>OsEvent</strong></h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskA</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">RE1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">RE3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskB</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">RE2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h4 id="with-osevent"><a class="anchor" href="#with-osevent">#</a> <strong>With</strong> <strong>OsEvent</strong></h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskA</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    EventMaskType Event<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">WaitEvent</span><span class="token punctuation">(</span>EvtA <span class="token operator">|</span> EvtB <span class="token operator">|</span> EvtC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">GetEvent</span><span class="token punctuation">(</span>TaskA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Event<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtB<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtC<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskD<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskB</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token function">RE1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskC</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token function">RE2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskD</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token function">RE3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h4 id="monitoring-of-group-of-runnables"><a class="anchor" href="#monitoring-of-group-of-runnables">#</a> <strong>Monitoring of group of runnables</strong></h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskA</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    EventMaskType Event<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">WaitEvent</span><span class="token punctuation">(</span>EvtA <span class="token operator">|</span> EvtB <span class="token operator">|</span> EvtC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">GetEvent</span><span class="token punctuation">(</span>TaskA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Event<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">RE1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtB<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token function">RE4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Event <span class="token operator">&amp;</span> EvtC<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token function">ClearEvent</span><span class="token punctuation">(</span>EvtC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token function">RE5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token function">ActivateTask</span><span class="token punctuation">(</span>TaskC<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskB</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token function">RE2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token function">RE3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token keyword">void</span> <span class="token function">TaskC</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token function">RE6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token function">RE7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h3 id="状态机制"><a class="anchor" href="#状态机制">#</a> 状态机制</h3><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801153626566.png" alt="image-20240801153626566"></p><p>一个任务的执行周期例子</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801154048073.png" alt="image-20240801154048073"></p><h3 id="425-interrupt-decoupling-and-notifications"><a class="anchor" href="#425-interrupt-decoupling-and-notifications">#</a> <strong>4.2.5</strong> Interrupt decoupling and notifications</h3><blockquote><p>Several of these BSW functionalities create situations, signalled by an interrupt, when AUTOSAR SW-Cs have to be involved. To inform AUTOSAR software components of those situations, runnables in AUTOSAR software components are activated by notifications. So interrupts that occur in the basic software have to be transformed into notifications of the AUTOSAR software components. Such a transformation has to take place at RTE level <strong>at the latest</strong>! Which interrupt is connected to which notification is decided either during system configuration/generation time or as part of the design of Complex Device Drivers or the Microcontroller Abstraction Layer.</p></blockquote><p>也就是说，中断的向上提醒要在 RTE 里实现（就是要在 RTE 里通知 SWC 哎不对啊，不是说上下啥都要通过 RTE 吗？那这句是废话了 ）</p><p>P174 页介绍了一堆配置参数</p><h3 id="426-data-consistency"><a class="anchor" href="#426-data-consistency">#</a> <strong>4.2.6</strong> Data Consistency</h3><p><strong>任务切换会导致数据一致性问题的发生</strong>【<strong>这块还挺重要的💮</strong>】</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801160250193.png" alt="image-20240801160250193"></p><p><strong>避免这一问题有一下机制</strong></p><blockquote><ul><li><strong>Sequential scheduling strategy</strong><ul><li><strong>顺序调度机制</strong></li><li>The activation code of Runnables is sequentially placed in one task/ISR2 so that no interference between them is possible because one Runnable is only activated after the termination of the other. Data consistency is guaranteed.</li></ul></li></ul><ul><li><p><strong>Interrupt blocking strategy</strong></p><ul><li><strong>中断阻塞机制</strong></li><li>Interrupt blocking can be an appropriate means if collision avoidance is required for a very short amount of time. This might be done by disabling respectively suspending all interrupts, Os interrupts only or - if hardware supports it - only of some interrupt levels. In general this mechanism must be applied with care because it might influence SW in tasks with higher priority too and the timing of the complete system.</li></ul></li><li><p><strong>Usage of OS resources</strong></p><ul><li><strong>使用 OS resources</strong></li><li>Usage of OS resources. Advantage in comparison to Interrupt blocking strategy is that less SW parts with higher priority are blocked. Disadvantage is that implementation might consume more resources (code, runtime) due to the more sophisticated mechanism. Appropriateness of this mechanism may vary depending on the number of OSs/cores and/or the number of available resources.</li></ul></li></ul><ul><li><strong>Task blocking strategy</strong><ul><li><strong>Task 阻塞策略</strong></li><li>Task task preemption is prohibited. This might be reached e.g. by assigning same priorities to affected tasks, by assigning same internal OS resource to affected tasks or by configuring the tasks to be non-preemptive. This mechanismmay be inappropriate in multi-partitioned systems.</li></ul></li></ul><ul><li><strong>Copy strategy</strong><ul><li><strong>拷贝策略</strong></li><li>Idea: The RTE creates copies of data items so that concurrent accesses in different task/ISR2 contexts cannot collide because some of the accesses are redirected to the copies.</li><li>How it can work:<ul><li>Application for <strong>read</strong> <em>conflicts</em>:</li><li>For all readers with lower priority than the writer a <em>read copy</em> is provided.</li><li>Example:</li><li>There exist Runnable R1, Runnable R2, data item X and a copy data item X. When Runnable R1 is running in higher priority task context than R2, and R1 is the only one writing X and R2 is reading X it is possible to guarantee data consistency by making a copy of data item X to variable X before activation of R2 and redirecting write access from X to X* or the read access from X to X for R2.</li><li>Application for <strong>write</strong> <em>conflicts</em>:<ul><li>If one or more data item receiver with a higher priority than the sender exist, a <em>write copy</em> for the sender is provided.</li><li>Example:</li><li>There exist Runnable R1, Runnable R2, data item X and copy data item X.When Runnable R1 (running in lower priority task context than R2) is writing X and R2 is reading X, it is possible to guarantee data consistency by making a copy of data item X to data item X <strong>before</strong> activation of R1 together with redirecting the write access from X to X* for R1 or the read access from X to X* for R2.</li></ul></li></ul></li><li>Usage of this copy mechanism may make sense if one or more of the following conditions hold:<ul><li>This copy mechanism can handle those cases when only one instance does the data write access.</li><li>R2 is accessing X several times.</li><li>More than one Runnable R2 has read (resp. write) access to X.</li><li>To save runtime is more important than to save code and RAM.</li><li>Additional RAM requirements to hold the copies is acceptable.</li></ul></li><li>Further issues to be taken into account:<ul><li>AUTOSAR SW-Cs provided as source code and AUTOSAR SW-Cs provided as object code may or have to be handled in different ways. The redirecting mechanism for source code could use macros for C and C++ very efficiently whereas object-code AUTOSAR SW-Cs most likely are forced to use references.</li></ul></li></ul></li></ul></blockquote><p><strong>Assignment of data consistency mechanisms</strong></p><p>可以在 RTE 中配置如下几种不同的机制</p><blockquote><p>Actually following values for configuration parameter RteExclusiveAreaImplMechanism must be supported:</p><ul><li>ALL_INTERRUPT_BLOCKING</li></ul><p>This value requests enabling and disabling of all Interrupts and is based on the</p><p><em>Interrupt blocking strategy</em>.</p><ul><li>OS_INTERRUPT_BLOCKING</li></ul><p>This value requests enabling and disabling of Os Interrupts and is based on the</p><p><em>Interrupt blocking strategy</em>.</p><ul><li>OS_RESOURCE</li></ul><p>This value requests to apply the <em>Usage of OS resources</em> mechanism.</p><ul><li>OS_SPINLOCK</li></ul><p>This value is used to co-ordinate concurrent access by TASKs/ISR2s on different</p><p>cores to a shared resource.</p><ul><li>NONE</li></ul><p>RTE generator shall not apply any mechanisms for data consistency. Data con</p><p>sistency will be ensured by methods outside of RTE implementation control.</p><ul><li>RTE_PLUGIN</li></ul><p>This value requests to apply the RTE Implementation Plug-In mechanism.</p></blockquote><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240801170445357.png" alt="image-20240801170445357"></p><h2 id="43-communication-paradigms"><a class="anchor" href="#43-communication-paradigms">#</a> <strong>4.3</strong> Communication Paradigms</h2><blockquote><p>AUTOSAR supports two basic communication paradigms: Client-Server and Sender Receiver. AUTOSAR software-components communicate through well defined ports and the behavior is statically defined by attributes.</p></blockquote><p>AUTOSAR 有两种通信模式</p><ul><li>Client-Server</li><li>Sender Receiver</li></ul><blockquote><p>The RTE provides the implementation of these communication paradigms. For inter ECU communication the RTE uses the functionalities provided by COM. For inter Partition communication (within the same ECU) the RTE may use functionalities provided by the IOC module. For intra-Partition the RTE provides the functionality on its own.</p></blockquote><p>对于 ECU 间的通信采用 COM 模块提供的功能</p><p>对应分区间的通信采用 IOC 模块的功能实现</p><blockquote><p>With Sender-Receiver communication there are two main principles: Data Distribution and Event Distribution.</p></blockquote><p>对于 Sender Receiver 有两个原则</p><ul><li>数据分发</li><li>事件分发</li></ul><h3 id="431-sender-receiver"><a class="anchor" href="#431-sender-receiver">#</a> <strong>4.3.1</strong> Sender-Receiver</h3><p><strong>Receive Modes</strong></p><blockquote><p>The RTE supports multiple receive modes for passing data to receivers. The four possible receive modes are:</p><ul><li><strong>Implicit data read access</strong><ul><li>when the receiver’s runnable executes it shall have access to a “copy” of the data that remains unchanged during the execution of the runnable.</li><li>当接收器的 runnable 执行时，它应有权访问在 runnable 执行期间保持不变的数据的副本</li></ul></li><li><strong>Explicit data read access</strong><ul><li>the RTE generator creates a non-blocking API call to enable a receiver to poll (and read) data. This receive mode is an “explicit” mode since an explicit API call is invoked by the receiver.</li><li>RTE 生成器创建非阻塞 API 调用以使接收器能够 poll (和读取) 数据。此接收模式为 “显示模式，因为接收器调用了显式 API 调用。</li></ul></li><li><strong>wake up of wait point</strong><ul><li>the RTE generator creates a blocking API call that the receiver invokes to read data.</li><li>RTE 生成器创建一个阻塞 API 调用，接收器调用该 API 调用来读取数据。</li></ul></li><li><strong>activation of runnable entity</strong><ul><li>the receiving runnable entity is invoked automatically by the RTE whenever new data is available. To access the new data, the runnable entity either has to use “implicit data read access” or “explicit data read access”, i.e. invoke an Rte_IRead, Rte_Read, Rte_DRead or Rte_Receive call, depending on the input configuration. This receive mode differs from “implicit data read access” since the receiver is invoked by the RTE in response to a DataReceivedEvent.</li><li>只要有新数据可用，RTE 就会自动调用接收的可运行实体。</li></ul></li></ul></blockquote><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829150512271.png" alt="image-20240829150512271"></p><p>涉及到一些方面</p><p><strong>Receive Modes</strong></p><p><strong>Multiple Data Elements</strong></p><p><strong>Multiple Receivers and Senders</strong></p><p><strong>Implicit and Explicit Data Reception and Transmission</strong></p><p><strong>Transmission Acknowledgement</strong></p><p><strong>Communication Time-out</strong></p><p><strong>Data Element Invalidation</strong></p><p><strong>Filters</strong></p><p><strong>Buffering</strong></p><p><strong>Operation</strong></p><p><strong>“Never received status” for Data Element</strong></p><p><strong>“Update flag” for Data Element</strong></p><p><strong>Dynamic data type</strong></p><p><strong>Inter-ECU communication through TP</strong></p><p><strong>Inter-ECU communication of arrays of bytes</strong></p><p><strong>Handling of acknowledgment events</strong></p><p><strong>Meta data for application</strong></p><h3 id="432-client-server"><a class="anchor" href="#432-client-server">#</a> <strong>4.3.2</strong> Client-Server</h3><p><strong>Multiplicity</strong></p><blockquote><p>Client-server interfaces contain two dimensions of multiplicity; multiple clients invoking a single server and multiple operations within a client-server interface.</p></blockquote><p>客户端 - 服务器接口包含两个多维度：多个客户端调用单个服务器以及客户端 - 服务器界面内的多个操作。</p><p><strong>Communication Time-out</strong></p><p><strong>Port-Defined argument values</strong></p><p><strong>Buffering</strong></p><blockquote><p>The buffering mechanisms described here also apply to the serialization of server calls in the Basic Software Scheduler.</p></blockquote><p>这里描述的缓冲机制也适用于基本软件调度程序中的服务器调用的序列化。</p><p>也就是对调用的指令进行缓冲，可以同时发送多条指令，服务器这边逐一执行</p><p><strong>Inter-ECU and Inter-Partition Response to Request Mapping</strong></p><p><strong>Client Identifier</strong></p><p><strong>SequenceCounter</strong></p><p><strong>Inter-ECU Response Channel Fan-Out</strong></p><p><strong>Parameter Serialization</strong></p><h3 id="433-swc-internal-communication"><a class="anchor" href="#433-swc-internal-communication">#</a> <strong>4.3.3</strong> SWC internal communication</h3><p><strong>Inter Runnable Variables</strong></p><blockquote><p>Sender/Receiver and Client/Server communication through AUTOSAR ports are</p><p>the model for communication between AUTOSAR SW-Cs.</p></blockquote><p>通过 AUTOSAR 端口的发送 / 接收和客户端 / 服务器通信是 AUTOSAR SW-C 之间的通信模型</p><blockquote><p>For communication between Runnables inside of an AUTOSAR SW-C the AUTOSAR SW-C Template [2] establishes a separate mechanism.</p></blockquote><p>对于 AUTOSAR SW-C 内部的可运行程序之间的通信，AUTOSAR SW-C 模板 [2] 建立一个单独的机制。</p><blockquote><p>But why not use Sender/Receiver communication directly instead? Purpose is data encapsulation / data hiding.</p></blockquote><p>但是为什么不直接使用 Sender/Receiver 通信呢？目的是数据封装 / 数据隐藏。</p><h3 id="434-inter-partition-communication"><a class="anchor" href="#434-inter-partition-communication">#</a> <strong>4.3.4</strong> Inter-Partition communication</h3><blockquote><p>Partitions are used to decompose an ECU into functional units. Partitions can contain both SW-Cs and BSW modules.</p></blockquote><p>分区用于将 ECU 分解为功能单元。分区可以包含 SW-C 模块和 BSW 模块。</p><blockquote><p>The partitioning is done to protect the software contained in the partitions against each other or to increase the performance by running the partitions on different cores of a multi core controller.</p></blockquote><p>进行分区是为了保护分区中包含的软件相互保护，或者通过在多核控制器的不同核心上运行分区来提高性能。</p><p><strong>Inter partition data communication using IOC</strong></p><blockquote><p>The IOC (Inter OS-Application Communication) is a feature of the AUTOSAR OS, which provides a data oriented communication mechanism between partitions.</p></blockquote><p>IOC (Inter OS-Application Communication) 是 AUTOSAROS 的一个特性，它提供了一个面向数据的分区之间的通信机制。</p><blockquote><p>The IOC provides communication buffers, queues, and protected access functions/macros to these buffers that can be used from any pre-configured partitions concurrently.</p></blockquote><p>IOC 为这些缓冲区提供通信缓冲区、队列和受保护的访问函数 / 宏，这些缓冲区内可以同时从任何预先配置的分区使用。</p><blockquote><p>The IOC offers communication of data to another core or between memory protected partitions with guarantee of data consistency.</p></blockquote><p>IOC 提供数据到另一个核心或内存保护分区之间的通信，保证数据的一致性。</p><p><strong>Inter partition data communication using Basic Software Scheduler</strong></p><blockquote><p>The Basic Software Scheduler provides Sender-Receiver and Client-Server communications mechanisms for communication between Basic Software Modules in different partitions.</p></blockquote><p>基本软件调度器提供发送 - 接收和客户端 - 服务器通信机制，用于在不同分区的基本软件模块之间的通信。</p><blockquote><p>Therefore these communication paradigms can be used by Basic Software Modules in a multi core environment.</p></blockquote><p>因此，这些通信范例可以被基本软件模块在多核心环境中使用。</p><p><strong>Accessing (Ld)Com and Det in multicore/multipartition configuration</strong></p><p><strong>Accessing NvM in multicore/multipartition configurations</strong></p><p><strong>Signaling and control flow support for inter partition communication</strong></p><blockquote><p>The OS representation of a partition is an OS Application.</p><p>This is a (non-exhaustive) summary of OS features that can be used for signaling and control flow across partition boundaries:</p></blockquote><p>这是一个 (非详尽的) 操作系统功能概述，这些功能可用于跨分区边界的信令和控制流:</p><blockquote><ul><li>activation of tasks</li><li>start and stop of schedule tables</li><li>event signaling</li><li>alarms</li><li>spin locks (for inter core synchronization)</li></ul><p>The following are not available for inter core signaling:</p><ul><li>OS Resource</li><li>DisableAllInterrupts</li></ul><p>For inter core synchronization, spin locks are provided. But, for efficiency reasons they should be used with care.</p></blockquote><p>为了实现核心间同步，提供了自旋锁，但出于效率考虑，应谨慎使用。</p><p><strong>Trusted Functions</strong></p><p><strong>Memory Protection and Pointer Type Parameters in RTE API</strong></p><h3 id="435-portinterface-element-mapping-and-data-conversion"><a class="anchor" href="#435-portinterface-element-mapping-and-data-conversion">#</a> <strong>4.3.5</strong> PortInterface Element Mapping and Data Conversion</h3><h3 id="436-network-representation"><a class="anchor" href="#436-network-representation">#</a> <strong>4.3.6</strong> Network Representation</h3><p><strong>Network Representation with no data transformation</strong></p><p><strong>Network Representation with data transformation</strong></p><h3 id="437-data-conversion"><a class="anchor" href="#437-data-conversion">#</a> <strong>4.3.7</strong> Data Conversion</h3><h3 id="438-range-checks-during-runtime"><a class="anchor" href="#438-range-checks-during-runtime">#</a> <strong>4.3.8</strong> Range Checks during Runtime</h3><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829160808040.png" alt="image-20240829160808040"></p><h2 id="44-modes"><a class="anchor" href="#44-modes">#</a> <strong>4.4</strong> Modes</h2><h3 id="441-mode-user"><a class="anchor" href="#441-mode-user">#</a> <strong>4.4.1</strong> Mode User</h3><blockquote><p>The ModeDeclarations can be used in two ways by the mode user</p><ul><li>Modes can be used to trigger runnables</li><li>An RTEEvent or BswEvent that starts an ExecutableEntity can contain a mode disabling dependency.</li></ul></blockquote><h3 id="442-mode-manager"><a class="anchor" href="#442-mode-manager">#</a> <strong>4.4.2</strong> Mode Manager</h3><blockquote><p>Entering and leaving modes is initiated by a mode manager.</p></blockquote><p>进入和离开模式由模式管理器启动。</p><blockquote><p>A mode manager might be a basic software module, for example the Basic Software Mode Manager (BswM), the communication manager (ComM), or the ECU state manager (EcuM).</p></blockquote><p>模式管理器可以是基本软件模块，例如基本软件模式管理器 (BSWM)、通信管理器 (ComM) 或 ECU 状态管理器 (EcuM)。</p><blockquote><p>The modemanager may also be an AUTOSAR SW-C. In this case, it is called an application mode manager.</p></blockquote><p>模式管理器也可以是 AUTOSAR SW-C。在这种情况下，它被称为应用程序模式管理器。</p><h3 id="443-refinement-of-the-semantics-of-modedeclarations-and-mode"><a class="anchor" href="#443-refinement-of-the-semantics-of-modedeclarations-and-mode">#</a> <strong>4.4.3</strong> Refinement of the semantics of ModeDeclarations and <strong>Mode</strong></h3><p><strong>DeclarationGroups</strong></p><h3 id="444-order-of-actions-taken-by-the-rte-basic-software-scheduler-upon-inter"><a class="anchor" href="#444-order-of-actions-taken-by-the-rte-basic-software-scheduler-upon-inter">#</a> <strong>4.4.4</strong> Order of actions taken by the RTE / Basic Software Scheduler <strong>upon inter</strong></h3><p><strong>ception of a mode switch notification</strong></p><p><strong>synchronous</strong> 同步</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829161635073.png" alt="image-20240829161635073"></p><p><strong>asynchronous</strong> 异步</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240829161733205.png" alt="image-20240829161733205"></p><p><strong>Assignment of mode machine instances to RTE and Basic Software Scheduler</strong></p><p><strong>Initialization of mode machine instances</strong></p><p><strong>Notification of mode switches</strong></p><p><strong>Mode switch acknowledgment</strong></p><p><strong>Mapping of ModeDeclarations</strong></p><p><strong>Distributed Shared Mode Queues</strong></p><h2 id="45-external-and-internal-trigger"><a class="anchor" href="#45-external-and-internal-trigger">#</a> <strong>4.5</strong> External and Internal Trigger</h2><ul><li><strong>External Trigger Event Communication</strong></li><li><strong>Trigger Source</strong></li><li><strong>Multiplicity</strong><ul><li><strong>Multiple Trigger</strong></li><li><strong>Multiple Trigger Sinks Single Trigger Source</strong></li><li><strong>Multiple Trigger Sources Single Trigger Sink</strong></li></ul></li><li><strong>Synchronized Trigger</strong></li></ul><p><strong>Inter Runnable Triggering</strong></p><ul><li><strong>Multiplicity</strong></li></ul><p><strong>Inter Basic Software Module Entity Triggering</strong></p><p><strong>Inter ECU Trigger Communication</strong></p><p><strong>Queuing of Triggers</strong></p><p><strong>Activation of triggered ExecutableEntities</strong></p><h2 id="46-initialization-and-finalization"><a class="anchor" href="#46-initialization-and-finalization">#</a> <strong>4.6</strong> Initialization and Finalization</h2><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240902163033649.png" alt="image-20240902163033649"></p><p><strong>Initialization of the RTE</strong></p><p><strong>Finalization of the RTE</strong></p><p><strong>Finalization of the</strong> <strong>Basic Software Scheduler</strong></p><p><strong>Initialization and Finalization of AUTOSAR Software-Components</strong></p><h2 id="47-variant-handling-support"><a class="anchor" href="#47-variant-handling-support">#</a> <strong>4.7</strong> Variant Handling Support</h2><h3 id="471-overview"><a class="anchor" href="#471-overview">#</a> <strong>4.7.1</strong> Overview</h3><blockquote><p>The <em>AUTOSAR Template</em>s support the creation of <em>Variant</em>s in a subset of its model elements. The <em>Variant Handling</em> support in the in <em>AUTOSAR Template</em>s is driven by the purpose to describe variability in a <em>AUTOSAR System</em> on several aspects, e.g.</p></blockquote><p>AUTOSAR 模板支持在其模型元素子集中创建变体。AUTOSAR 模板中的变体处理支持旨在从多个方面描述 AUTOSAR 系统中的可变性，例如:</p><blockquote><ul><li>Virtual Functional Bus</li><li>Component SwcInternalBehavior and SwcImplementation</li><li>Deployment of the software components to ECUs</li><li>Communication Matrix</li><li>Basic Software Modules</li></ul></blockquote><p>虚拟功能总线<br>组件外部行为和功能<br>将软件组件部署到 ECU<br>通信矩阵<br>基本软件模块</p><blockquote><p>This approach requires that the RTE Generator is able to process the described Variability in input configurations and partially to implement described variability in the generated RTE and Basic Software Scheduler code.</p></blockquote><p>这种方法要求 RTE 生成器能够处理输入配置中描述的变量，并在生成的 RTE 和基本软件调度器代码中部分实现所描述的变量。</p><h3 id="472-choosing-a-variant-and-binding-variability"><a class="anchor" href="#472-choosing-a-variant-and-binding-variability">#</a> 4.7.2 Choosing a Variant and Binding Variability</h3><p><strong>General impact of Binding Times on RTE generation</strong></p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905103227817.png" alt="image-20240905103227817"></p><blockquote><p>R resolve variability, a particular variant is the output</p><p>I implement variability, all possible variants in the output</p><p>RV provide values to resolve implemented variability <em>PreBuild</em> or <em>PostBuild</em></p><p>n/a not applicable</p></blockquote><p>绑定时间对 RTE 生成的影响</p><p><strong>Choosing a particular variant</strong></p><p><strong>SystemDesignTime</strong></p><p><strong>CodeGenerationTime</strong></p><p><strong>PreCompileTime</strong></p><p><strong>LinkTime</strong></p><h3 id="473-variability-affecting-the-rte-generation"><a class="anchor" href="#473-variability-affecting-the-rte-generation">#</a> 4.7.3 Variability affecting the RTE generation</h3><p><strong>Software Composition</strong></p><p><strong>Atomic Software Component and its Internal Behavior</strong></p><ul><li><strong>RTE API which is subject to variability</strong></li></ul><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114721400.png" alt="image-20240905114721400"></p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114737008.png" alt="image-20240905114737008"></p><ul><li><strong>Conditional API options</strong></li></ul><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114754389.png" alt="image-20240905114754389"></p><ul><li><strong>Runnable Entity’s and RTEEvents</strong></li></ul><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114848386.png" alt="image-20240905114848386"></p><ul><li><strong>Conditional Memory Allocation</strong></li></ul><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905114911511.png" alt="image-20240905114911511"></p><p><strong>NvBlockComponent and its Internal Behavior</strong></p><p><strong>Parameter Component</strong></p><p><strong>Basic Software Modules and its Internal Behavior</strong></p><p><strong>Flat Instance descriptor</strong></p><h3 id="474-variability-affecting-the-basic-software-scheduler-generation"><a class="anchor" href="#474-variability-affecting-the-basic-software-scheduler-generation">#</a> 4.7.4 Variability affecting the Basic Software Scheduler generation</h3><h2 id="48-development-error"><a class="anchor" href="#48-development-error">#</a> <strong>4.8</strong> Development error</h2><h2 id="49-bypass-support"><a class="anchor" href="#49-bypass-support">#</a> <strong>4.9</strong> Bypass Support</h2><p>旁路支持</p><blockquote><p>Rapid prototyping can be used during electronic control unit development to evaluate and test new software control algorithms for various functions.</p></blockquote><p>在电子控制单元开发过程中，可以使用快速原型来评估和测试适用于各种功能的新软件控制算法。</p><blockquote><p>With Fullpass technology the original ECU is totally replaced by a Rapid Prototyping Unit (RPU).</p></blockquote><p>采用 Fullpass 技术，原有的 ECU 完全被快速原型单元 (RPU) 所取代。</p><blockquote><p>With Bypass technology the original ECU and software stays in the control loop to supports the majority of the control algorithms and interface with sensors, actuators and communication buses: only the specific control algorithm that shall be prototyped is deported into the RPU (external bypass) or even directly executed in the original ECU (internal bypass).</p></blockquote><p>通过旁路技术，原始 ECU 和软件留在控制回路中，以支持大多数控制算法并与传感器致动器和通信总线接口：只有应进行原型设计的特定控制算法被发送到 RPU (外部旁路) 中，甚至直接在原始 ECU (内部旁路) 中执行。</p><blockquote><p>Bypass mainly consists in replacing at run time inputs and/or outputs of the original software algorithms by value computed by the prototype algorithm under test.</p></blockquote><p>绕过主要包括在运行时用被测试的原型算法计算的值替换原始软件算法的输入和 / 或输出。</p><blockquote><p>The RTE does not directly implement bypass but the RTE provides supports for the integration of such implementation by CDD and/or integration code.</p></blockquote><p>RTE 不直接实现绕过，但 RTE 支持通过 CDD 和 / 或集成代码实现此类实现。</p><h3 id="491-bypass-description"><a class="anchor" href="#491-bypass-description">#</a> <strong>4.9.1</strong> Bypass description</h3><h3 id="492-component-wrapper-method"><a class="anchor" href="#492-component-wrapper-method">#</a> <strong>4.9.2</strong> Component wrapper method</h3><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905135241264.png" alt="image-20240905135241264"></p><h3 id="493-direct-buffer-access-method"><a class="anchor" href="#493-direct-buffer-access-method">#</a> <strong>4.9.3</strong> Direct buffer access method</h3><blockquote><p>The direct buffer access method provides runtime direct read and write access to the RTE buffers that implement the ECU communication infrastructure.</p></blockquote><p>直接缓冲区访问方法提供对实现 ECU 通信基础设施的 RTE 缓冲区的运行时直接读写访问</p><h3 id="494-extended-buffer-access-method"><a class="anchor" href="#494-extended-buffer-access-method">#</a> <strong>4.9.4</strong> Extended buffer access method</h3><blockquote><p>The extended buffer access method enhances the support for rapid prototyping (RP) to support the bypass use case where the RTE cannot be regenerated by the bypass user.</p></blockquote><p>扩展缓冲区访问方法增强了对快速原型 (RP) 的支持，以支持旁路用户无法再生 RTE 的旁路用例。</p><blockquote><p>The goal is to ensure that all VariableDataPrototypes that are communicated via RTE APIs are written to and read back from a RP global buffer that can be modified by rapid prototyping tools (RPT).</p></blockquote><p>目标是确保所有通过 RTE ApI 通信的变量数据原型都写入并从 RP 全局缓冲区读回，该缓冲区可通过快速原型生成工具 (RPT) 进行修改。</p><blockquote><p>The method applies to all RTE APIs and not just those for implicit access and hence is termed the <em>extended</em> buffer access method.</p></blockquote><p>该方法适用于所有 RTE API，而不仅仅是用于隐式访问的 API，因此被称为扩展缓冲区访问方法。</p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905141458222.png" alt="image-20240905141458222"></p><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240905141637776.png" alt="image-20240905141637776"></p><h3 id="495-service-based-prototyping"><a class="anchor" href="#495-service-based-prototyping">#</a> <strong>4.9.5</strong> Service Based Prototyping</h3><blockquote><p>Access to the RP global buffers and RP global measurement buffers can be implemented by using a service based ECU interface in which an additional RP service component, such as an “XCP on CAN” or “XCP on Ethernet” service, is added to the ECU application.</p></blockquote><p>可以使用基于服务的 ECU 接口访问 RP 全局缓冲区和 RP 全局测量缓冲区，其中在 ECU 应用程序中添加了额外的 RP 服务组件，例如 “CAN 上的 XCP” 或 “以太网上的 XCP” 服务</p><blockquote><p>The integration of the service can be performed pre-build by means of source code based integration, for example, by adding an XCP or custom BSW component, or post-build by patching the binary code of an already compiled ECU image.</p></blockquote><p>服务集成可以通过源代码集成 (例如，通过添加 XCP 或自定义 BSW 组件) 进行预构建，也可以通过修补已经编译的 ECU 映像的二进制代码进行后构建。</p><blockquote><p>In a service based scenario data is sampled and/or stimulated at RP service points.</p></blockquote><p>在基于服务的场景中，数据在 RP 服务点被采样和 / 或激励。</p><blockquote><p>During either sampling or stimulation the data is read and/or written from the memory associated with the VariableDataPrototype to/from a local buffer during the execution of the RP service point and hence transferred to/from the RP tool.</p></blockquote><p>在采样或刺激期间，在执行 RP 服务点期间，从与 VariableDataPrototype 关联的存储器中读取和 / 或写入本地缓冲区，从而将数据传输到 / 从 RP 工具。</p><blockquote><p>Within the context of the RTE the data stimulated by the RP service points are the RP global buffers and RP global measurement buffers however any data that is measurable is potentially subject to reading.</p></blockquote><p>在 RTE 的上下文中，由 RP 服务点激发的数据是 RP 全局缓冲区和 RP 全局测量缓冲区，但是任何可测量数据都可能受到读取。</p><blockquote><p>A RP service point is simply a call of a RP service function that is provided by the RP service component.</p></blockquote><p>RP 服务点只是对 RP 服务组件提供的 RP 服务函数的调用。</p><blockquote><p>The RP service function is responsible for sampling (reading) and stimulating (writing) the bypass data.</p></blockquote><p>RP 服务功能负责对旁路数据进行采样 (读取) 和激励 (写入)。</p><blockquote><p>The action of sampling may then trigger the RP system to perform the bypass (this may involve the communication of the sampled data to an external system for computation) ready for reading when the stimulation occurs.</p></blockquote><p>采样操作可能会触发 RP 系统执行旁路操作 (这可能涉及将采样数据传送到外部系统进行计算)，以便在刺激发生时进行读取。</p><h2 id="410-data-transformation"><a class="anchor" href="#410-data-transformation">#</a> <strong>4.10</strong> Data Transformation</h2><blockquote><p>Transformers enable AUTOSAR systems to use a data transformation mechanism to linearize and transform data.</p></blockquote><p>废话一条</p><blockquote><p>They can be concatenated to transformer chains and are executed by the RTE for inter-ECU communication which is configured to be transformed.</p></blockquote><p>它们可以连接到转换器链，并由用于 ECU 间通信的 RTE 执行，ECU 间通信被配置为被转换的</p><blockquote><p>The input of the first transformer in the chain gets the data from the RTE.Each following transformer uses the output of the preceding transformer as input.</p></blockquote><p>链中第一个转换器的输入从 RTE 获得数据，随后的每个转换器使用前一个转换器的输出作为输入</p><blockquote><p>All transformers following the first one then have a generic signature with just a byte array as IN and OUT parameter. Such an architecture could be used to design systems, where you can flexibly add functionality like safety or security protection to a serialized stream.</p></blockquote><p>第一个转换器之后的所有转换器都有一个通用的签名，只有字节数组作为 IN 和 OUT 参数。这样的架构可以用来设计系统，您可以在串行流中灵活地添加安全或安全保护等功能。</p><blockquote><p>The transformers for inter-ECU communication are configured in the System Description.</p></blockquote><p>用于 ECU 间通信的转换器在系统说明中配置。</p><blockquote><p>Furthermore the RTE can execute transformers for intra-ECU communication to transform different representations of data structures between software components or basic software modules within one ECU.</p></blockquote><p>此外，RTE 可以执行用于 ECU 内部通信的转换器，以转换一个 ECU 内软件组件或基本软件模块之间的不同数据结构表示。</p><blockquote><p>Transformers for intra-ECU communication are restricted to unqueued S/R communication. In addition no transformer chains are applicable.</p></blockquote><p>用于 ECU 内部通信的转换器仅限于非排队的 S/R 通信。此外，不适用转换器链。</p><blockquote><p>Those limitations are formulated since for the currently known use-cases there is no need for introducing this functionality.</p></blockquote><p>之所以制定这些限制，是因为对于目前已知的用例，没有必要引入此功能。</p><blockquote><p>The execution of the transformers and the necessary buffer handling is coordinated by the RTE.</p></blockquote><p>转换器的运行和必要的缓冲处理由 RTE 进行协调。</p><h3 id="execution-of-transformer"><a class="anchor" href="#execution-of-transformer">#</a> <strong>Execution of Transformer</strong></h3><p><strong>Transformer for inter-ECU communication</strong></p><p><strong>Transformer for intra-ECU communication</strong></p><h3 id="transformer-chains"><a class="anchor" href="#transformer-chains">#</a> <strong>Transformer Chains</strong></h3><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240909142712539.png" alt="image-20240909142712539"></p><h3 id="buffer-handling"><a class="anchor" href="#buffer-handling">#</a> <strong>Buffer Handling</strong></h3><h3 id="interfaces-to-transformer"><a class="anchor" href="#interfaces-to-transformer">#</a> <strong>Interfaces to Transformer</strong></h3><h3 id="error-handling"><a class="anchor" href="#error-handling">#</a> <strong>Error Handling</strong></h3><h3 id="transformer-code-forwarding"><a class="anchor" href="#transformer-code-forwarding">#</a> <strong>Transformer Code Forwarding</strong></h3><blockquote><p>There exist use-cases where the application software needs to influence the behavior of the sending transformer chain.</p></blockquote><p>存在应用软件需要影响发送转换器链的行为的用例。</p><blockquote><p>One prominent example is a signal to service translation application where the forwarding of E2E status information into the E2E Transformer on the sending side is required.</p></blockquote><p>一个突出的例子是信号到服务转换应用程序，其中需要将 E2E 状态信息转发到发送端的 E2E 转换器。</p><blockquote><p>In case E2E protection is to be applied for a communication path with signal to service translation on the way,</p><p>then the E2E status assessed for the received data needs to be forwarded to</p><p>the E2E information generated for the sending side.</p></blockquote><p>如果 E2E 保护应用于具有信号到服务转换的通信路径，则需要对接收到的数据进行评估的 E2E 状态需要转发到为发送方生成的 E2E 信息。</p><blockquote><p>Thus the application which is going to use the data can identify data exchange faults by using the standard E2E check function.</p></blockquote><p>因此，将要使用数据的应用程序可以使用标准的 E2E 检查功能来识别数据交换故障。</p><h3 id="transformer-transaction-handling"><a class="anchor" href="#transformer-transaction-handling">#</a> <strong>Transformer Transaction Handling</strong></h3><h3 id="transformer-protocol-header-peeking"><a class="anchor" href="#transformer-protocol-header-peeking">#</a> <strong>Transformer Protocol Header Peeking</strong></h3><h3 id="com-based-transformer"><a class="anchor" href="#com-based-transformer">#</a> <strong>COM Based Transformer</strong></h3><blockquote><p>The COM Based Transformer approach is an alternative transformation handling whic has several aspects:</p></blockquote><p>基于 COM 的转换器方法是一种可选的转换处理方法，它有以下几个方面</p><blockquote><ul><li>the first transformer is the ’COM Based Transformer’ [24] for the ’serialization’ of data,</li><li>the further transformers are invoked normally and enhance the array representation of the data element,</li><li>the handling of the transformed data towards the COM Module [3] is done via a specific array based signal group API.</li></ul></blockquote><p>第一个转换器是 “基于 COM 的 Transformer”[24] 对于数据的 “序列化 “</p><p>进一步变换器被正常调用并增强数据元素的阵列表示，</p><p>向 COM 模块转换数据的处理 [3] 是通过特定的基于阵列的信号组 API 来完成的。</p><blockquote><p>The ’COM Based Transformer’ [24] serializes the data elements into the array representation exactly as the COM module would have done it.</p></blockquote><p>基于 COM 的转换器 [24] 正如 COM 模块所做的那样，将数据元素序列化为数组表示形式。</p><blockquote><p>The System Template [8] provides means to define which data elements shall be handled by the ’COM Based Transformer’ and - via the communication matrix section - also how the data shall be serialized.</p></blockquote><p>系统模板 [8] 提供了定义哪些数据元素应该由 “基于 COM 的 Transformer” 处理的方法，以及 -- 通过通信矩阵部分 -- 数据应该如何序列化。</p><blockquote><p>This is the basis for the COM module’s configuration and ’COM Based Transformer’ behavior.</p><p>The RTE interacts with the COM module via dedicated array based signal group APIs for sending and receiving the transformed data.</p></blockquote><p>这是 COM 模块配置和 “基于 COM 的 Transformer” 行为的基础。<br>RTE 通过专用的基于阵列的信号组 API 与 COM 模块交互，用于发送和接收转换数据。</p><h1 id="5-rte-reference"><a class="anchor" href="#5-rte-reference">#</a> <strong>5 RTE Reference</strong></h1><blockquote><p>“Everything should be as simple as possible, but no simpler.”</p><p>– <em>Albert Einstein</em></p></blockquote><h2 id="51-scope"><a class="anchor" href="#51-scope">#</a> <strong>5.1</strong> Scope</h2><ul><li><p><strong>5.1.1 Programming Languages</strong></p></li><li><p><strong>5.1.2 Generator Principles</strong></p><ul><li><p><strong>Operating Modes</strong></p><ul><li><p><strong>Compatibility Mode</strong></p></li><li><p><strong>Vendor Mode</strong></p></li></ul></li><li><p><strong>Optimization Modes</strong></p><ul><li><strong>Build support</strong></li><li><strong>Software Component Namespace</strong></li></ul></li></ul></li><li><p><strong>5.1.3 Generator external configuration switches</strong></p><ul><li><strong>Unconnected R-Port check</strong></li><li><strong>Missing input configuration check</strong></li><li><strong>Missing initialization values</strong></li></ul></li></ul><h2 id="52-api-principles"><a class="anchor" href="#52-api-principles">#</a> <strong>5.2</strong> API Principles</h2><blockquote><p>The design of the RTE API has been guided by the following core principles:</p><ul><li>The API should be orthogonal – there should be only one way of performing a task.</li><li><strong>[SWS_Rte_01314]</strong> The API shall be compiler independent. <em>(<strong>SRS_Rte_00100</strong>)</em></li><li><strong>[SWS_Rte_01315]</strong> The API shall support components where the source code is available [SRS_Rte_00024] and where only object-code is available [SRS_Rte_00140].<em>(<strong>SRS_Rte_00024</strong>,</em> <em>SRS_Rte_00140</em>*)*</li><li>The API shall support the multiple instantiation of AUTOSAR software components [SRS_Rte_00011] that share code [SRS_Rte_00012].</li></ul></blockquote><p>RTE API 的设计遵循以下核心原则:</p><ul><li>API 应该是正交的 -- 执行任务应该只有一种方法</li><li>[SWS_Rte_01314] API 应与编译器无关。(SRS_Rte_00100)</li><li>[SWS_Rte_01315] API 应支持源代码可用的组件 [SRS_Rte_00024] 和只有对象代码可用的组件 [SRS Rte_00140].c (SRS Rte_00024，SRS_Rte_00140**)</li><li>API 应支持共享代码「SRS Rte 00012] 的 AUTOSAR 软件组件 [SRS Rte00011] 的多个实例化。</li></ul><blockquote><p>Two forms of the RTE API are available to software-components; direct and indirect.</p></blockquote><p>软件组件可以使用两种形式的 RTE API: 直接和间接。</p><blockquote><p>The direct API has been designed with regard to efficient invocation and includes an API mapping that can be used by an RTE generator to optimize a component’s API, for example, to permit the direct invocation of the generated API functions or even eliding the generated RTE completely.</p></blockquote><p>直接 API 的设计考虑了高效的调用，并包括一个 API 映射，RTE 生成器可以使用它来优化组件的 API，例如，允许直接调用生成的 API 函数，甚至完全省略生成的 RTE。</p><blockquote><p>The indirect API cannot be optimized using the API mapping but has the advantage that the handle used to access the API can be stored in memory and accessed, via an iterator, to apply the same API to multiple ports.</p></blockquote><p>间接 API 不能使用 API 映射进行优化，但它具有优势，即用于访问 API 的句柄可以存储在内存中，并通过迭代器进行访问，以将相同的 API 应用于多个端口。</p><p>嗯这个真的是很常用，会将整个代码的逻辑梳理的很清晰</p><p>给个例子吧</p><pre><code class="language-C">void (*fuck[10])(int) = {
    PipeLine_CheckPointer,
    PipeLine_CheckStatus,
    PipeLine_EnterProtectionArae
};

int main(){
    
}
</code></pre><p>就这样吧</p><h3 id="521-rte-namespace"><a class="anchor" href="#521-rte-namespace">#</a> <strong>5.2.1</strong> RTE Namespace</h3><h3 id="522-direct-ap"><a class="anchor" href="#522-direct-ap">#</a> <strong>5.2.2</strong> Direct AP</h3><h3 id="523-indirect-api"><a class="anchor" href="#523-indirect-api">#</a> <strong>5.2.3</strong> Indirect API</h3><h3 id="524-variableaccess-in-the-datareadaccess-and-datawriteaccess-roles"><a class="anchor" href="#524-variableaccess-in-the-datareadaccess-and-datawriteaccess-roles">#</a> <strong>5.2.4</strong> VariableAccess <strong>in the</strong> <strong>dataReadAccess</strong> <strong>and</strong> <strong>dataWriteAccess</strong> <strong>roles</strong></h3><h3 id="525-per-instance-memory"><a class="anchor" href="#525-per-instance-memory">#</a> <strong>5.2.5</strong> Per Instance Memory</h3><h3 id="526-api-mapping"><a class="anchor" href="#526-api-mapping">#</a> <strong>5.2.6</strong> API Mapping</h3><h3 id="527-unconnected-ports"><a class="anchor" href="#527-unconnected-ports">#</a> <strong>5.2.7</strong> Unconnected Ports</h3><h3 id="528-non-identical-port-interfaces"><a class="anchor" href="#528-non-identical-port-interfaces">#</a> <strong>5.2.8</strong> Non-identical port interfaces</h3><h3 id="529-return-type-std_returntype"><a class="anchor" href="#529-return-type-std_returntype">#</a> <strong>5.2.9</strong> Return type Std_ReturnType</h3><h2 id="53-rte-modules"><a class="anchor" href="#53-rte-modules">#</a> <strong>5.3</strong> RTE Modules</h2><h2 id="54-rte-data-structures"><a class="anchor" href="#54-rte-data-structures">#</a> <strong>5.4</strong> RTE Data Structures</h2><h2 id="55-api-data-types"><a class="anchor" href="#55-api-data-types">#</a> <strong>5.5</strong> API Data Types</h2><h3 id="551-std_returntype"><a class="anchor" href="#551-std_returntype">#</a> <strong>5.5.1</strong> Std_ReturnType</h3><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240919111157918.png" alt="image-20240919111157918"></p><h2 id="56-api-reference"><a class="anchor" href="#56-api-reference">#</a> <strong>5.6</strong> API Reference</h2><h2 id="57-runnable-entity-reference"><a class="anchor" href="#57-runnable-entity-reference">#</a> <strong>5.7</strong> Runnable Entity Reference</h2><h2 id="58-rte-lifecycle-api-reference"><a class="anchor" href="#58-rte-lifecycle-api-reference">#</a> <strong>5.8</strong> RTE Lifecycle API Reference</h2><h2 id="59-rte-call-backs-reference"><a class="anchor" href="#59-rte-call-backs-reference">#</a> <strong>5.9</strong> RTE Call-backs Reference</h2><h2 id="510-expected-interfaces"><a class="anchor" href="#510-expected-interfaces">#</a> <strong>5.10</strong> Expected interfaces</h2><h2 id="511-vfb-tracing-reference"><a class="anchor" href="#511-vfb-tracing-reference">#</a> <strong>5.11</strong> VFB Tracing Reference</h2><h1 id="6-basic-software-scheduler-reference"><a class="anchor" href="#6-basic-software-scheduler-reference">#</a> <strong>6 Basic Software Scheduler Reference</strong></h1><h1 id="7-rte-implementation-plug-ins-reference"><a class="anchor" href="#7-rte-implementation-plug-ins-reference">#</a> <strong>7 RTE Implementation Plug-Ins Reference</strong></h1><h2 id="711-rte-implementation-plug-ins-in-the-autosar-architecture"><a class="anchor" href="#711-rte-implementation-plug-ins-in-the-autosar-architecture">#</a> <strong>7.1.1</strong> RTE Implementation Plug-Ins in the AUTOSAR Architecture</h2><p><img data-src="../../../img.assets/24-11-01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%884%EF%BC%89RTE/image-20240919113812748.png" alt="image-20240919113812748"></p><h1 id="8-rte-ecu-configuration"><a class="anchor" href="#8-rte-ecu-configuration">#</a> <strong>8 RTE ECU Configuration</strong></h1><h1 id="2-functional-overview"><a class="anchor" href="#2-functional-overview">#</a> <strong>2 Functional Overview</strong></h1><blockquote><p>The Run-Time Environment (RTE) is at the heart of the AUTOSAR ECU architecture. The RTE is the realization (for a particular ECU) of the interfaces of the AUTOSAR Virtual Function Bus (VFB) and thus provides the infrastructure services for communication between Application Software Components as well as facilitating access to basic software components including the OS.</p></blockquote><p>RTE 是 VFB 的实现，为应用软件组件之间提供通信，SWC 与 BSW 之间的交互</p><h1 id="4-requirements-on-rte"><a class="anchor" href="#4-requirements-on-rte">#</a> <strong>4 Requirements on RTE</strong></h1><h2 id="41-functional-requirements"><a class="anchor" href="#41-functional-requirements">#</a> <strong>4.1</strong> Functional Requirements</h2><h3 id="411-interaction-with-autosar-os"><a class="anchor" href="#411-interaction-with-autosar-os">#</a> <strong>4.1.1</strong> Interaction with AUTOSAR OS</h3><p><strong>[SRS_Rte_00020] Access to OS</strong></p><p><strong>[SRS_Rte_00099] Decoupling of interrupts</strong></p><p><strong>[SRS_Rte_00036] Assignment to OS Applications</strong></p><p><strong>[SRS_Rte_00049] Construction of task bodies</strong></p><p><strong>[SRS_Rte_00193] Support for Runnable Entity execution chaining</strong></p><p><strong>[SRS_Rte_00210] Support for inter OS application communication</strong></p><h2 id="412-interaction-with-autosar-com"><a class="anchor" href="#412-interaction-with-autosar-com">#</a> <strong>4.1.2</strong> Interaction with AUTOSAR COM</h2><p><strong>[SRS_Rte_00068] Signal initial values</strong></p><p><strong>[SRS_Rte_00069] Communication timeouts</strong></p><p><strong>[SRS_Rte_00073] Atomic transport of Data Elements</strong></p><p><strong>[SRS_Rte_00082] Standardized communication protocol</strong></p><p><strong>[SRS_Rte_00091] Inter-ECU Marshalling</strong></p><p><strong>[SRS_Rte_00181] Conversion between internal and network data types</strong></p><p><strong>[SRS_Rte_00246] Support of Efficient COM for large data</strong></p><p><strong>[SRS_Rte_00251] Array based signal group handling with Com</strong></p><p><strong>[SRS_Rte_00322] Support of Metadata</strong></p><h2 id="413-interaction-with-application-software-components"><a class="anchor" href="#413-interaction-with-application-software-components">#</a> <strong>4.1.3</strong> <strong>Interaction with Application Software Components</strong></h2><p><strong>[SRS_Rte_00011] Support for multiple Application Software Component instances.</strong></p><p><strong>[SRS_Rte_00012] Multiple instantiated AUTOSAR software components delivered as binary code shall share code</strong></p><p><strong>[SRS_Rte_00013] Per-instance memory</strong></p><p><strong>[SRS_Rte_00077] Instantiation of per-instance memory</strong></p><p><strong>[SRS_Rte_00017] Rejection of inconsistent component implementations</strong></p><p><strong>[SRS_Rte_00134] Runnable Entity categories supported by the RTE</strong></p><p><strong>[SRS_Rte_00072] Activation of Runnable Entities</strong></p><p>RTE 要根据事件触发任务</p><p><strong>[SRS_Rte_00160] Debounced start of Runnable Entities</strong></p><p><strong>消抖，短时间内只触发一次</strong></p><p><strong>[SRS_Rte_00161] Activation offset of Runnable Entities</strong></p><p><strong>[SRS_Rte_00031] Multiple Runnable Entities</strong></p><p><strong>[SRS_Rte_00032] Data consistency mechanisms</strong></p><p><strong>数据一致性的机制</strong></p><p><strong>[SRS_Rte_00046] Support for "Executable Entity runs inside" Exclusive Areas</strong></p><p><strong>[SRS_Rte_00142] Support for InterRunnableVariables</strong></p><p><strong>[SRS_Rte_00033] Serialized execution of Server Runnable Entities</strong></p><p>RTE 支持运行实体的序列化执行</p><p><strong>[SRS_Rte_00133] Concurrent invocation of Runnable Entities</strong></p><p>可并发</p><p><strong>[SRS_Rte_00143] Mode Switches</strong></p><p><strong>[SRS_Rte_00176] Sharing of NVRAM data</strong></p><p><strong>[SRS_Rte_00180] DataSemantics range check during runtime</strong></p><p>支持一些数据的检查</p><p><strong>[SRS_Rte_00182] Self Scaling Signals at Port Interfaces</strong></p><p><strong>[SRS_Rte_00236] Support for ModeInterfaceMapping</strong></p><p><strong>[SRS_Rte_00237] Time recurrent activation of Runnable Entities</strong></p><p>可定时循环激活运行实体</p><h2 id="414-interaction-with-basic-software-components"><a class="anchor" href="#414-interaction-with-basic-software-components">#</a> <strong>4.1.4</strong> <strong>Interaction with Basic Software Components</strong></h2><p><strong>[SRS_Rte_00152] Support for port-defined argument values</strong></p><p><strong>[SRS_Rte_00022] Interaction with call-backs</strong></p><p><strong>[SRS_Rte_00062] Local access to basic software components</strong></p><p>支持本地通过 BSW，也可以远程通过其他 ECU 的 BSW</p><p><strong>[SRS_Rte_00169] Map code and memory allocated by the RTE to memory sections</strong></p><p><strong>[SRS_Rte_00170] Provide used memory sections description</strong></p><p><strong>[SRS_Rte_00177] Support of NvBlockComponentType</strong></p><p><strong>[SRS_Rte_00228] Fan-out NvBlock callback function</strong></p><p><strong>[SRS_Rte_00233] Generation of the Basic Software Module Description</strong></p><p><strong>[SRS_Rte_00241] Support for Local or Remote Handling of BSW Service Calls on Partitioned Systems</strong></p><blockquote><p>For systems where the BSW modules can be executed in multiple partitions, the RTE generator shall redirect the BSW service call from a SWC either to the local or to a remote partition based on the partition mapping(s) assigned to the BSW Module.</p></blockquote><p><strong>[SRS_Rte_00245] Support of Writing Strategies for NV data</strong></p><h2 id="415-generation-of-the-bsw-scheduler"><a class="anchor" href="#415-generation-of-the-bsw-scheduler">#</a> <strong>4.1.5</strong> <strong>Generation of the BSW Scheduler</strong></h2><p><strong>[SRS_Rte_00211] Cyclic time based scheduling of BSW Schedulable Entities</strong></p><p><strong>[SRS_Rte_00212] Activation Offset of BSW Schedulable Entities</strong></p><p><strong>[SRS_Rte_00213] Mode Switches for BSW Modules</strong></p><p><strong>[SRS_Rte_00214] Common Mode handling for Basic SW and Application SW</strong></p><p><strong>[SRS_Rte_00215] API for Mode switch notification to the SchM</strong></p><p><strong>[SRS_Rte_00216] Triggering of BSW Schedulable Entities by occurrence of External Trigger</strong></p><p>支持外部的触发源</p><p><strong>[SRS_Rte_00230] Triggering of BSW Schedulable Entities by occurrence of Internal Trigger</strong></p><p><strong>[SRS_Rte_00217] Synchronized activation of Runnable Entities and BSW Schedulable Entities</strong></p><p><strong>[SRS_Rte_00218] API for Triggering BSW modules by Triggered Events</strong></p><p><strong>[SRS_Rte_00219] Support for interlaced execution sequences of Runnable Entities and BSW Schedulable Entities</strong></p><p><strong>[SRS_Rte_00220] ECU life cycle dependent scheduling</strong></p><p><strong>[SRS_Rte_00221] Support for "BSW integration" builds</strong></p><p><strong>[SRS_Rte_00222] Support shared exclusive areas in BSW Service Modules and the corresponding Service Component</strong></p><p><strong>[SRS_Rte_00229] Support for Variant Handling of BSW Modules</strong></p><p><strong>[SRS_Rte_00243] Support for inter-partition communication of BSW modules</strong></p><h2 id="416-support-for-measurement-and-calibration"><a class="anchor" href="#416-support-for-measurement-and-calibration">#</a> <strong>4.1.6</strong> <strong>Support for Measurement and Calibration</strong></h2><p><strong>[SRS_Rte_00153] Support for Measurement</strong></p><p><strong>[SRS_Rte_00154] Support for Calibration</strong></p><p><strong>[SRS_Rte_00156] Support for different calibration data emulation methods</strong></p><blockquote><p>The RTE generator shall support these data emulation methods for calibration purposes:</p><p>directAccess</p><p>Calibration data is stored in ROM and accessed directly. This method can be used with appropriate calibration hardware.</p><p>Single pointered method</p><p>Calibration data accesses are done via one indirection over a pointer table in</p><p>RAM</p><p>Double pointered method</p><p>Calibration data accesses are done via a base pointer in RAM and over a pointer table in ROM/FLASH</p><p>InitRAM parameter method</p><p>RTE accesses calibration parameters located in RAM directly (without any indirection) and copies the values from ROM/FLASH during startup</p><p>Methods 2-4 need SW support from RTE.</p></blockquote><p>要支持数据校准</p><p><strong>[SRS_Rte_00157] Support for calibration parameters in NVRAM</strong></p><p><strong>[SRS_Rte_00158] Support separation of calibration parameters</strong></p><p><strong>[SRS_Rte_00159] Sharing of calibration parameters</strong></p><p><strong>[SRS_Rte_00189] A2L Generation Support</strong></p><h2 id="417-general-requirements"><a class="anchor" href="#417-general-requirements">#</a> <strong>4.1.7</strong> <strong>General Requirements</strong></h2><p><strong>[SRS_Rte_00021] Per-ECU RTE customization</strong></p><blockquote><p>The RTE shall be customizable (generated and/or configured) for each ECU.</p><p>The RTE generator should avoid, where possible, the use of generic functions and should, instead, favor functions that are configured/generated to specifically implement the required communication patterns.</p></blockquote><p>RTE 应该客制化，配置化，尽量避免使用通用的 API</p><p><strong>[SRS_Rte_00065] Deterministic generation</strong></p><p><strong>[SRS_Rte_00028] "1:n" Sender-receiver communication</strong></p><p><strong>[SRS_Rte_00131] "n:1" Sender-receiver communication</strong></p><p><strong>[SRS_Rte_00029] "n:1" Client-server communication</strong></p><blockquote><p>The RTE shall support multiple-client-single-server ("n:1") client-server (function invocation) communication. Individual clients are independent - there is no coordination of requests between clients.</p><p>Single-client-multiple-server ("1:n") communication is not required. Such communication raises issues about buffering and selection of results that are application dependent and therefore not considered to be the domain of the RTE.</p></blockquote><p>不需要单客户端多服务端</p><p><strong>[SRS_Rte_00079] Single asynchronous client-server interaction</strong></p><p>一次只支持单个的异步交互</p><p><strong>[SRS_Rte_00080] Multiple requests of servers</strong></p><p>支持多个客户端对服务端的并发请求，服务端进行请求队列排队</p><p><strong>[SRS_Rte_00162] "1:n" External Trigger communication</strong></p><p><strong>[SRS_Rte_00163] Support for InterRunnableTriggering</strong></p><p><strong>[SRS_Rte_00235] Support queued triggers</strong></p><p><strong>[SRS_Rte_00025] Static communication</strong></p><blockquote><p>The RTE shall support only those communication connections known when the RTE is generated - the source(s) and destination(s) of all communication shall be known statically</p></blockquote><p>也就是说，服务器端的接口都是定义好的，都是静态的。只有订阅者是动态的。</p><p><strong>[SRS_Rte_00144] RTE shall support the notification of mode switches via AUTOSAR interfaces</strong></p><p>定义好接口机制，在模式切换时做好 trace 函数接口</p><p><strong>[SRS_Rte_00018] Rejection of invalid configurations</strong></p><p><strong>[SRS_Rte_00055] RTE use of global namespace</strong></p><blockquote><p>All symbols use the prefix "RTE".</p></blockquote><p><strong>[SRS_Rte_00164] Ensure a unique naming of generated types visible in the global namespace</strong></p><p><strong>[SRS_Rte_00165] Suppress identical "C" type re-definitions</strong></p><p><strong>[SRS_Rte_00166] Use the AUTOSAR Standard Types in the global namespace if the AUTOSAR data type is mapped to an AUTOSAR Standard Type</strong></p><p><strong>[SRS_Rte_00167] Encapsulate a Software Component local name space</strong></p><p><strong>[SRS_Rte_00252] Encapsulate a BSW Module local name space</strong></p><p><strong>[SRS_Rte_00126] C language support</strong></p><p><strong>[SRS_Rte_00138] C++ language support</strong></p><p><strong>[SRS_Rte_00051] RTE API mapping</strong></p><p><strong>[SRS_Rte_00048] RTE Generator input</strong></p><p><strong>[SRS_Rte_00023] RTE Overheads</strong></p><p><strong>[SRS_Rte_00024] Source-code AUTOSAR software components</strong></p><p><strong>[SRS_Rte_00140] Binary-code AUTOSAR software components</strong></p><p><strong>[SRS_Rte_00083] Optimization for source-code components</strong></p><p><strong>[SRS_Rte_00027] VFB to RTE mapping shall be semantic preserving</strong></p><p><strong>[SRS_Rte_00190] Support for variable-length Data Types</strong></p><p><strong>[SRS_Rte_00234] Support for Record Type sub-setting</strong></p><blockquote><p>4 wheel speed signals and the movement direction signal are provided in one record. If a receiver is only interested in the movement direction information all of the other information from this record does not have to be considered at this specific receiver.</p></blockquote><p><strong>[SRS_Rte_00098] Explicit Sending</strong></p><p><strong>[SRS_Rte_00129] Implicit Sending</strong></p><p><strong>[SRS_Rte_00128] Implicit Reception</strong></p><p><strong>[SRS_Rte_00141] Explicit Reception</strong></p><p><strong>[SRS_Rte_00092] Implementation of VFB model "waitpoints"</strong></p><p>支持等待点，事件触发后继续执行</p><p><strong>[SRS_Rte_00145] Compatibility mode</strong></p><p><strong>[SRS_Rte_00146] Vendor mode</strong></p><p>有一个供应商的操作模式</p><p><strong>[SRS_Rte_00148] Support "Specification of Memory Mapping"</strong></p><p><strong>[SRS_Rte_00150] Support "Specification of Platform Types"</strong></p><p><strong>[SRS_Rte_00151] Support RTE relevant requirements of the "General Requirements on Basic Software Modules"</strong></p><p><strong>[SRS_Rte_00171] Support for fixed and constant data</strong></p><p><strong>[SRS_Rte_00178] Data consistency of NvBlockComponentType</strong></p><p><strong>[SRS_Rte_00179] Support of Update Flag for Data Reception</strong></p><p>有个标志位来标识是否有数据更新</p><p><strong>[SRS_Rte_00184] RTE Status "Never Received"</strong></p><p><strong>[SRS_Rte_00191] Support for Variant Handling</strong></p><p><strong>[SRS_Rte_00201] Contract Phase with Variant Handling support</strong></p><p><strong>[SRS_Rte_00202] Support for array size variants</strong></p><p><strong>[SRS_Rte_00204] Support the selection / de-selection of SWC prototypes</strong></p><p><strong>[SRS_Rte_00206] Support the selection of a signal provider</strong></p><p><strong>[SRS_Rte_00207] Support N to M communication patterns while unresolved variations are affecting these communications</strong></p><p><strong>[SRS_Rte_00231] Support native interface between Rte and Com for Strings and uint8 arrays</strong></p><p><strong>[SRS_Rte_00232] Synchronization of runnable entities</strong></p><p><strong>[SRS_Rte_00238] Allow enabling of RTE-Feature to get the activating Event of Executable Entity</strong></p><p><strong>[SRS_Rte_00244] Support for bypass</strong></p><p><strong>[SRS_Rte_00254] Selectable RP Preparation</strong></p><p><strong>[SRS_Rte_00255] RP Memory Interface</strong></p><p><strong>[SRS_Rte_00256] Conditional Bypass</strong></p><p><strong>[SRS_Rte_00257] RunnableEntity Bypass</strong></p><p><strong>[SRS_Rte_00258] RTE Generated Service Points</strong></p><p><strong>[SRS_Rte_00259] Manually Inserted Service Points</strong></p><p><strong>[SRS_Rte_00260] RP Interface Documentation</strong></p><p><strong>[SRS_Rte_00247] The Rte shall execute transformer chains for SWC communication</strong></p><p><strong>[SRS_Rte_00248] The Rte shall provide the buffer for the data transformation</strong></p><p><strong>[SRS_Rte_00249] The Rte shall provide transformation errors to the SWCs</strong></p><p><strong>[SRS_Rte_00253] The RTE shall execute data transformation for SWC/BSW communication within one ECU</strong></p><p><strong>[SRS_Rte_00250] The Rte shall provide size indications of variable size arrays to SWCs</strong></p><p>对可变大小的数组要指示出长度信息</p><p><strong>[SRS_Rte_00261] The RTE shall support optional struct members.</strong></p><h2 id="418-vfb-tracing"><a class="anchor" href="#418-vfb-tracing">#</a> <strong>4.1.8</strong> <strong>VFB Tracing</strong></h2><p><strong>[SRS_Rte_00005] The RTE generator shall support "trace" builds</strong></p><p>支持 trace，这里会有很多接口来追踪代码</p><p><strong>[SRS_Rte_00045] Standardized VFB tracing interface</strong></p><p><strong>[SRS_Rte_00008] VFB tracing configuration</strong></p><p><strong>[SRS_Rte_00192] Support multiple trace clients</strong></p><p><strong>[SRS_Rte_00003] Tracing of sender-receiver communication</strong></p><p><strong>[SRS_Rte_00004] Tracing of client-server communication</strong></p><h2 id="419-application-software-component-initialization-and-finalization"><a class="anchor" href="#419-application-software-component-initialization-and-finalization">#</a> <strong>4.1.9</strong> <strong>Application Software Component Initialization and Finalization</strong></h2><p><strong>[SRS_Rte_00052] Initialization and finalization of components</strong></p><p><strong>[SRS_Rte_00070] Invocation order of Runnable Entities</strong></p><p><strong>[SRS_Rte_00239] Support rule-based initialization of composite DataPrototypes and compound primitive DataPrototypes</strong></p><p><strong>[SRS_Rte_00240] Support of init runnables for initialization purposes</strong></p><h2 id="4110-api"><a class="anchor" href="#4110-api">#</a> <strong>4.1.10</strong> <strong>API</strong></h2><p><strong>[SRS_Rte_00100] Compiler independent API</strong></p><p><strong>[SRS_Rte_00168] Typing of RTE API.</strong></p><p><strong>[SRS_Rte_00059] RTE API shall pass "in" primitive data types by value</strong></p><p><strong>[SRS_Rte_00060] RTE API shall pass "in" composite data types by reference</strong></p><blockquote><p>Pass by reference is efficient for large data types.</p></blockquote><p><strong>[SRS_Rte_00061] "in/out" and "out" parameters</strong></p><blockquote><p>The RTE API shall pass ‘in/out’ and "out" formal parameters by reference.</p></blockquote><p><strong>[SRS_Rte_00115] API for data consistency mechanism</strong></p><p><strong>[SRS_Rte_00075] API for accessing per-instance memory</strong></p><p><strong>[SRS_Rte_00107] Support for INFORMATION_TYPE attribute</strong></p><p><strong>[SRS_Rte_00108] Support for INIT_VALUE attribute</strong></p><p><strong>[SRS_Rte_00109] Support for RECEIVE_MODE attribute</strong></p><p><strong>[SRS_Rte_00110] Support for BUFFERING attribute</strong></p><p><strong>[SRS_Rte_00111] Support for CLIENT_MODE attribute</strong></p><p><strong>[SRS_Rte_00121] Support for FILTER attribute</strong></p><p><strong>[SRS_Rte_00147] Support for communication infrastructure time-out notification</strong></p><p><strong>[SRS_Rte_00078] Support for Data Element Invalidation</strong></p><p><strong>[SRS_Rte_00122] Support for Transmission Acknowledgement</strong></p><p><strong>[SRS_Rte_00094] Communication and Resource Errors</strong></p><p><strong>[SRS_Rte_00084] Support infrastructural errors</strong></p><p><strong>[SRS_Rte_00123] The RTE shall forward application level errors from server to client</strong></p><p><strong>[SRS_Rte_00124] API for application level errors during Client Server communication</strong></p><p><strong>[SRS_Rte_00089] Independent access to interface elements</strong></p><p><strong>[SRS_Rte_00137] API for mismatched ports</strong></p><p><strong>[SRS_Rte_00139] Support for unconnected ports</strong></p><p><strong>[SRS_Rte_00200] Support of unconnected R-Ports</strong></p><p><strong>[SRS_Rte_00155] API to access calibration parameters</strong></p><p><strong>[SRS_Rte_00183] RTE Read API returning the dataElement value</strong></p><p><strong>[SRS_Rte_00185] RTE API with Rte_IFeedback</strong></p><p><strong>[SRS_Rte_00203] API to read system constant</strong></p><p><strong>[SRS_Rte_00242] Support for Cross-Core Exclusive Areas</strong></p><h2 id="4111-cc-api"><a class="anchor" href="#4111-cc-api">#</a> <strong>4.1.11</strong> C/C++ API</h2><p><strong>[SRS_Rte_00087] Software Module Header File generation</strong></p><h2 id="4112-initialization-and-finalization-operation"><a class="anchor" href="#4112-initialization-and-finalization-operation">#</a> <strong>4.1.12</strong> <strong>Initialization and Finalization Operation</strong></h2><p><strong>[SRS_Rte_00116] RTE Initialization and finalization</strong></p><h2 id="4113-partition-restarting-and-termination"><a class="anchor" href="#4113-partition-restarting-and-termination">#</a> <strong>4.1.13</strong> <strong>Partition Restarting and Termination</strong></h2><p><strong>[SRS_Rte_00196] Inter-partition communication consistency</strong></p><h2 id="4114-fault-operation"><a class="anchor" href="#4114-fault-operation">#</a> <strong>4.1.14</strong> <strong>Fault Operation</strong></h2><h2 id="4115-rte-implementation-plug-ins"><a class="anchor" href="#4115-rte-implementation-plug-ins">#</a> <strong>4.1.15</strong> <strong>RTE Implementation Plug-Ins</strong></h2><p><strong>[SRS_Rte_00318] Modular Runtime Environment</strong></p><p><strong>[SRS_Rte_00300] RTE Implementation Plug-Ins for explicit communication</strong></p><blockquote><p>The RTE shall support to implement for explicit communication following subfunctionality</p><p><em>•</em> getting a semaphore</p><p><em>•</em> releasing a semaphore</p><p><em>•</em> implementation of the semaphore</p><p><em>•</em> accessing the global copy of the data</p><p><em>•</em> invocation of transformers</p><p><em>•</em> APIs to enable the communication across different ASIL levels</p><p><em>•</em> APIs to enable the communication between Software Clusters</p><p>via RTE Implementation Plug-Ins outside the RTE Generator. This includes port based communication as well as Inter Runnable Variables.</p></blockquote><p><strong>[SRS_Rte_00301] RTE Implementation Plug-Ins for implicit communication</strong></p><p><strong>[SRS_Rte_00320] RTE Implementation Plug-Ins for implicit communication II</strong></p><p><strong>[SRS_Rte_00302] RTE Implementation Plug-Ins for exclusive areas</strong></p><p><strong>[SRS_Rte_00303] RTE Implementation Plug-Ins for global copy instantiation</strong></p><p><strong>[SRS_Rte_00304] Multiple RTE Plug-Ins</strong></p><p><strong>[SRS_Rte_00305] Graduated validation strategy</strong></p><p><strong>[SRS_Rte_00306] Standardized interfaces for RTE Implementation Plug-Ins</strong></p><p><strong>[SRS_Rte_00307] RTE Implementation Plug-Ins for cross core communication</strong></p><p><strong>[SRS_Rte_00309] RTE Implementation Plug-Ins for cross safety partition communication</strong></p><p><strong>[SRS_Rte_00310] Shared mode queue</strong></p><p><strong>[SRS_Rte_00311] Core synchronous transitions for mode switches</strong></p><p><strong>[SRS_Rte_00312] RTE Implementation Plug-Ins for transformers in client server communication</strong></p><p><strong>[SRS_Rte_00317] RTE Implementation Plug-Ins for transformers in trigger communication</strong></p><p><strong>[SRS_Rte_00319] RTE Implementation Plug-Ins for parameter communication</strong></p><p><strong>[SRS_Rte_00313] Description of RTE Implementation Plug-in properties</strong></p><p><strong>[SRS_Rte_00314] Avoid nesting of critical sections</strong></p><p><strong>[SRS_Rte_00315] Protection of mode machine instance access</strong></p><p><strong>[SRS_Rte_00321] RTE Implementation Plug-Ins for mode communication</strong></p><p><strong>[SRS_Rte_00316] RTE Implementation Plug-Ins for compatibility mode</strong></p><div class="tags"><a href="/tags/AUTOSAR/" rel="tag"><i class="ic i-tag"></i> AUTOSAR</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-02-10 22:41:47" itemprop="dateModified" datetime="2025-02-10T22:41:47+08:00">2025-02-10</time> </span><span id="archives/fd244a42.html" class="item leancloud_visitors" data-flag-title="小柴带你学AutoSar系列三、标准和规范篇（4）RTE" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="flechazo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="flechazo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="flechazo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>flechazo <i class="ic i-at"><em>@</em></i>我在人间贩卖黄昏，只为收集世间温柔遇见你.</li><li class="link"><strong>本文链接：</strong> <a href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html" title="小柴带你学AutoSar系列三、标准和规范篇（4）RTE">https://flechazoclf.github.io/FlechazoCLF.github.io/archives/fd244a42.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/archives/3c8f29a7.html" itemprop="url" rel="prev" data-background-image="/archives/3c8f29a7.html../../../wallpaper/19.png" title="小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（2）嵌入式操作系统概述"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 嵌入式系统设计师</span><h3>小柴冲刺软考中级嵌入式系统设计师系列四、嵌入式系统软件基础知识（2）嵌入式操作系统概述</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6autosar%E7%B3%BB%E5%88%97%E4%B8%89-%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%874rte"><span class="toc-number">1.</span> <span class="toc-text">小柴带你学 AutoSar 系列三、标准和规范篇（4）RTE</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-introduction"><span class="toc-number">2.</span> <span class="toc-text">1 Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-rte-overview"><span class="toc-number">3.</span> <span class="toc-text">2 RTE Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-the-rte-in-the-context-of-autosar"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 The RTE in the Context of AUTOSAR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-autosar-concepts"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 AUTOSAR Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221-autosar-software-components"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 AUTOSAR Software-components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-basic-software-modules"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 Basic Software Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223-communication"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3 Communication</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">支持的通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#communication-paradigms"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">Communication Paradigms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#communication-modes"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">Communication Modes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-communication"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">Static Communication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multiplicity"><span class="toc-number">3.2.3.5.</span> <span class="toc-text">Multiplicity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#224-concurrency"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.2.4 Concurrency</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-the-rte-generator"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 The RTE Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-design-decisions"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 Design Decisions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-rte-generation-process"><span class="toc-number">4.</span> <span class="toc-text">3 RTE Generation Process</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rte-generator-for-software-components"><span class="toc-number">4.1.</span> <span class="toc-text">RTE Generator for Software-Components</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rte-generator-for-basic-software-scheduler"><span class="toc-number">4.2.</span> <span class="toc-text">RTE Generator for Basic Software Scheduler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-rte-functional-specification"><span class="toc-number">5.</span> <span class="toc-text">4 RTE Functional Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-architectural-concepts"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 Architectural concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-rte-and-basic-software-scheduler-implementation-aspects"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 RTE and Basic Software Scheduler Implementation Aspects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%87%8Ctask%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">这里 task 有几种不同的触发方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#without-osevent"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">Without OsEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with-osevent"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">With OsEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#monitoring-of-group-of-runnables"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">Monitoring of group of runnables</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text">状态机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#425-interrupt-decoupling-and-notifications"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.5 Interrupt decoupling and notifications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#426-data-consistency"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.2.6 Data Consistency</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-communication-paradigms"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 Communication Paradigms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-sender-receiver"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.3.1 Sender-Receiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#432-client-server"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.3.2 Client-Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#433-swc-internal-communication"><span class="toc-number">5.3.3.</span> <span class="toc-text">4.3.3 SWC internal communication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#434-inter-partition-communication"><span class="toc-number">5.3.4.</span> <span class="toc-text">4.3.4 Inter-Partition communication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-portinterface-element-mapping-and-data-conversion"><span class="toc-number">5.3.5.</span> <span class="toc-text">4.3.5 PortInterface Element Mapping and Data Conversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#436-network-representation"><span class="toc-number">5.3.6.</span> <span class="toc-text">4.3.6 Network Representation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-data-conversion"><span class="toc-number">5.3.7.</span> <span class="toc-text">4.3.7 Data Conversion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-range-checks-during-runtime"><span class="toc-number">5.3.8.</span> <span class="toc-text">4.3.8 Range Checks during Runtime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-modes"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 Modes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#441-mode-user"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.4.1 Mode User</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#442-mode-manager"><span class="toc-number">5.4.2.</span> <span class="toc-text">4.4.2 Mode Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#443-refinement-of-the-semantics-of-modedeclarations-and-mode"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.4.3 Refinement of the semantics of ModeDeclarations and Mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#444-order-of-actions-taken-by-the-rte-basic-software-scheduler-upon-inter"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.4.4 Order of actions taken by the RTE / Basic Software Scheduler upon inter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-external-and-internal-trigger"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 External and Internal Trigger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-initialization-and-finalization"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 Initialization and Finalization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-variant-handling-support"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 Variant Handling Support</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#471-overview"><span class="toc-number">5.7.1.</span> <span class="toc-text">4.7.1 Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#472-choosing-a-variant-and-binding-variability"><span class="toc-number">5.7.2.</span> <span class="toc-text">4.7.2 Choosing a Variant and Binding Variability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#473-variability-affecting-the-rte-generation"><span class="toc-number">5.7.3.</span> <span class="toc-text">4.7.3 Variability affecting the RTE generation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-variability-affecting-the-basic-software-scheduler-generation"><span class="toc-number">5.7.4.</span> <span class="toc-text">4.7.4 Variability affecting the Basic Software Scheduler generation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-development-error"><span class="toc-number">5.8.</span> <span class="toc-text">4.8 Development error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-bypass-support"><span class="toc-number">5.9.</span> <span class="toc-text">4.9 Bypass Support</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#491-bypass-description"><span class="toc-number">5.9.1.</span> <span class="toc-text">4.9.1 Bypass description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#492-component-wrapper-method"><span class="toc-number">5.9.2.</span> <span class="toc-text">4.9.2 Component wrapper method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#493-direct-buffer-access-method"><span class="toc-number">5.9.3.</span> <span class="toc-text">4.9.3 Direct buffer access method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-extended-buffer-access-method"><span class="toc-number">5.9.4.</span> <span class="toc-text">4.9.4 Extended buffer access method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#495-service-based-prototyping"><span class="toc-number">5.9.5.</span> <span class="toc-text">4.9.5 Service Based Prototyping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#410-data-transformation"><span class="toc-number">5.10.</span> <span class="toc-text">4.10 Data Transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execution-of-transformer"><span class="toc-number">5.10.1.</span> <span class="toc-text">Execution of Transformer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transformer-chains"><span class="toc-number">5.10.2.</span> <span class="toc-text">Transformer Chains</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-handling"><span class="toc-number">5.10.3.</span> <span class="toc-text">Buffer Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interfaces-to-transformer"><span class="toc-number">5.10.4.</span> <span class="toc-text">Interfaces to Transformer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-handling"><span class="toc-number">5.10.5.</span> <span class="toc-text">Error Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transformer-code-forwarding"><span class="toc-number">5.10.6.</span> <span class="toc-text">Transformer Code Forwarding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transformer-transaction-handling"><span class="toc-number">5.10.7.</span> <span class="toc-text">Transformer Transaction Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transformer-protocol-header-peeking"><span class="toc-number">5.10.8.</span> <span class="toc-text">Transformer Protocol Header Peeking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#com-based-transformer"><span class="toc-number">5.10.9.</span> <span class="toc-text">COM Based Transformer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-rte-reference"><span class="toc-number">6.</span> <span class="toc-text">5 RTE Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-scope"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Scope</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-api-principles"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 API Principles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521-rte-namespace"><span class="toc-number">6.2.1.</span> <span class="toc-text">5.2.1 RTE Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#522-direct-ap"><span class="toc-number">6.2.2.</span> <span class="toc-text">5.2.2 Direct AP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#523-indirect-api"><span class="toc-number">6.2.3.</span> <span class="toc-text">5.2.3 Indirect API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#524-variableaccess-in-the-datareadaccess-and-datawriteaccess-roles"><span class="toc-number">6.2.4.</span> <span class="toc-text">5.2.4 VariableAccess in the dataReadAccess and dataWriteAccess roles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#525-per-instance-memory"><span class="toc-number">6.2.5.</span> <span class="toc-text">5.2.5 Per Instance Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#526-api-mapping"><span class="toc-number">6.2.6.</span> <span class="toc-text">5.2.6 API Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#527-unconnected-ports"><span class="toc-number">6.2.7.</span> <span class="toc-text">5.2.7 Unconnected Ports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#528-non-identical-port-interfaces"><span class="toc-number">6.2.8.</span> <span class="toc-text">5.2.8 Non-identical port interfaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#529-return-type-std_returntype"><span class="toc-number">6.2.9.</span> <span class="toc-text">5.2.9 Return type Std_ReturnType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-rte-modules"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 RTE Modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-rte-data-structures"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 RTE Data Structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-api-data-types"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 API Data Types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#551-std_returntype"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.5.1 Std_ReturnType</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-api-reference"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 API Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-runnable-entity-reference"><span class="toc-number">6.7.</span> <span class="toc-text">5.7 Runnable Entity Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-rte-lifecycle-api-reference"><span class="toc-number">6.8.</span> <span class="toc-text">5.8 RTE Lifecycle API Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-rte-call-backs-reference"><span class="toc-number">6.9.</span> <span class="toc-text">5.9 RTE Call-backs Reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#510-expected-interfaces"><span class="toc-number">6.10.</span> <span class="toc-text">5.10 Expected interfaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#511-vfb-tracing-reference"><span class="toc-number">6.11.</span> <span class="toc-text">5.11 VFB Tracing Reference</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-basic-software-scheduler-reference"><span class="toc-number">7.</span> <span class="toc-text">6 Basic Software Scheduler Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-rte-implementation-plug-ins-reference"><span class="toc-number">8.</span> <span class="toc-text">7 RTE Implementation Plug-Ins Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#711-rte-implementation-plug-ins-in-the-autosar-architecture"><span class="toc-number">8.1.</span> <span class="toc-text">7.1.1 RTE Implementation Plug-Ins in the AUTOSAR Architecture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-rte-ecu-configuration"><span class="toc-number">9.</span> <span class="toc-text">8 RTE ECU Configuration</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-functional-overview"><span class="toc-number">10.</span> <span class="toc-text">2 Functional Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-requirements-on-rte"><span class="toc-number">11.</span> <span class="toc-text">4 Requirements on RTE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-functional-requirements"><span class="toc-number">11.1.</span> <span class="toc-text">4.1 Functional Requirements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#411-interaction-with-autosar-os"><span class="toc-number">11.1.1.</span> <span class="toc-text">4.1.1 Interaction with AUTOSAR OS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#412-interaction-with-autosar-com"><span class="toc-number">11.2.</span> <span class="toc-text">4.1.2 Interaction with AUTOSAR COM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#413-interaction-with-application-software-components"><span class="toc-number">11.3.</span> <span class="toc-text">4.1.3 Interaction with Application Software Components</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#414-interaction-with-basic-software-components"><span class="toc-number">11.4.</span> <span class="toc-text">4.1.4 Interaction with Basic Software Components</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#415-generation-of-the-bsw-scheduler"><span class="toc-number">11.5.</span> <span class="toc-text">4.1.5 Generation of the BSW Scheduler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-support-for-measurement-and-calibration"><span class="toc-number">11.6.</span> <span class="toc-text">4.1.6 Support for Measurement and Calibration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#417-general-requirements"><span class="toc-number">11.7.</span> <span class="toc-text">4.1.7 General Requirements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#418-vfb-tracing"><span class="toc-number">11.8.</span> <span class="toc-text">4.1.8 VFB Tracing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#419-application-software-component-initialization-and-finalization"><span class="toc-number">11.9.</span> <span class="toc-text">4.1.9 Application Software Component Initialization and Finalization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4110-api"><span class="toc-number">11.10.</span> <span class="toc-text">4.1.10 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4111-cc-api"><span class="toc-number">11.11.</span> <span class="toc-text">4.1.11 C/C++ API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4112-initialization-and-finalization-operation"><span class="toc-number">11.12.</span> <span class="toc-text">4.1.12 Initialization and Finalization Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4113-partition-restarting-and-termination"><span class="toc-number">11.13.</span> <span class="toc-text">4.1.13 Partition Restarting and Termination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4114-fault-operation"><span class="toc-number">11.14.</span> <span class="toc-text">4.1.14 Fault Operation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4115-rte-implementation-plug-ins"><span class="toc-number">11.15.</span> <span class="toc-text">4.1.15 RTE Implementation Plug-Ins</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/archives/dfcb5141.html" rel="bookmark" title="LD文件在AUTOSAR工程中的作用和语法解析">LD文件在AUTOSAR工程中的作用和语法解析</a></li><li><a href="/archives/cbed58a6.html" rel="bookmark" title="小柴带你学AutoSar总目录">小柴带你学AutoSar总目录</a></li><li><a href="/archives/b20010d9.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（1）概念和目标">小柴带你学AutoSar系列一、基础知识篇（1）概念和目标</a></li><li><a href="/archives/e0c2534f.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement">小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement</a></li><li><a href="/archives/e8a5cc27.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构">小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构</a></li><li><a href="/archives/e8bc299.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（5）makefile基础">小柴带你学AutoSar系列一、基础知识篇（5）makefile基础</a></li><li><a href="/archives/5e71c9a6.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（3）C语言基础">小柴带你学AutoSar系列一、基础知识篇（3）C语言基础</a></li><li><a href="/archives/7cac95ec.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（4）编译">小柴带你学AutoSar系列一、基础知识篇（4）编译</a></li><li><a href="/archives/3c7f112.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850">小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850</a></li><li><a href="/archives/3f4a19e2.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（7）术语">小柴带你学AutoSar系列一、基础知识篇（7）术语</a></li><li><a href="/archives/962e9003.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（1）General">小柴带你学习AutoSar系列三、标准和规范篇（1）General</a></li><li><a href="/archives/db4ff6ff.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral">小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral</a></li><li><a href="/archives/c9ca48bd.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement">小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement</a></li><li class="active"><a href="/archives/fd244a42.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（4）RTE">小柴带你学AutoSar系列三、标准和规范篇（4）RTE</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="flechazo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">flechazo</p><div class="description" itemprop="description">我在人间贩卖星光</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">192</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">44</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">41</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fnb25pMzdD" title="https://github.com/Agoni37C"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" title="https://www.zhihu.com/people/jiu_sheng"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvcGxheWxpc3Q/aWQ9NzE3NTI4NzIwNQ==" title="https://music.163.com/#/playlist?id=7175287205"><i class="ic i-cloud-music"></i></span> <span class="exturl item weixin" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vbXAvaG9tZXBhZ2U/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZoaWQ9MiZzbj05ZThkZGVkOGU3MTgxYTA4YTA1MjFiOTQ2MjIyY2Q3MiZzY2VuZT0xOCN3ZWNoYXRfcmVkaXJlY3Q=" title="http://mp.weixin.qq.com/mp/homepage?__biz=MzAxODM2NTQ0Nw==&amp;hid=2&amp;sn=9e8dded8e7181a08a0521b946222cd72&amp;scene=18#wechat_redirect"><i class="ic i-address-card"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxODc1ODQ0P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https://space.bilibili.com/441875844?spm_id_from=333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAwLw=="><i class="ic i-home"></i>首页</span></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>小伙伴们</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAxLw=="><i class="ic i-magic"></i>导航页🚀</span></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>小天地🍼</a><ul class="submenu"><li class="item"><a href="/broken-thoughts/" rel="section"><i class="ic i-heart"></i>碎碎念</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAyLw=="><i class="ic i-heart"></i>云小🎪盘</span></li><li class="item"><a href="/mypages/Videoparse/" rel="section"><i class="ic i-heart"></i>视频解析</a></li><li class="item"><a href="/movies/" rel="section"><i class="ic i-heart"></i>影集</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA5Lw=="><i class="ic i-heart"></i>游戏🎮小站</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA2Lw=="><i class="ic i-heart"></i>动感天地🎶</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAzLw=="><i class="ic i-heart"></i>4k壁纸❄</span></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>有趣单页</a><ul class="submenu"><li class="item"><a href="/mypageslayout/barrage/" rel="section"><i class="ic i-list-alt"></i>弹幕墙</a></li><li class="item"><a href="/mypages/crossing-the-cliff/" rel="section"><i class="ic i-th"></i>圣诞老人过桥</a></li><li class="item"><a href="/mypages/eat/" rel="section"><i class="ic i-tags"></i>今天吃什么</a></li><li class="item"><a href="/mypages/clock/" rel="section"><i class="ic i-list-alt"></i>好看的闹钟</a></li><li class="item"><a href="/mypages/QQpage/" rel="section"><i class="ic i-list-alt"></i>QQ展示页</a></li><li class="item"><a href="/mypages/jianli/" rel="section"><i class="ic i-th"></i>简历</a></li><li class="item"><a href="/mypages/love/" rel="section"><i class="ic i-tags"></i>执子之手</a></li><li class="item"><a href="/mypages/tiangou/" rel="section"><i class="ic i-list-alt"></i>舔狗语录</a></li><li class="item"><a href="/mypages/washing/" rel="section"><i class="ic i-th"></i>洗衣机</a></li><li class="item"><a href="/mypages/todolist/" rel="section"><i class="ic i-tags"></i>行动清单</a></li><li class="item"><a href="/mypages/yindao2/" rel="section"><i class="ic i-list-alt"></i>引导页</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/microcosm/" title="分类于 小世界✨">小世界✨</a> <i class="ic i-angle-right"></i> <a href="/categories/microcosm/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/" title="分类于 自我提升">自我提升</a></div><span><a href="/archives/a1c393ed.html" title="【自我提升】我的MBTI人格测试">【自我提升】我的MBTI人格测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/python/" title="分类于 python">python</a></div><span><a href="/archives/b189bf4.html" title="用python实现批量post请求">用python实现批量post请求</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/AUTOSAR/" title="分类于 AUTOSAR">AUTOSAR</a></div><span><a href="/archives/7cac95ec.html" title="小柴带你学AutoSar系列一、基础知识篇（4）编译">小柴带你学AutoSar系列一、基础知识篇（4）编译</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microcosm/" title="分类于 小世界✨">小世界✨</a> <i class="ic i-angle-right"></i> <a href="/categories/microcosm/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/" title="分类于 自我提升">自我提升</a></div><span><a href="/archives/7ab3c68a.html" title="我的日记【flechazo】">我的日记【flechazo】</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/english/" title="分类于 english">english</a> <i class="ic i-angle-right"></i> <a href="/categories/english/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E8%8B%B1%E8%AF%AD/" title="分类于 从零开始学英语">从零开始学英语</a></div><span><a href="/archives/3f3ebf6e.html" title="🍗50个实用肉食快餐单词-海鲜甜点英文">🍗50个实用肉食快餐单词-海鲜甜点英文</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blog/" title="分类于 blog🌮">blog🌮</a> <i class="ic i-angle-right"></i> <a href="/categories/blog/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/archives/5be07a54.html" title="🥨将Hexo部署到自己的服务器上🥨">🥨将Hexo部署到自己的服务器上🥨</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F/" title="分类于 嵌入式">嵌入式</a></div><span><a href="/archives/363bdf24.html" title="嵌入式软件开发知识总结">嵌入式软件开发知识总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%F0%9F%95%B3/" title="分类于 踩过的坑🕳">踩过的坑🕳</a></div><span><a href="/archives/37a91de3.html" title="⛄hexo中sitemap-xml-error-xmlParseEntityRef-no-name-的解决方法☃">⛄hexo中sitemap-xml-error-xmlParseEntityRef-no-name-的解决方法☃</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/6bbd33c4.html" title="小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（3）CadencePCB系统设计">小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（3）CadencePCB系统设计</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/microcosm/" title="分类于 小世界✨">小世界✨</a> <i class="ic i-angle-right"></i> <a href="/categories/microcosm/%E9%82%A3%E4%BA%9B%E5%8A%A8%E4%BA%BA%E5%BF%83%E5%BC%A6%E7%9A%84%E5%8F%A5%E5%AD%90/" title="分类于 那些动人心弦的句子">那些动人心弦的句子</a></div><span><a href="/archives/42fd5ff.html" title="🍜珍惜时间">🍜珍惜时间</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">© 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">flechazo @ flechazo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">906k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">13:44</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> &amp; Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL={path:"archives/fd244a42.html",favicon:{show:"flechazo",hide:"(´Д｀)客官别走！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html><!-- rebuild by hrmmi -->