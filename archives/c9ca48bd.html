<!-- build time:Mon Feb 10 2025 22:46:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><script src="http://echarts.baidu.com/dist/echarts.common.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/map/js/china.min.js"></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="yandex-verification" content="fadb7324b0f3dbe2"><link rel="alternate" type="application/rss+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/atom.xml"><link rel="alternate" type="application/json" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="AUTOSAR,嵌入式,软件开发"><link rel="canonical" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c9ca48bd.html"><title>小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement - AUTOSAR - 技术教程🎃 | flechazo = 我在人间贩卖黄昏，只为收集世间温柔遇见你. = 有幸来到人间的旅人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement</h1><div class="meta"><span class="item" title="创建时间：2024-08-31 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+08:00">2024-08-31</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">flechazo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/archives/c9ca48bd.html../../../wallpaper/11.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/" itemprop="item" rel="index" title="分类于 技术教程🎃"><span itemprop="name">技术教程🎃</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/AUTOSAR/" itemprop="item" rel="index" title="分类于 AUTOSAR"><span itemprop="name">AUTOSAR</span></a><meta itemprop="position" content="2"></span></div><article itemscope="" itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c9ca48bd.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="flechazo"><meta itemprop="description" content="有幸来到人间的旅人, 我在人间贩卖星光"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="我在人间贩卖黄昏，只为收集世间温柔遇见你."></span><div class="body md" itemprop="articleBody"><p></p><div class="links"><div class="item" title="【知乎】flechazo" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=">【知乎】flechazo</span><p class="desc">https://www.zhihu.com/people/jiu_sheng</p></div></div></div><p></p><p></p><div class="links"><div class="item" title="【CSDN】小柴带你学AutoSar总目录" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">【CSDN】小柴带你学AutoSar总目录</span><p class="desc">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p></div></div></div><p></p><p>Autosar 系列教程：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==">小柴带你学 AutoSar 总目录</span></p><h1 id="小柴带你学autosar系列三-标准和规范篇3modemanagement"><a class="anchor" href="#小柴带你学autosar系列三-标准和规范篇3modemanagement">#</a> 小柴带你学 AutoSar 系列三、标准和规范篇（3）ModeManagement</h1><p>宝子们，我来啦</p><p>虽迟但到哈哈哈😜</p><p>一个人的精力果然是有限的</p><p>最近在搬家哈哈哈😋</p><p>只要坚持下去就可以打败 99.99% 的人了✌️</p><p>主打一个默默无闻</p><h1 id="modemanagementguide"><a class="anchor" href="#modemanagementguide">#</a> ModeManagementGuide</h1><h2 id="2-overall-mechanisms-and-concepts"><a class="anchor" href="#2-overall-mechanisms-and-concepts">#</a> 2 Overall mechanisms and concepts</h2><blockquote><p>A mode can be seen as the current state of an ECU1 wide, global variable, which is maintained by the RTE respectively the Schedule Manager.</p></blockquote><p>一个代表 ECU 当前状态的全局变量是由 RTE 和调度管理器维护</p><blockquote><p>Modes can be used for different purposes.</p><p>First of all modes are used to synchronize Software Components and Basic Software Modules. Via modes specified triggers can be enabled and disabled, and consequently the activation of Executable Entitys can be prevented.</p><p>Also Executable Entitys can be triggered explicitely during a Mode Switch.</p><p>On the other hand mode switches can explicitly trigger executable entities during transition from one mode to another. For example the RTE can activate an OnEntry ExecutableEntity to initialize acertain resource before entering a specific mode. In this mode the triggers of this ExecutableEntity are activated. If the mode is left the OnExit ExecutableEntity is called, which could execute some cleanup code and the triggers would be deacti vated.</p></blockquote><p>模式管理有如下几个目的：</p><ul><li>可以同步 SWC 和 BSW<ul><li>通过使能和失能特殊的触发器来执行或禁止相应的运行实体</li><li>此外运行实体在模式切换期间显示触发</li></ul></li></ul><p>这里对自己写代码也有一些感触了，就是代码写好之后，通过模式切换来触发函数，这样架构师就可以将代码分配给 Coder，之后架构师通过模式管理来组织代码的执行。当然啦，初始化也是一个状态切换哦！</p><h3 id="21-declaration-of-modes"><a class="anchor" href="#21-declaration-of-modes">#</a> 2.1 Declaration of modes</h3><p>例如：</p><blockquote><p>ECU state management there may exist the ModeDeclarations</p><ul><li>STARTUP,</li><li>RUN</li><li>POST_RUN</li><li>SLEEP</li></ul></blockquote><h3 id="22-mode-managers-and-mode-users"><a class="anchor" href="#22-mode-managers-and-mode-users">#</a> 2.2 Mode managers and mode users</h3><p>两个模式：管理者模式 和 用户模式</p><blockquote><p>Responsible for switching modes are <em>Mode managers</em>, which are the only instances able to change the value of the global variable.</p></blockquote><p>也就是说要单独将模式管理做成软件组件的形式</p><h3 id="23-modes-in-the-rte"><a class="anchor" href="#23-modes-in-the-rte">#</a> 2.3 Modes in the RTE</h3><p>每个组件都有模式管理接口</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240831180708672.png" alt="image-20240831180708672"></p><h3 id="24-modes-in-the-basic-software-scheduler"><a class="anchor" href="#24-modes-in-the-basic-software-scheduler">#</a> 2.4 Modes in the Basic Software Scheduler</h3><blockquote><p>Another possibility for a Basic Software Module acting as a Mode user to get informed about mode switches, is to register a BSW Module Entry, which is triggered by a Mode Switch Event (see also [3]).</p></blockquote><p>这里也有另一种设想，模式的切换的逻辑都是固定的，那么是否可以将模式和模式的入口出口都通过注册的机制来处理，这样就无需再多写模式切换的逻辑了。说干就干<a href="">之后会设计一个注册机制的模式管理框架</a></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240807115103069.png" alt="image-20240807115103069"></p><h3 id="25-communication-of-modes"><a class="anchor" href="#25-communication-of-modes">#</a> 2.5 Communication of modes</h3><p>分为：</p><ul><li>Mode Switch</li><li>Mode Request</li></ul><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240831180853675.png" alt="image-20240831180853675"></p><h2 id="3-configuration-of-the-basic-software-modemanager"><a class="anchor" href="#3-configuration-of-the-basic-software-modemanager">#</a> 3 Configuration of the Basic Software Modemanager</h2><h3 id="32-semantics-of-bswm-configuration-interfaces-and-behavioral-aspects"><a class="anchor" href="#32-semantics-of-bswm-configuration-interfaces-and-behavioral-aspects">#</a> 3.2 Semantics of BswM Configuration: Interfaces and behavioral aspects</h3><blockquote><p>In general the BswM can be seen as a state machine, which is defined by its interface and a behavioral description. The input actions of this state machine are mode requests. Each mode request is described in the ECU configuration of the BswM as a BswMModeRequestSource. These mode requests can be of different types (C-API calls, mode requests via RTE, mode notifications via RTE, etc.) but internally they are treated in the same way.</p><p>If a mode is requested the internal mirror of this BswMModeRequestSource is updated and depending on the configuration a rule evaluation is triggered, which results in the execution of predefined action lists. Action lists group Actions. Typically an action is a triggering of a mode switch in the RTE or Schedule Manager, but there are also predefined actions which change the status of some Basic Software Module.</p></blockquote><p>总的来说，BswM 可以被看作是一个状态机，它由其接口和行为描述定义该状态机的输入操作是模式请求。每个模式请求在 BswM 的 ECU 配置中作为 BswMModeRequestSource 进行描述。这些模式请求可以是不同类型 (C-API 调用，通过 RTE 发送的模式请求，通过 RTE 发送模式通知等)，但它们在内部以相同的方式处理。<br>如果请求模式，则此 BswMModeRequestSource 的内部镜像将进行更新并且根据配置触发规则评估，从而导致执行预定义的动作列表。动作列表将动作分组。通常，动作是触发 RTE 或调度管理器中的模式切换，但也有预定义的动作，可以更改某些基本软件模块的状态。</p><p><strong>Interface of the BswM</strong></p><blockquote><p>The interface is defined by the BswMModeRequestSource and the BswMActionListItem containers.</p></blockquote><p>BswM 的接口有两个</p><ul><li>BswMModeRequestSource</li><li>BswMActionListItem</li></ul><p><strong>Mode Requests</strong></p><p>BswMModeRequestSource 是一个可选的容器</p><p><strong>Available Actions</strong></p><p>伪代码</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token function">EcuM_SetState</span><span class="token punctuation">(</span>EcuM_StateType State<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>modeGroup EcuM_StateType <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ECUM_STATE_STARTUP<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    ECUM_STATE_APP_RUN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    ECUM_STATE_APP_POST_RUN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ECUM_STATE_SHUTDOWN<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    ECUM_STATE_SLEEP</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p>后面又一堆无聊的伪代码</p><p><strong>Configuration of the BswM behavior</strong></p><blockquote><p>The behavior of the BswM is specified via rules and action lists. A rule is a logical expression, which combines the current values of ModeRequestTypeMaps. The evaluation of each rule either results in the execution of its true or false action lists.</p></blockquote><p>BswM 的行为是通过规则和操作列表来指定的。规则是一个逻辑表达式，它结合了 ModeRequestTypeMaps 的当前值。对每个规则的评估要么导致其真或假操作列表的执行。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240807151000055.png" alt="image-20240807151000055"></p><blockquote><p>The ModeControlContainer contains these ActionLists. An ActionList can consist of a set of atomic actions, other “nested” ActionLists or it can reference (nested) rules which are then evaluated in the context of this Actionlist.</p></blockquote><p>ModeControlcontainer 包含这些 ActionLists。ActionList 可以由一组原子操作、其他 “嵌套 ActionLists 或引用 (嵌套) 规则组成，然后在此 Actionlist 的上下文中进行评估。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240807151015607.png" alt="image-20240807151015607"></p><h3 id="33-ecu-state-management"><a class="anchor" href="#33-ecu-state-management">#</a> 3.3 ECU state management</h3><blockquote><p>During startup and shutdown the task of the BswM is to initialize all basic software modules in a similar way as it is done by the ECUM in older AUTOSAR releases. To achieve this the following ModeDeclarationGroup is defined, which indicates the overall state of the ECU to application software components and is used for internal rule arbitration.</p></blockquote><p>在启动和关闭期间，BswM 的任务是初始化所有基本软件模块，其方式与早期 AUTOSAR 版本中的 ECUM 类似。为了实现这一点定义了以下 ModeDeclarationGroup，它指示 ECU 对应用软件组件的总体状态，并用于内部规则仲裁。</p><pre><code class="language-C">modeGroup MDG_EcuMode {
    ECU_RUN,
    ECU_APP_RUN,
    ECU_APP_POST_RUN,
    ECU_GO_SLEEP,
    ECU_GO_OFF_ONE,
    ECU_SLEEP,
    ECU_GO_OFF_TWO,
    ECU_STARTUP_ONE,
    ECU_STARTUP_TWO,
    ECU_RESET_READY
}
interface modeSwitch MSIF_EcuMode {
    mode MDG_EcuMode ecuMode
}
</code></pre><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240807180720010.png" alt="image-20240807180720010"></p><h3 id="34-communication-management"><a class="anchor" href="#34-communication-management">#</a> 3.4 Communication Management</h3><blockquote><p>Besides parts of the ECU state management, the BswM is also responsible for parts of the communication management. This section describes the functionality of the BswM, which is related to the Communication Stack of AUTOSAR. This covers but is not restricted to the following uses cases.</p><ul><li>Starting and stopping of IPDU Groups in general</li><li>Partial Networking</li><li>Diagnostic use cases which influence the communication of an ECU. e.g. it might be necessary to set the FlexRay State manager to passive mode via FrSm_SetEcuPassive() when requested by an application.</li><li>Service Discovery Control for Appplication SWCs</li></ul><p>To fulfill the requested functionality the BswM has ModeRequestSources to</p><ul><li>the Communication Manager</li><li>the bus state managers</li><li>AUTOSAR COM</li><li>Service Discovery</li></ul></blockquote><p>除了 ECU 状态管理的一部分外，BswM 还负责通信管理的一部分。本节描述了 BswM 的功能，该功能与 AUTOSAR 的通信堆栈有关。这包括但不限于以下用例。</p><p><strong>Partial Network Cluster</strong></p><blockquote><p>A Partial Network Cluster (PNC) is a (logical) group of ECUs which have to be active at the same time to realize some distributed functionality. A PNC can be assigned to one or multiple users (configuration in ComM) and specific software components can request or release communication for a PNC by requesting the communication mode of a user mapped to the PNC. ComM implements a state machine for each partial network cluster (PNC) and each PNC has its own state. For a simple mapping, the PNC state definitions are related to the states of ComM.</p></blockquote><p>部分网络集群 (PNC) 是 (逻辑) ECU 组，这些 ECU 必须同时处于活动状态才能实现某些分布式功能。PNC 可以分配给一个或多个用户 (在 ComM 中进行配置)，特定的软件组件可以通过请求映射到 PNC 的用户通信模式来请求或释放 PNC 的通信。ComM 为每个部分网络集群 (PNCS) 实现一个状态机，每个 PNC 都有自己的状态。对于简单的映射，PNC 状态定义与 ComM 的状态相关。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240808104459145.png" alt="image-20240808104459145"></p><blockquote><p>The status of all PNCs on the nodes of a system channel is exchanged within the so-called PNC bit vector via a network management message (NM message).</p></blockquote><p>系统信道节点上的所有 PNC 的状态通过网络管理消息 (NM 消息) 在所谓的 PNC 位矢量内交换。</p><blockquote><p>Each PNC uses a dedicated bit position within a bit vector (PNC bit vector) transferred by a NM message on CAN, FlexRay and Ethernet. If a PNC is requested by a local ComM user on the node, the node sets the corresponding PNC bit in the PNC bit vector to 1. If the PNC is not requested anymore; the node sets the corresponding PNC bit in the PNC bit vector to 0. (Please note: If the optional feature "Synchronized PNC shutdown" is used and a PN shutdown messages has to be transmitted, the PNC bits are set to 1 for the PNCs which are released and the remaining PNC bits are set to 0). The &lt;Bus&gt;Nm extract the PNC bit vector from a received NM-PDU and forward the PNC bit vector to the NM interface. The Nm interface module collects and aggregates PNC requests.</p></blockquote><p>每个 PNC 在由 CAN、FlexRay 和以太网上的 NM 消息传输的位向量 (PNC 位向量) 中都使用一个专用位。如果节点上的本地 ComM 用户请求 PNC，则节点将 PNC 位向量中的相应 PNC 位设置为 1。如果不再需要 PNC，则节点会将 PNC 位向量的相应 PNC 位设为 0。(请注意：如果使用了可选功能 “同步 PNC 关闭” 并且必须发送 PN 关闭消息，则已释放的 PNC 的 PNC 位将设置为 1，其余的 PNC 位将设为 0)。&lt;Bus&gt;Nm 从接收到的 NM-PDU 中提取 PNC 位向量并将 PNC 位矢量转发到 NM 接口。Nm 接口模块收集和汇总 PNC 请求。</p><blockquote><p>Each PNC uses the same bit position in the PNC bit vector on every system channel within the NM message. ComM uses 3 types of PNC bit vector named External and Internal Request Array (<strong>EIRA</strong>), External Request Array (<strong>ERA</strong>) and <strong>I</strong>nternal Request Array (<strong>IRA</strong>) to exchange PNC status information with NM interface and &lt;Bus&gt;Nms.</p></blockquote><p>有三种类型</p><ul><li>External and Internal Request Array (<strong>EIRA</strong>) 外部中断请求阵列</li><li>External Request Array (<strong>ERA</strong>) 外部请求阵列</li><li><strong>I</strong>nternal Request Array (<strong>IRA</strong>) 内部请求阵列</li></ul><blockquote><p>Partial networking is supported on the bus types CAN, FlexRay and Ethernet. Activation and deactivation of the I-PDU groups of the PNCs on a CAN, FlexRay and Ethernet node is required to control the communication capabilities considering the current state of the PNC and to avoid false timeouts in the system.</p></blockquote><p>部分网络支持 CAN、FlexRay 和以太网总线类型。在 CAN、Flex-Ray 和以太网节点上，需要对 PNC 的 I-PDU 组进行激活和失活，以控制通信能力，考虑到 PNC 的当前状态，并避免系统中的错误超时。</p><blockquote><p>Starting and stopping of I-PD groups in COM are handled in BswM. I-PDU-Groups shall be started if the corresponding PNC is internally or externally requested. As soon as a PNC is neither internally norexternally requested, the corresponding I-PDU-Group shall be stopped.</p></blockquote><p>COM 中的 I-PDU 组启动和停止由 BswM 处理。如果相应的 PNC 内部或外部请求，则应启动相应的 I-PDU-Group，一旦 PNC 既没有内部请求也没有外部请求，则应停止相应的 I-PDU 群组。</p><blockquote><p>Internal PNC requests indicate communication needs locally on the ECU and are also called "active PNC request". External PNC requests indicate communication needs of a remote ECU in the network and are also called "passive PNC request".</p></blockquote><p>内部 PNC 请求指示 ECU 上的本地通信需求，也称为 “主动 PNC 请求”。</p><p>外部 PNC 请求指示网络中远程 ECU 的通信需求，也称为 “被动 PNC 请求”。</p><blockquote><p>The logic to control I-PDU-Groups is handled as interaction between ComM and BswM. ComM indicates the current state of a particular PNC state machine to BswM.</p></blockquote><p>控制 I-PDU - 群的逻辑是作为 ComM 和 BswM 之间的交互处理的。ComM 向 BswM 表示特定 PNC 状态机的当前状态。</p><blockquote><p>The BswM controls the corresponding I-PDU groups by means of mode arbitration and mode control. Please note, deactivation of single FlexRay ECUs is not possible.</p></blockquote><p>BswM 通过模式仲裁和模式控制来控制相应的 I-PDU 组。请注意，单个 FlexRayECU 是不可用的。因为 FlexRay 是严格基于时间传输的，需要至少两个节点才可以正常通信。</p><blockquote><p>The PNC Gateway feature is used to span (logical) partial network clusters across bus / communication channel boundaries, "gatewaying" PNC requests from one bus/net work to the others.</p></blockquote><p>PNC 网关功能用于跨越总线 / 通信信道边界的 (逻辑) 部分网络集群，将 PNC 请求从一个总线 / 网络 “网关化” 到其他网络。</p><blockquote><p>The PNC Gateway collects PNC requests from all of its multiple active channels (which are called active since it actively keeps them awake, if required) and aggregates them.</p></blockquote><p>PNC 网关从其所有多个活动通道 (这些通道被称为活动通道，因为如果需要，它会主动保持它们处于清醒状态) 收集 PNC 请求并对其进行汇总。</p><blockquote><p>The PNC Gateway sends the aggregated PNC state in the network to all its active channels, which causes all nodes to have the same view on the global PNC request state as the gateway.</p></blockquote><p>PNC 网关将网络中聚合的 PNC 状态发送到其所有活动信道，这使得所有节点对全局 PNC 请求状态具有与网关相同的视图。</p><blockquote><p>If the PNC Gateway is not the topmost PNC Gateway in the network hierarchy, the PNC Gateway will also send the aggregated PNC request state of all subordinate nodes, plus its own internal request state, to its superior PNC coordinator, which is connected via the so-called connector type "passive".</p></blockquote><p>如果 PNC 网关不是网络层次结构中的最高 PNC 网关，则 PNC 网关还将发送所有子节点的聚合 PNC 请求状态以及它自己的内部请求状态到其上级 PNC 协调器，该协调器通过所谓的 “被动” 连接器类型连接。</p><blockquote><p>The superior PNC coordinators will aggregate the subordinate coordinators PNC request states, so the top-level coordinator will know about all active PNC requests in the network, and send that info to the subordinate nodes.</p></blockquote><p>上级 PNC 协调器将聚合下属协调器的 PNC 请求状态，因此顶级协调器将了解网络中所有活动的 PNC 请求，并将该信息发送到子节点。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240808175912278.png" alt="image-20240808175912278"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240808180646651.png" alt="image-20240808180646651"></p><p><strong>Aggregation of internal and external Partial Network Cluster</strong></p><p>内部和外部的网络集群的聚合</p><blockquote><p>This feature is used by every ECU that is member of a Partial Network Cluster (PNC).</p><ul><li>Active PNC requests are forwarded by the ComM via the Nm to the &lt;Bus&gt;Nms.</li><li>Passive PNC requests are received by the &lt;Bus&gt;Nms and forwarded to the Nm.</li></ul></blockquote><p>作为部分网络集群 (PNC) 成员的每个 ECU 都使用此功能。</p><ul><li>主动 PNC 请求由 ComM 通过 Nm 转发到 &lt;Bus&gt;Nm。</li><li>&lt;Bus&gt;Nm 接收被动 PNC 请求并将其转发给 Nm。</li></ul><blockquote><p>Nm handles received PNC request with respect to a so-called PN filter mask. The PN filter mask define which of the received PNC requests are relevant. Nm collects and maintains internal and external PNC requests.</p></blockquote><p>Nm 处理接收到的与 PN 过滤器掩码相关的 PNC 请求。PN 过滤器掩码定义了哪些接收到的 PNC 请求是相关的。Nm 收集和维护内部和外部 PNC 请求。</p><blockquote><p>The aggregation of internal and external requested PNCs is called "External Internal Request Array (EIRA)".</p></blockquote><p>内部和外部请求的 PNC 的汇总称为 “外部内部请求阵列 (EIRA)</p><blockquote><p>Changes of the EIRA are forwarded by Nm to ComM. ComM needs this information to handle changes in the corresponding PNC state machines.</p></blockquote><p>EIA 的更改由 Nm 转发到 ComM。ComM 需要此信息来处理相应 PNC 状态机中的更改。</p><blockquote><p>The provided information of a request change (PNC request changed from requested to released and vice versa) to ComM at (almost) the same time on every ECU, results to switch the I-PDU-Groups synchronously on all direct connected ECUs.</p></blockquote><p>在每个 ECU 上 (几乎) 同时向 ComM 提供的请求更改 (PNC 请求从请求变为释放反之亦然) 信息导致在所有直接连接的 ECU 上同步切换 I-PDU 组。</p><blockquote><p>Therefore the Nm maintain timers (so-called PNC reset timer) of each PNC request in the EIRA.</p></blockquote><p>因此，Nm 在 EIRA 中维护每个 PNC 请求的定时器 (即 PNC 复位定时器)</p><blockquote><p>The PNC reset timer is restarted every time the corresponding PNC is requested within received PNC bit vector and every time the corresponding PNC request is transmitted.</p></blockquote><p>每次在接收到的 PNC 位矢量内请求对应的 PNC 以及每次发送对应的 PNC 请求时，都会重新启动 PNC 复位定时器。</p><p><strong>Aggregation of external Partial Network Cluster</strong></p><p>外部的网络集群的聚合</p><blockquote><p>This feature is used by the ECUs where the PNC Gateway functionality is enabled to collect the external PNC requests per channel.</p></blockquote><p>此功能由启用 PNC 网关功能的 ECU 使用，以收集每个通道的外部 PNC 请求。</p><blockquote><p>The external PNC requests have to be coordinated across all affected channels. The logic of the PNC coordination is provided by ComM.</p></blockquote><p>外部 PNC 请求必须通过所有受影响的通道进行协调。PNC 协调的逻辑由 ComM 提供。</p><blockquote><p>There, for each channel it is configured if it is actively or passively coordinated.</p></blockquote><p>对于每个通道，如果它是主动协调还是被动协调，都会进行配置。</p><blockquote><p>On actively coordinated channels, external PNC requests are mirrored back to the channel where the PNC request was received and also forwarded to all other coordinated channels (either passively or actively coordinated) where this PNC is assigned to.</p></blockquote><p>在主动协调的通道上，外部 PNC 请求被镜像回接收 PNC 请求的通道，并转发到分配有该 PNC 的所有其他协调通道 (无论是被动协调还是主动协调)。</p><blockquote><p>On passive coordinated channels external PNC requests are forwarded to other actively coordinated channels where this PNC is assigned to without mirroring back on the channel from where the external PNC request was received.</p><p>This avoids endless mirroring of partial network cluster requests,</p></blockquote><p>在被动协调通道中，外部 PNC 请求被转发到其他主动协调通道，该 PNC 也会被分配给主动协调通道，而不会在接收外部 PNC 请求的通道中镜像回来。这避免了部分网络集群请求的无休止的反射。</p><blockquote><p>if 2 ECUs have PNC Gateway functionality enabled and are connected to the same channel.</p><p>The Nm module provides the information if PNCs are externally requested or released to ComM and manages the PNC timer handling for each relevant PNC and per channel.</p><p>The aggregated state of the external requested PNCs is called "External Request Array" (ERA).</p></blockquote><p>如果两个 ECU 启用了 PNC Gateway 功能并连接到同一信道，则 Nm 模块会在外部向 ComM 请求或释放 PNC 时提供这些信息，并管理每个相关 PNC 和每个信道的 PNC 定时器处理。外部请求的 PNC 的聚合称为 “外部请求阵列”(ERA)</p><p><strong>Synchronized PNC shutdown</strong></p><p>PNC shutdown 的同步</p><blockquote><p>In order to avoid timeout failure on application level, the PNC shall shutdown in a synchronized way (all nodes in the PNC will shutdown at the same point in time).</p></blockquote><p>为了避免应用层的超时故障，PNC 应以同步方式关闭 (PNC 中的所有节点将在同一时间点关闭)。</p><blockquote><p>The synchronized PNC shutdown is a functionality which is a cooperation of ComM, Nm and &lt;Bus&gt;Nm to ensure a synchronized PNC shutdown at almost the same point in time across the whole PN topology.</p></blockquote><p>同步 PNC 关闭是一个由 ComM、Nm 和 总线 Nm 共同实现的功能 &lt;Bus&gt;，可确保在整个 PN 拓扑中几乎相同的时间点同步 PNC 关断。</p><blockquote><p>A synchronized PNC shutdown is handled by ECUs in role of a top-level PNC coordinator or intermediate PNC coordinator if the PNC Gateway is enabled.</p></blockquote><p>如果 PNC 网关处于启用状态，则由 ECU 充当顶级 PNC 协调器或中间 PNC 协调器处理同步 PNC 关闭。</p><blockquote><p>If the ComM of an ECU in the role of a top-level PNC coordinator detects that a PNC is released (PNC is no longer internally or externally requested), the ComM requests a synchronized PNC shutdown.</p></blockquote><p>如果充当顶级 PNC 协调整个 ECU 的 ComM 检测到 PNC 释放 (PNC 内部或外部请求不再存在)，则 ComM 请求同步 PNC 关闭</p><blockquote><p>The Nm module stores all requests and handles them in the context of the Nm_Mainfunction. The Nm module indicates the affected &lt;Bus&gt;Nms regarding an activated PNC shutdown process.</p></blockquote><p>Nm 模块存储所有请求，并在 Nm_Mainfunction 函数中处理它们。Nm 模块指示与已激活的 PNC 关机过程有关的受影响的 &lt;Bus&gt;Nm。</p><blockquote><p>The &lt;Bus&gt;Nms call the Nm module to provide the aggregated requests for a synchronized PNC shutdown as PNC bit vector per given NM-Channel.</p></blockquote><p>&lt;Bus&gt;Nms 调用 Nm 模块，以便以每个给定的 NM 信道的 PNC 位向量的形式提供对同步 PNC 关机的聚合请求。</p><blockquote><p>The &lt;Bus&gt;Nms use the provided PNC bit vector to assemble a NM-PDU as PN shutdown message and transmit this message on the according NM channel.</p></blockquote><p>&lt;Bus&gt;Nm 使用提供的 PNC 位矢量来组装 NM-PDU 作为 PN 关闭消息，并在相应的 NM 通道上传输该消息。</p><blockquote><p>If a PN shutdown message is received by an ECU in the role of an intermediate PNC coordinator, the &lt;Bus&gt;Nms extract the PNC bit vector from the received PN shutdown message and forwards the information by calling the callback function Nm_ForwardSynchronizedPncShutdown.</p></blockquote><p>如果中间 PNC 协调器角色中的 ECU 接收到 PN 关闭消息，则 &lt;Bus&gt;Nms 从接收到的 PN 关闭消息中提取 PNC 位向量，并通过调用回调函数 Nm_ForwardSynchronizedPncShutdown 来转发该信息。</p><blockquote><p>The callback function will immediately forward the indication to ComM by calling ComM_Nm_ForwardSynchronizedPncShutdown. ComM will immediately request a synchronized PNC shutdown of all actively PNC coordinated (coordinated by a PNC gateway) ComMChannels.</p></blockquote><p>回调函数将立即通过调用 ComM_Nm_ForwardSynchronizedPncShutdown 将指示转发到 ComM。ComM 将立即请求所有积极 PNC 协调 (由 PNC 网关协调) 的 ComMChannels 的同步 PNC 关闭。</p><blockquote><p>The requests for a synchronized PNC shutdown are forwarded to the Nm module per NM-Channel and handled in the same way as described in the previous section. If a PNC leaf node receives a PN shutdown message, then it will handle the message as a usual NM message (update the local PN info and reset PN reset time).</p></blockquote><p>同步 PNC 关闭请求通过 NM 通道转发到 Nm 模块，处理方式与前一节所述相同。如果 PNC 叶节点接收到 PN 关闭消息，则它将像处理常规 NM 消息一样处理该消息 (更新本地 PN 信息并重置 PN 复位时间)</p><p><strong>Scheduling of main functions</strong></p><blockquote><p>Since state changes of communication channels or PNCs are generally processed in the context of the main processing functions, it is important to properly consider the scheduling and the order of execution for the main processing functions for the modules involved in the communication and network management (ComM, Nm, &lt;Bus&gt;Nms).</p></blockquote><p>由于通信信道或 PNC 的状态变化通常在主处理功能的上下文中进行处理，因此正确考虑涉及通信和网络管理 (ComM、Nm、&lt;Bus&gt;Nms) 的模块的主处理功能的调度和执行顺序非常重要。</p><blockquote><p>ComM generally coordinates the activities considering the events in the system and triggers the required actions (by calling the relevant APIs) of the lower layers.</p></blockquote><p>ComM 通常会考虑系统中的事件来协调活动，并触发下层所需的动作 (通过调用相关的 API)。</p><blockquote><p>Events in the system causing specific actions required to be triggered by ComM can be internal requests of users (internal requests for channels or PNCs), passive/external requests for channels or PNCs or synchronized PNC shutdown messages received on the bus.</p></blockquote><p>系统中导致需要由 ComM 触发特定操作的事件可以是</p><ul><li>用户的内部请求 (对信道或 PNC 的内部请求)、</li><li>对信道或 PNC 的被动 / 外部请求</li><li>或在总线上接收到的同步 PNC 关闭消息。</li></ul><blockquote><p>External events may be caused by wakeup events, reception of cyclic NM messages or synchronized shutdown messages.</p></blockquote><p>外部事件可能由</p><ul><li>唤醒事件、</li><li>周期性 NM 消息的接收</li><li>或同步关机消息引起。</li></ul><blockquote><p>ComM receives and processes all internal and external requests</p></blockquote><p>ComM 接收和处理所有内部和外部请求</p><blockquote><p>and triggers required actions</p></blockquote><p>并触发必要的动作</p><blockquote><p>that will lead to state changes in the state machines for communication and network management modules</p></blockquote><p>这将引导通信和网络管理模块状态机的状态变化</p><blockquote><p>and consequently the transmission of cyclic NM messages or synchronized shutdown messages on the bus.</p></blockquote><p>从而在总线上传输循环 NM 消息或同步关闭消息。</p><blockquote><p>During integration of the modules, it must be considered that the processing of specific requests is done asynchronously in the basic software (e.g. transmission requests,some requests from the application)</p></blockquote><p>在集成模块时，必须考虑特定请求的处理在基本软件中异步完成 (例如传输请求、来自应用程序的某些请求)</p><blockquote><p>and also that specific actions may be processed decoupled in the context of the main processing cycle of the involved modules (e.g.transmission in the &lt;Bus&gt;Nms, processing of timers, state changes and notificationsto upper layers).</p></blockquote><p>并且特定操作可能在所涉及模块的主要处理周期的上下文中脱钩处理 (例如在 &lt; Bus&gt;Nms 中的传输、处理定时器、状态更改和通知给上层)。</p><p><strong>I-PDU Group Switching</strong></p><blockquote><p>For the I-PDU group switching it is expected that dedicated I-PDU groups for outgoing and incoming I-PDUs in COM exist for each channel or partial network.</p></blockquote><p>对于 I-PDU 组交换，预计每个通道或部分网络都存在用于 COM 中传入和传出 I-PDUs 的专用 I-PDU 组。</p><blockquote><p>AUTOSAR COM takes care that an I-PDU is active (started) if at least one I-PDU group containing this I-PDU is active.</p></blockquote><p>AUTOSAR COM 确保如果至少一个包含此 I-PDU 的 I-PDU 组处于活动状态，则 I-PDU 处于活动状态 (启动)</p><p>有两种组织方式</p><ul><li><strong>Channel related I-PDU Group Handling</strong></li><li><strong>PNC related I-PDU Group Handling</strong></li></ul><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240809114837791.png" alt="image-20240809114837791"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240809114845904.png" alt="image-20240809114845904"></p><p><strong>Channel related I-PDU Group Handling</strong></p><p><strong>Listing 3.18: ComM reports FULL_COMMUNICATION</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule channel1requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> ComM_Mode_Channel1 <span class="token operator">==</span> COMM_FULL_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	actionlist channel1requestedActions<span class="token comment">/* channel 1 */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>actions channel1requestedActions on condition <span class="token punctuation">{</span> <span class="token comment">/* channel 1 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        init true</pre></td></tr><tr><td data-num="9"></td><td><pre>        enable 	ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>CAN1IPDUS_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        		ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>CAN1IPDUS_RX</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="13"></td><td><pre>rule channel2requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> ComM_Mode_Channel2 <span class="token operator">==</span> COMM_FULL_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    	actionlist channel2requestedActions<span class="token comment">/* channel 2 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre>actions channel2requestedActions on condition <span class="token punctuation">{</span><span class="token comment">/* channel 2 */</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        init true</pre></td></tr><tr><td data-num="21"></td><td><pre>        enable 	ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>CAN2IPDUS_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        		ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>CAN2IPDUS_RX</pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>Listing 3.19: ComM reports SILENT_COMMUNICATION</strong></p><p><strong>Listing 3.20: ComM reports NO_COMMUNICATION</strong></p><p><strong>PNC related I-PDU Group Handling</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token comment">/* PNC 1 */</span></pre></td></tr><tr><td data-num="2"></td><td><pre>rule pnc1requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC1 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span> PNC1 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	actionlist pnc1requestedActions</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="7"></td><td><pre>actions pnc1requestedActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        init true</pre></td></tr><tr><td data-num="10"></td><td><pre>        enable 	ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC1IPDUS_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        		ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC1IPDUS_RX</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">/* PNC 2 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre>rule pnc2requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC2 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span> PNC2 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    	actionlist pnc2requestedActions</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="21"></td><td><pre>actions pnc2requestedActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        init true</pre></td></tr><tr><td data-num="24"></td><td><pre>        enable 	ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC2IPDUS_CH1_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC2IPDUS_CH1_RX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC2IPDUS_CH2_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC2IPDUS_CH1_RX</pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">/* PNC 3 */</span></pre></td></tr><tr><td data-num="32"></td><td><pre>rule pnc3requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC3 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span> PNC3 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        actionlist pnc3requestedActions</pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="37"></td><td><pre>actions pnc3requestedActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        init true</pre></td></tr><tr><td data-num="40"></td><td><pre>        enable 	ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC3IPDUS_TX<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        		ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>PNC3IPDUS_RX</pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>Listing 3.21: ComM reports PNC_REQUESTED or PNC_READY_SLEEP</strong></p><p><strong>Listing 3.22: ComM reports PNC_PREPARE_SLEEP</strong></p><p><strong>Listing 3.23: ComM reports PNC_NO_COMMUNICATION</strong></p><p><strong>J1939 Networkmanagement</strong></p><blockquote><p>In contrast to current AUTOSAR network management, the task of J1939 network management is not to handle sleep and wake-up of ECUs, but to assign unique addresses to each node represented by an ECU.</p></blockquote><p>与目前的 AUTOSAR 网络管理不同，J1939 网络管理的任务不是处理 ECU 的休眠和唤醒，而是为 ECU 代表的每个节点分配唯一地址。</p><blockquote><p>This is achieved by sending the AddressClaimed (AC, 0x0EE00) parameter group a start-up, which announces the desired address.</p></blockquote><p>这是通过向 AddressClaim (AC，OxOEE00) 参数组发送启动来实现的，该启动会宣布所需的地址。</p><blockquote><p>If another node claims the same address, and has higher priority, the node has to go silent after sending the Cannot ClaimAddress parameter group ((AddressClaim)AC with null address as SA), or try to use another address.</p></blockquote><p>如果另一个节点声称相同的地址，并且具有更高的优先级，则该节点必须在发送 CannotClaimAddress 参数组 (空地址为 SA 的 AC) 后保持沉默，或者尝试使用另一个地址。</p><blockquote><p>To support this use case the BswM is extended to accept state change indications from the J1939Nm via the API function BswM_J1939Nm_StateChangeNotification()(see also 3.2.2.2.15).</p></blockquote><p>为了支持此用例，BswM 扩展为通过 API 函数 BswM_J1939Nm_StateChangeNotification (另参见 3.2.1.2.2.15) 接受来自 l1939Nm 的状态变化指示。</p><blockquote><p>Depending on the state indicated by the network management the BswM needs to switch ComIPduGroups of COM, PduRRoutingPathGroups of PduR, and general request handling of the J1939Rm.</p></blockquote><p>根据网络管理所指示的状态，BswM 需要切换 COM 的 ComIPduGroups 、PduR 的 PduRRoutingPathGroups 以及 J1939 RM 的通用请求。</p><blockquote><p>The first two actions are realized via BswMPduGroupSwitch- and BswMPduRouter Control -actions. The J1939 Request Manager shall be switched using the BswMJ1939Rm action.</p><p>COM is expected to have IPDU groups containing all locally received and transmitted I-PDUs for each network. The PduR shall be configured in the same way, having RoutingPathGroups for all locally received and transmitted IPDUs for each channel, excluding the received I-PDU for the Request message forwarded to the J1939Rm.</p></blockquote><p>COM 应具有包含每个网络所有本地接收和传输的 IPDU 的 IPDU 组。PduR 应以相同的方式进行配置，具有用于每个信道所有本地接收和传输的所有 IPDU 的 RoutingPathGroups，但不包括转发到 J1939Rm 的请求消息的接收 IPDU。</p><blockquote><p>The BswM must then be configured to</p><p>然后，BSWM 必须配置</p><p>switch on and off the aforementioned IPDU groups</p><p>打开和关闭上述 IPDU 组</p><p>and PduRRoutingPathGroups depending on the reported NM states,</p><p>和依赖于 NM 状态的 PduRRoutingPathGroups</p><p>as well as general request handling of the J1939 Request Manager.</p><p>以及 J1939 请求管理器的一般请求处理。</p></blockquote><p><strong>J1939 diagnostic mode management</strong></p><blockquote><p>In addition to address assignment the BswM has also to supervise the sending of<br>broadcast messages in a J1939 environment. Each IPDU group represents the broadcast messages (J1939 PGs with PDU2 format PGN or PDU1 format PGN and broadcast destination address) of one network.</p></blockquote><p>除了地址分配之外，BswM 还必须监督 J1939 环境中的广播消息的发送。每个 IPDU 组表示一个网络的广播消息 (J1939 PGs，具有 PDU2 格式 PGN 或 PDU1 格式 PGN 和广播目标地址)</p><blockquote><p>For this purpose it is also expected that COM contains one IPDU group for each channel, which contains the broadcast messages of this ECU.</p></blockquote><p>为此，还希望 COM 为每个信道包含一个 IPDU 组，该组包含该 ECU 的广播消息。</p><p><strong>Listing 3.25: Rule to implement broadcast management according to J1939</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule J1939_broadcast_management initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> BswMJ1939DcmBroadcastStatus <span class="token operator">==</span> NETWORK_ENABLED<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	actionlist J1939ActivateBroadcastActions</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    	actionlist J1939DeactivateBroadcastActions</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre>actions J1939ActivateBroadcastActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        init true</pre></td></tr><tr><td data-num="11"></td><td><pre>        enable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>J1939BroadcastIPDUS</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="14"></td><td><pre>actions J1939DeactivateBroadcastActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    PduGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyCom<span class="token punctuation">.</span>J1939BroadcastIPDUS</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>LIN Schedule Table Switch</strong></p><blockquote><p>The BswM is able to switch the schedule tables LIN channels based on requests from Application SWCs.</p></blockquote><p>BswM 能够根据应用程序 SWC 的请求切换调度表 LIN 通道。</p><blockquote><p>The SWC requests a LIN schedule table from the BswM in form of an application mode. After the successful switch the BswM switches to the requested mode.</p></blockquote><p>SWC 以应用模式的形式向 BSWM 请求 LIN 调度表。成功切换后，Bswm 切换到所请求的模式。</p><blockquote><p>In the following, an example for this behavior is shown. At first, a ModeDeclarationGroup is needed which is used by the Application SWCs to request a certain schedule to which the LIN channel shall be switched.</p></blockquote><p>下面显示了这种行为的示例。首先，需要一个模式声明组，该组由应用程序 SWC 用于请求 LIN 通道应切换到的特定时间表。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>modeGroup MDG_LinScheduleTables <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Schedule1<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Schedule2</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>An enumeration containing the same values is needed for the SenderReceiverInterface between BswM and SWC.</p></blockquote><p>BSWM 和 SWC 之间的 SenderReceiverInterface 需要一个包含相同值的枚举。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">ENUM_LinScheduleTables</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Schedule1<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Schedule2</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>A ModeSwitchInterface is necessary to switch the application mode after the LIN schedule table was set.</p></blockquote><p>在设置 LIN 调度表后，必须使用 ModeSwitchInterface 来切换应用程序模式。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>interface modeSwitch LinScheduleMode <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	mode MDG_LinScheduleTables LinScheduleMode</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>Also a SenderReceiverInterface which uses the previously defined enumeration is needed. It can be used by the application SWC to request a mode that should lead to a LIN schedule table switch.</p></blockquote><p>此外，还需要使用先前定义的枚举的 SenderReceiverInterface。应用程序 SWC 可以使用它来请求引导 LIN 调度表切换状态。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>interface senderReceiver LinChannel1ScheduleTableRequestPort <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    data ENUM_LinScheduleTables LinScheduleMode</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>The following BswM rule switches the schedule table of a LIN channel when the application SWC request another application mode.</p></blockquote><p>当应用程序 SWC 请求另一个应用程序模式时，以下 BswM 规则是切换 LIN 通道的调度表。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule LinChannel1Schedule1Request initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LinChannel1ScheduleTableRequestPort <span class="token operator">==</span> Schedule1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	<span class="token function">LinScheduleSwitch</span><span class="token punctuation">(</span>LinSchedule1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>The following BswM rule switches the application mode to the mode which was previously requested by the application. It is triggered when the LinSM notifies the BswM that a LIN schedule table switch occurred.</p></blockquote><p>下列 BswM 规则将应用程序模式切换到先前由应用程序请求的模式。当 LINSM 通知 BSWM 发生了 LIN 调度表切换时，将触发该规则。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule LinChannel1Schedule1Switched initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LinSM_CurrentState <span class="token operator">==</span> LinSchedule1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	<span class="token function">RteSwitch</span><span class="token punctuation">(</span>LinScheduleMode<span class="token punctuation">,</span> Schedule1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>And finally the corresponding rules for the LIN schedule table LinSchedule2:</p></blockquote><p>最后为 LIN 进度表 LinSchedule2 提供了相应的规则:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule LinChannel1Schedule2Request initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LinChannel1ScheduleTableRequestPort <span class="token operator">==</span> Schedule2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    	<span class="token function">LinScheduleSwitch</span><span class="token punctuation">(</span>LinSchedule2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="7"></td><td><pre>rule LinChannel2Schedule1Switched initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LinSM_CurrentState <span class="token operator">==</span> Schedule2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    	<span class="token function">RteSwitch</span><span class="token punctuation">(</span>LinScheduleMode<span class="token punctuation">,</span> LinSchedule2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>Ethernet switch port group switching</strong></p><blockquote><p>For Ethernet switch port switching it is expected that EthSwtPorts are condensed to EthIfSwitchPortGroups. EthIfSwitchGroups could be derived from the SystemDescriptionExtract.</p></blockquote><p>对于以太网交换机端口交换，希望把 EthSwtPorts 压缩为 EthIfSwitchPortGroups。 EthIfSwitchGroups 可以从 SystemDescriptionExtract 中派生。</p><blockquote><p>According to the modelling each EthSwitchPortGroup is mapped to at least one PNC. The switching of EthIfSwitchPortGroup is realized with particular BswM rules.</p></blockquote><p>根据该模型，每个 EthSwitchPortGroup 被映射到至少一个 PNC。<br>EthIfSwitchPortGroup 的切换是用特定的 BswM 规则实现的。</p><blockquote><p>Therefore, ComM reports the current mode of a PNC via BswM_ComM_CurrentPNCMode. The mapping between PNCs and EthSwitchPortGroup is known by the BswM.</p></blockquote><p>因此，ComM 通过 BswM_ComM_CurrentPNCMode 报告 PNC 的当前模式。PNCs 与 EthSwitchPortGroup 之间的映射由在 BswM 这 。</p><blockquote><p>Thus, the BswM forward the reported current mode of a PNC to the EthIf by calling EthIf_SwitchPortGroupRequestMode with corresponding EthIfSwitchPortGroup.</p></blockquote><p><strong>因此，BSwM 通过调用具有相应 EthIfSwitchPortGroup 的 EthIf_SwitchPortGroupRequestMode 将报告的 PNC 当前模式转发到 Ethlf。</strong></p><blockquote><p>According to the given PortMode (either ETH_MODE_DOWN or ETH_MODE_ACTIVE) the EthIf manages the requests for EthIfSwitchPortGroups and decides to switch off or switch on EthSwtPorts.</p></blockquote><p>根据给定的 PortMode (ETH_MODE_DOWN 或 ETH_MODE_ACTIVE)，Ethlf 管理 EthIfSwitchPortGroups 的请求，并决定关闭或打开 EthSwtPorts。</p><blockquote><p>To illustrate how the switching of EthIfSwitchPortGroups can be managed the following scenario is created. The exemplary ECU shall have two partial networks (named PNC1 and PNC2) and two according EthIfSwtPortGroups (named EthIfSwtPortGroup1 and EthIfSwtPortGroup2) configured:</p></blockquote><p>为了说明如何管理 EthIfSwitchPortGroups 的切换，创建了以下场景。示例 ECU 应配置两个部分网络 (名称为 PNC1 和 PNC2) 和两个相应的 EthIfSwtPortGroups (名称为 EthIfSwtPortGroup1 和 EthIfSwtPortGroup2)</p><blockquote><ul><li>If PNC1 is requested,than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup1 and ETH_MODE_ACTIV</li><li>If PNC1 is released, than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup1 and ETH_MODE_DOWN</li><li>If PNC2 is requested, than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup2 and ETH_MODE_ACTIVE</li><li>If PNC2 is released,than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup2 and ETH_MODE_DOWN</li></ul></blockquote><blockquote><p>If a partial network is requested than the corresponding EthSwtPortGroup is switched on.</p></blockquote><p>如果请求的部分网络则打开相应的 EthSwtPortGroup</p><p><strong>Listing 3.26: ComM reports the transition to COMM_PNC_FULL_COMMUNICATION</strong></p><pre><code class="language-C">rule pnc1requested initially false {
    if ( PNC1 == COMM_PNC_REQUESTED ||
        PNC1 == COMM_PNC_READY_SLEEP ||
        PNC1 == COMM_PNC_PREPARE_SLEEP ){
        	actionlist pnc1requestedActions
    }
}
actions pnc1requestedActions on condition {
    EthIfSwitchPortGroupRequestMode {
        init false
        enable EthIfSwtPortGroup1
    }
}
rule pnc2requested initially false {
    if ( PNC2 == COMM_PNC_REQUESTED ||
        PNC2 == COMM_PNC_READY_SLEEP ||
        PNC2 == COMM_PNC_PREPARE_SLEEP ){
        	actionlist pnc2requestedActions
    }
}
actions pnc2requestedActions on condition {
    EthIfSwitchPortGroupRequestMode {
        init false
        enable EthIfSwtPortGroup2
    }
}
</code></pre><p><strong>Listing 3.27: ComM reports COMM_PNC_NO_COMMUNICATION</strong></p><p><strong>Ethernet switch port group switching with wake-up request</strong></p><blockquote><p>AUTOSAR supports the handling for OA TC10 compatible Ethernet hardware to sleep/wake-up over dataline. In combination with PNC handling and the Ethernet switch port group switching, the ComM indicate the BswM for an active PNC request with a wake-up request by reporting COMM_PNC_REQUESTED_WITH_WAKEUP_REQUEST.</p></blockquote><p>AUTOSAR 支持处理 OA TC10 兼容以太网硬件的休眠 / 唤醒数据线。结合 PNC 处理和以太网交换机端口组交换，ComM 通过 COMM_PNC_REQUESTED_WITH_WAKEUP_REQUEST 来指示 BswM 具有唤醒请求的活跃的 PNC 。</p><blockquote><p>The BswM forwards the active PNC to the EthIf by calling EthIf_SwitchPortGroupRequestMode with the corresponding EthIfSwtPortGroup and the corresponding Eth_ModeType ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.</p></blockquote><p>BswM 通过调用 EthIf_SwitchPortGroupRequestMode，并将相应的 EthIfSwtPortGroup 和相应的 Eth_ModeType ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST 传递给 Ethlf，将活动的 PNC 转发给 Ethlf。</p><blockquote><p>Based on the exemplary configuration in chapter 3.4.8 Ethernet switch port group switching, the following example illustrates the Ethernet switch port switching with wake-up on dataline request:</p></blockquote><p>基于第 3.4.8 章以太网交换机端口组交换中的示例配置，下面的示例演示了在 dataline 请求时唤醒以太网的交换机的 port</p><blockquote><ul><li>If PNC1 is requested, than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup1 and ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST</li><li>If PNC2 is requested, than EthIf_SwitchPortGroupRequestMode is called with EthSwtPortGroup2 and ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST</li></ul></blockquote><blockquote><p>If a partial network is requested and the Ethernet hardware supports and uses<br>the wake-up on dataline,</p><p>than the corresponding EthSwtPortGroup is switched<br>on</p><p>and the request for a wake-up over dataline is reported by the Eth_ModeType<br>ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.</p></blockquote><p>如果请求部分网络，并且以太网硬件支持并使用数据线上的唤醒，</p><p>则相应的 EthSwtPortGroup 被打开，</p><p>并且通过 Eth_ModeType ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST 报告对数据线上唤醒的请求。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule pnc1requested_with_wakeup_request initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC1 <span class="token operator">==</span> COMM_PNC_REQUESTED_WITH_WAKEUP_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	actionlist pnc1requested_with_wakeup_request_Actions</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>actions pnc1requested_with_wakeup_request_Actions on condition</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    EthIfSwitchPortGroupRequestMode <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        init false</pre></td></tr><tr><td data-num="10"></td><td><pre>        enable EthIfSwtPortGroup1</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="13"></td><td><pre>rule pnc2requested_with_wakeup_request initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC2 <span class="token operator">==</span> COMM_PNC_REQUESTED_WITH_WAKEUP_REQUEST<span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    	actionlist pnc2requested_with_wakeup_request_Actions</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre>actions pnc2requested_with_wakeup_request_Actions on condition</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    EthIfSwitchPortGroupRequestMode <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        init false</pre></td></tr><tr><td data-num="22"></td><td><pre>        enable EthIfSwtPortGroup1</pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>Besides the management of requests for EthIfSwitchPortGroup switching, the EthIf supervises the accumulated link state per EthSwitchPortGroup. If the EthIf detects an unexpected change of the accumulated link state of the EthIfSwitchPortGroup, the EthIf indicates this link state change by calling BswM_EthIf_PortGroupLinkStateChg of the affected EthIfSwitchPortGroup. This indication could be forwarded to the application via a ModeSwitch to react on such communication errors scenarios (e.g. Ethernet switch port hardware error, loose connection of the dataline,... a.s.o.).</p></blockquote><p>EthIf 也会去监控 port 的 link 状态，当 port link status 发生改变时，会调用 BswM_EthIf_PortGroupLinkStateChg () 来做一些处理。</p><p><strong>PduR routing path group switching</strong></p><blockquote><p>PduR routing path group switching is used to switch routing path of I-PDUs which are not assigned to a Com I-PDU group (see chapter 3.4.4 I-PDU Group Switching),</p><p>e.g I-PDUs transmitted via LdCom. LdCom has not the capability to control I-PDU groups as it is provided by Com.</p></blockquote><p>PduR 路由路径组交换用于交换未分配给 Com I-PDU 组的 L-PDUs 的路由路径 (请参阅第 3.4.4 节 I-PDU 组交换)</p><p>例如通过 LdCom 传输的 I-PDUs。LdCom 没有 Com 提供的控制 I-PDU 群的能力。</p><blockquote><p>Therefore it is possible to control the affected PudR routing paths by configured PduR routing path groups (similar to I-PDU groups in Com).</p></blockquote><p>因此，可以通过配置的 PduR 路由路径组 (类似于 com 中的 I-PDU 组) 来控制受影响的 PudR 路由路由。</p><blockquote><p>The PduR routing path groups are controlled via the following API: PduR_EnableRouting(&lt;routing path group id&gt;) and PduR_DisableRouting(&lt;routing path group id&gt;).</p></blockquote><p>俩 API</p><blockquote><p>The APIs could be called by BswM based on particular BswM rules. This enable the switching of PduR routing path groups in combination with partial networking,</p><p>e.g. ComM indicate the current PNC state to BswM, BswM evaluate the trigger conditions of the dedicated BswM rules and trigger the BswM action (control the PduR routing path groups).</p></blockquote><p><strong>也就是说 ComM 告诉 BswM 当前 PNC 的状态，然后 BswM 根据你特定的规则去处理</strong></p><blockquote><p>Please note:</p><ul><li>If I-PDUs should be controlled, then it is recommended to control Com I-PDUs via Com I-PDU groups and the remaining I-PDUs via switching of PduR routing path groups.</li></ul></blockquote><p>如果应该控制 I-PDUs</p><p>那么建议通过 Com I-PDU 组来控制 Com I-PDUs</p><p>通过切换 PduR 路由路径组来控制其余的 I-PDU。</p><blockquote><p>The following scenarios illustrate how PduR routing path groups of an ECU can be managed. The exemplary ECU shall have one physical Ethernet channel with two VLANs and three partial network clusters.</p></blockquote><p>下面的场景说明如何管理一个 ECU 的 PduR 路由路径组。示例 ECU 应有一个物理以太网信道与两个 VLAN 和三个部分网络集群。</p><blockquote><p>The mode request ports for the VLANs are named EthSM_Vlan1 and EthSM_Vlan2, the request sources for the partial network clusters are named PNC1, PNC2 and PNC3. I-PDUs of PNC1 shall be communicated only over Vlan1. I-PDUs of PNC2 shall be communicated over Vlan1 and Vlan2. I-PDUs of PNC3 shall be communicated only over Vlan2. In case of an indication by a bus state manager the BswM shall check, which partial network clusters are requested.</p></blockquote><p><strong>Listing 3.29: Active wakeup on channel</strong></p><pre><code class="language-ABAP">rule activeWakeupVlan1 initially false {
    if ( EthSM_Vlan1 == ETHSM_BSWM_FULL_COMMUNICATION){
    	actionlist activeWakeupVlan1Actions
    }
}
actions activeWakeupVlan1Actions on condition{
	rule pnc1requested rule pnc2requested
}
rule activeWakeupVlan2 initially false{
    if ( EthSM_Vlan2 == ETHSM_BSWM_FULL_COMMUNICATION &amp;&amp;
    PNC2 != PNC_REQUESTED &amp;&amp;
    PNC3 != PNC_REQUESTED ) {
    	actionlist activeWakeupVlan2Actions
    }
}
actions activeWakeupVlan2Actions on condition{
    rule pnc2requested rule pnc3requested
}
</code></pre><blockquote><p>If the bus state manager reports that a VLAN is going offline the BswM disable the corresponding I-PDU routing path groups. If the channel is part of a partial network the whole partial network has to be disabled.</p></blockquote><p>如果总线状态管理器报告 VLAN 即将下线，则 BswM 应禁用相应的 I-PDU 路由路径组。如果信道是部分网络的一部分，则必须禁用整个部分网络。</p><p><strong>Listing 3.30: EthSM reports NO_COMMUNICATION</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule offlineVlan1 initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>EthSM_Vlan1 <span class="token operator">==</span> ETHSM_BSWM_NO_COMMUNICATION<span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	actionlist offlineVlan1Actions <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre>actions offlineVlan1Actions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>PduRRoutingPathGroupSwitch<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    init true disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>VLAN1_IPDU_ROUTING_PATHS<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC1_IPDU_ROUTING_PATHS<span class="token punctuation">,</span> ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span>PNC2_IPDU_ROUTING_PATHS <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="11"></td><td><pre>rule offlineVlan2 initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> EhtSM_Can2 <span class="token operator">==</span> CANSM_BSWM_NO_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        actionlist offlineVlan2Actions</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="16"></td><td><pre>actions offlineVlan2Actions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    PduRRoutingPathGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        init true disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>VLAN2_IPDU_ROUTING_PATHS<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span> PNC2_IPDU_ROUTING_PATHS<span class="token punctuation">,</span> ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            MyPduR<span class="token punctuation">.</span>PNC3_IPDU_ROUTING_PATHS</pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>In case that a single partial network cluster is released the I-PDU routing path group representing this network has to be disabled.</p></blockquote><p>如果释放了单个部分网络集群，则必须禁用表示该网络的 I-PDU 路由路径组。</p><p><strong>Listing 3.31: PNC reports NO_COMMUNICATION</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule pnc1nocom initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC1 <span class="token operator">==</span> PNC_NO_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    	actionlist pnc1nocomTrueActions</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>actions pnc1nocomActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PduRRoutingPathGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    	init true disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC1_IPDU_ROUTING_PATHS</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="11"></td><td><pre>rule pnc2nocom initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC2 <span class="token operator">==</span> PNC_NO_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    	actionlist pnc2nocomTrueActions</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="16"></td><td><pre>actions pnc2nocomActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    PduRRoutingPathGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    	init true disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC2_IPDU_ROUTING_PATHS</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="21"></td><td><pre>rule pnc3nocom initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC3 <span class="token operator">==</span> PNC_NO_COMMUNICATION <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    	actionlist pnc3nocomActions</pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="26"></td><td><pre>actions pnc3nocomActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    PduRRoutingPathGroupSwitch <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    	init true disable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC3_IPDU_ROUTING_PATHS</pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>If a partial network cluster is requested the corresponding I-PDU routing path groups are enabled.</p></blockquote><p>如果请求部分网络集群，则启用相应的 1-PDU 路由路径组。</p><p><strong>Listing 3.32: PNC reports PNC_REQUESTED or PNC_READY_SLEEP</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>rule pnc1requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC1 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    PNC1 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">{</span> actionlist pnc1requestedActions <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>actions pnc1requestedActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PduRRoutingPathGroupSwitch</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">{</span> init true enable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC1_IPDU_ROUTING_PATHS <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre>rule pnc2requested initially false <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC2 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    PNC2 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">{</span> actionlist pnc2requestedActions <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>actions pnc2requestedActions on condition <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    PduRRoutingPathGroupSwitch</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">{</span> init true enable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span>PNC2_IPDU_ROUTING_PATHS <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="19"></td><td><pre>rule pnc3requested initially false</pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> PNC3 <span class="token operator">==</span> PNC_REQUESTED <span class="token operator">||</span> PNC3 <span class="token operator">==</span> PNC_READY_SLEEP <span class="token punctuation">)</span> <span class="token punctuation">{</span> actionlist</pre></td></tr><tr><td data-num="21"></td><td><pre>    pnc3requestedActions <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="23"></td><td><pre>actions pnc3requestedActions on condition</pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">{</span> PduRRoutingPathGroupSwitch <span class="token punctuation">{</span> init true enable ArMmExample<span class="token punctuation">.</span>EcuC<span class="token punctuation">.</span>MyPduR<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    PNC2_IPDU_ROUTING_PATHS <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>Service Discovery Control</strong></p><blockquote><p>AUTOSAR offers a standard mean to control Service Oriented Communication by Application Software Components. It makes use of the generic means to do mode management with BswM.</p></blockquote><p>AUTOSAR 提供了一种通过应用软件组件来控制面向服务的通信的标准方法，它利用通用的方法来使用 BswM 进行模式管理。</p><blockquote><p>To achieve a standard interface and behavior, the Mode Request Ports and Mode Switch Interfaces are standardized together with a configuration description for the BswM (see [4] Specification of Basic Software Mode Manager, chapter 7.8). This way not only the interfaces but also the expected behavior is well defined.</p></blockquote><p>为了实现标准的接口和行为，将模式请求端口和模式切换接口与 BswM 的配置描述一起标准化 (参见 [4] 基本软件模式管理器规范，第 7.8 章). 这样不仅接口定义得很好，而且预期的行为也很好的定义了。</p><blockquote><p>The configuration description is meant to be used for the tooling to generate a matching set of rules and actionlists to provide the actual control of service discovery.</p></blockquote><p>配置描述旨在用于工具生成一组匹配的 rules 和 actionlists ，以提供对服务发现的实际控制。</p><blockquote><p>Both auto-offer/auto-subscribe as well as an own project-specific approach can be used in parallel.</p><p>Only exception is, that if auto-offer/auto-subscribe is used,</p><p>no applicative control is possible for the same service instance on the same ECU.</p></blockquote><p>auto-offer/auto-subscribe 以及自己项目的特定方法都可以并行使用。</p><p>唯一的例外是，如果使用 auto-offer/auto-subscribe，则不可能对同一 ECU 上的同一服务实例进行应用控制。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240814155205768.png" alt="image-20240814155205768"></p><blockquote><p>In order to be able to use the standard means for Service Discovery control, it has to be taken into account already at design time of the Application-SWCs.</p></blockquote><p>为了能够使用标准的服务发现控制手段，在应用程序 - SWC 的设计时就必须考虑到这一点。</p><blockquote><p>While the fact that the use cases are required must be known at design time, the actual interfaces are completely agnostic to which SOA technology they will be applied.</p></blockquote><p>虽然在设计时必须知道需要用例这一事实，但实际的接口完全不知道会被应用到哪个 SOA 技术。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240814155658948.png" alt="image-20240814155658948"></p><blockquote><p>For a SWC to be able to request the subscription to one or more events a corresponding S/R-port is needed.</p></blockquote><p>对于 SWC 要能够请求订阅一个或多个活动，就需要相应的 S/R port。</p><blockquote><p>The fact that this port shall be used to interact with ServiceDiscovery is expressed by setting ServiceNeedsKind to BswMgrNeeds.</p></blockquote><p>通过将 ServiceNeedsKind 设置为 BswMgrNeeds 来表示该端口应用于与 ServiceDiscovery 交互.</p><blockquote><p>The kind of interaction is determined by the RoleBasedDataAssignment which could be one of</p><ul><li>ClientEventSubscription</li><li>ClientEventSubscriptionStatus</li><li>ServerServiceOffer</li><li>ServerEventSubscriptionStatus</li></ul></blockquote><p>有这么几个类型的交互种类</p><blockquote><p>The mapping to the actual payload ports (i.e. events/methods) is provided by referencing all Event-/Method-Ports relevant for this request/notification in RepresentedPort Group.</p></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240814160230207.png" alt="image-20240814160230207"></p><blockquote><p>The mapping is done at design time.</p></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240814160522126.png" alt="image-20240814160522126"></p><h3 id="35-diagnostics"><a class="anchor" href="#35-diagnostics">#</a> 3.5 Diagnostics</h3><blockquote><p>In AUTOSAR release 4.0.3 onwards the DCM is the overall mode manager for all diagnostic use cases. The BswM is responsible to change the state of the other basic software modules accordingly.</p></blockquote><p>在 AUTOSAR4.0.3 版之后，DCM 是所有诊断用例的总体模式管理器，BswM 负责相应地改变其他基本软件模块的状态。</p><p><strong>Diagnostic Session Control</strong></p><p>例子</p><p><strong>Listing 3.33: ModeGroup for session control service of the DCM</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>modeGroup DcmDiagnosticSessionControl <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    DefaultSession<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ProgrammingSession<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ExtendedDiagnosticSession<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    SafetySystemDiagnosticSession<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    AllSessionLevel</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre>interface modeSwitch MSIF_DcmDiagnosticSessionControl <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    mode DcmDiagnosticSessionControl diagnosticSessionControl</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>The DCM acting as a mode manager can inform other BSW modules about the current mode of the session control service and if needed set the basic software in the<br>corresponding mode.</p></blockquote><p>DCM 作为模式管理器，可以将会话控制服务的当前模式通知其他 BSW 模块并在需要时将 Bsw 设置在相应的模式中。</p><p><strong>Listing 3.34: ModeRequestPort for session control service of the DCM</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>request BswModeNotification DiagnosticSessionControl <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    source MSIF_DcmDiagnosticSessionControl<span class="token punctuation">.</span>diagnosticSessionControl</pre></td></tr><tr><td data-num="3"></td><td><pre>    processing IMMEDIATE</pre></td></tr><tr><td data-num="4"></td><td><pre>    initialValue DefaultSession</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>ECU Reset</strong></p><blockquote><p>In case of ECU Reset, the interaction between DCM and BswM is more complex. The Specification of the Diagnostic Communication Manager [5] specifies for this purpose the interface as described in listing 3.35. Via this interface the DCM signals the BswM to</p><ol><li>prepare the ECU to execute a specific reset.</li><li>to explicitly execute this reset.</li></ol></blockquote><p>在 ECU reset 的情况下，DCM 与 BswM 的交互更加复杂。诊断通信管理器规范 [5] 为此目的指定清单 3.35 中描述的接口。通过该接口，DCM 向 BswM 发送信号到<br>1. 为 ECU 执行特定 reset 做好准备。<br>2. 以显式执行此 reset。</p><p><strong>Listing 3.35: Mode switch interface for ECU reset diagnostic service</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>modeGroup DcmEcuReset<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    NONE<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    HARD<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    KEYONOFF<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    SOFT<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    JUMPTOBOOTLOADER<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    JUMPTOSYSSUPPLIERBOOTLOADER <span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    EXECUTE</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre>interface modeSwitch MSIF_DcmEcuReset <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    mode DcmEcuReset ecureset</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><blockquote><p>[SWS_Dcm_00373] states that on reception of a request for UDS Service with the sub functions other than enableRapidPowerShutDown (0x04) or disableRapidPower ShutDown (0x05), the DCM module shall switch the ModeDeclarationGroupPrototype DcmEcuReset to the received resetType. After the mode switch is requested the DCM triggers the start of the positive response message transmission.</p></blockquote><p>好像是废话哈哈哈</p><p><strong>Rapid Power Shutdown</strong></p><p>enableRapidPowerShutdown (0x04) or disableRapidPowerShutdown (0x05)</p><p>这个控制的，当然如果有特定的下电序列，也可以提供给 BswM</p><p><strong>Communciation Control diagnostic service</strong></p><blockquote><p>If the DCM reports to the BswM that a specified communication control mode is entered, the BswM has to enable resp. disable the corresponding IPDU groups as shown in listing 3.38.</p></blockquote><p>如果 DCM 向 BswM 报告输入了指定的通信控制模式，则 Bswm 必须启用 resp. 禁用相应的 IPDU 组</p><p><strong>Control DTC Setting</strong></p><p><strong>Listing 3.39: Mode switch interface for Control of DTC setting</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>modeGroup DcmControlDTCSetting <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    ENABLEDTCSETTING<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    DISABLEDTCSETTING</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="5"></td><td><pre>interface modeSwitch MSIF_DcmControlDtcSetting <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mode DcmControlDTCSetting dtcSetting</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><p><strong>Roe Status</strong></p><blockquote><p>The Dcm will switch the current status of the Roe per configured Roe Event via a mode switch of ModeDeclarationGroupPrototype DcmResponseOnEvent_&lt;RoeEventID&gt; switching the mode to EVENT_STARTED, EVENT_STOPPED and EVENT_CLEARED.</p><p>The information is necessary mainly for applications that need to interact with the Dcm if the events shall be triggered from external.</p></blockquote><p>Dcm 将通过模式开关 ModeDeclarationGroupPrototype DcmResponseOnEvent_ &lt;Roe EventID&gt; 将 Roe 事件的当前状态切换为 EVENT_STARTED、EVENT_STOPPED 和 EVENT_CLEARED，以配置 Roe 事件。</p><p>如果事件要从外部触发，这些信息主要对需要与 DCM 交互的应用程序是必要的。</p><p><strong>Listing 3.40: Mode switch interface for Roe Status</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>ModeGroup DcmResponseOnEvent_<span class="token operator">&lt;</span>RoeEventID<span class="token operator">&gt;</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    EVENT_STARTED<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    EVENT_STOPPED<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    EVENT_CLEARED</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>interface modeSwitch MSIF_DcmResponseOnEvent<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    mode DcmResponseOnEvent currentMode</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h3 id="36-bswm-to-bswm-interaction-on-multicore-ecus"><a class="anchor" href="#36-bswm-to-bswm-interaction-on-multicore-ecus">#</a> 3.6 BswM to BswM interaction on multicore ECUs</h3><blockquote><p>The BswM mainly interacts with the state managers of the functional clusters, e.g. with the ComM, and should therefore be locally available on the same partition in order to limit inter-core communication as much as possible.</p></blockquote><p>BswM 主要与功能集群的状态管理器进行交互，例如与 ComM 进行交互，因此应该在同一分区上本地可用，以尽可能限制内核之间的通信。</p><blockquote><p>Therefore, the BswM can be distributed over multiple partitions containing BSW modules. These independent BswMs have partition specific configuration sets. The synchronization of the different partition local BswM instances can be accomplished by normal mode-communication (mode request, mode switch) between BswM service components.</p></blockquote><p>因此，BSwM 可以分布在包含 BSW 模块的多个分区中。这些独立的 BswMs 具有分区特定的配置集。不同分区本地 BswM 实例之间的同步可以通过 BswM 服务组件之间的正常模式通信 (模式请求，模式切换) 来实现。</p><blockquote><p>If a partition of the ECU contains BSW modules running inside the partition, the partition would also have a partition local BswM.</p></blockquote><p>如果 ECU 的分区包含在该分区内部运行的 BSW 模块，则该分区也将有一个分区本地 BsWM。</p><blockquote><p>A partition local BswM is responsible for the complete initialization of the BSW Modules within its partition. As the initialization sequence largely depends on the distribution of the modules in different partitions, this has a big impact on the configuration of all partition local BswMs.</p></blockquote><p>分区本地 BSwM 负责其分区内的 BSW 模块的完整初始化。每个分区内的 BswM 的配置很关键</p><blockquote><p>Each partition local BswM has the job of coordinating the initialization of the BSW modules which are running in its partition.</p></blockquote><p>每个分区本地 BSwM 负责协调在其分区中运行的 Bsw 模块的初始化。</p><blockquote><p>Each instance of the BswM will then take care of the correct initialization and deinitialization of the partition local BSW modules, so that the following scenarios can be realized:</p></blockquote><p>然后，BswM 的每个实例将处理分区本地 Bsw 模块的正确初始化和去初始化，从而可以实现以下场景:</p><blockquote><ul><li>Startup up: After startup of the OS, each EcuM will hand over control to the partition local BswM, which then takes care of the initialization of the other partition local BSW Modules. Afterwards, the partition local BswM signals the readiness of the partition to the other BswM instances running in other partitions. This signalling is done using normal mode-communication between the BswM service components.</li><li>Shutdown: The partition local BswM determines via its ModeRequestSources, whether it can be shut down or not. If this is the case, it signals its current state to the other BswM instances running in other partitions. This signalling is done using normal mode communication between the BswM service components. The BswM placed inside the partition of the Master EcuM can then decide on this information whether it initiates a shutdown of the ECU.</li><li>Deinitialization: The BswM (on the partition where the Master EcuM is running inside) can signal the other BswMs that it wants to shutdown the ECU. This signalling is done using normal mode-communication between the BswM service components. The other BwsMs can then deinitialize the modules running inside their partition in order to enable a clean shutdown.</li><li>Restart of a partition: If a partition is restarted, the local BswM signals to the other BswM instances that it is in a restart mode. This signalling is done using normal mode communication between the BswM service components. Then, the other BswMs can determine if local applications need to be informed or potentially restarted, and how to synchronize them to the newly started partition.</li></ul></blockquote><h3 id="37-inter-partition-actions"><a class="anchor" href="#37-inter-partition-actions">#</a> 3.7 Inter-partition Actions</h3><blockquote><p>The BswM does not implement mechanisms to prevent the execution of actions which affect modules residing on another partition.</p></blockquote><p>BswM 不实现阻止执行影响驻留在另一分区的模块的操作的机制。</p><blockquote><p>The configurator of the BswM needs to be aware of this during the configuration of BswM actions. Generally, the BswM can safely execute actions which affect its own partition, but special consideration on the part of the configurator must be given when configuring a BswM action which affects another partition.</p></blockquote><p>在配置 BswM 操作时，BswM 的配置器需要意识到这一点。一般来说 BswM 可以安全地执行影响其自身份区的操作，但当配置影响另 - 个分区的 BswM 操作时必须特别考虑配置器的部分。</p><blockquote><p>When configuring a cross-partition action, care must be taken to ensure tha the cross-partition action (in implementation, a function call to another partition) can be executed safely and without endangering system performance or stability.</p></blockquote><p>当配置跨分区操作时，必须注意确保跨分区操作 (在实现中，对另一个分区的函数调用) 可以安全地执行，并且不会危及系统性能或稳定性。</p><blockquote><p>If necessary, the implementor of a function needs to state limitations with respect to its usage(e.g. ’not prepared to be called cross-partition with memory protection enabled’).</p></blockquote><p>如果有必要，函数的实现者需要对它的使用状态进行限制 (例如不准备在启用内存保护的情况下被称为交叉分区’)。</p><blockquote><p>Among other things, the following issues need to be considered on the part of the configurator of cross-partition actions: memory protection, stopping/restarting of partitions, and proper preparation of the callee’s (i.e. the recipient of the action) partition.</p></blockquote><p>跨分区操作的配置器需要考虑以下问题：内存保护、分区停止重新启动以及正确准备被调用方 (即操作的接收方) 的分区。</p><h3 id="38-inter-partition-requestsindications"><a class="anchor" href="#38-inter-partition-requestsindications">#</a> 3.8 Inter-partition Requests/Indications</h3><blockquote><p>If the BswM is integrated in a multi-partition ECU, mode requests and/or mode indications could possibly be sent across partition boundaries to the BswM.</p></blockquote><p>如果 BswM 集成在多分区 ECU 中，则可能跨分区边界向 BswM 发送模式请求和 / 或模式指示。</p><blockquote><p>In the case of a mode request/indication which crosses a partition via the Rte (e.g. BswMSwcModeRequest), the configurator does not need to take special considerations regarding system stability or data consistency, the Rte handles the communication of this type of cross-partition mode request/indication.</p></blockquote><p>如果模式请求 / 指示通过 Rte 跨越分区 (例如 BswMSwcModeRequest)，则配置器不需要特别考虑系统稳定性或数据一致性，Rte 会处理此类跨分区模式请求 / 指示的通信。</p><blockquote><p>However, if the cross-partition mode request/indication comes directly from a BSW module (e.g. BswMComMIndication) or from a generic source (e.g. BswMGenericRequest), the configurator must take special considerations, for example:</p><ol><li><p>When the configurator uses memory protection, memory sections which are in volved in cross-partition mode requests/indications (e.g. BswM-internal status flags) need to be configured to allow such cross-partition access.</p></li><li><p>Cross-partition Mode requests/indications which are configured with IMMEDIATE processing may also trigger an immediately executed actionlist. The resultant actions will be executed in the context of the caller (e.g. a BSW module in another partition). For these IMMEDIATE cross-partition mode requests/indication, the same issues as in chapter "Inter-partition Actions" also need to be considered.</p></li></ol></blockquote><p>然而，如果跨分区模式请求 / 指示直接来自 BSW 模块 (例如 BswMComMIndication) 或来自通用源 (例如 BswMGenericRequest) 那配置得特殊考虑例如：</p><ul><li>当配置器使用内存保护时，涉及跨分区模式请求 / 指示的内存段 (例如 BswM - 内部状态标志) 需要进行配置以允许此类跨分区访问。</li><li>配置了 IMMEDIATE 处理的跨分区模式请求 / 指示也可能触发立即执行的动作列表。产生的动作将在调用者的上下文中执行 (例如，另一个分区中的 BSW 模块)。对于这些 IMMEDIATE 跨分区模式请求 / 指标，还需要考虑 “跨分区操作” 章中的相同问题。</li></ul><h1 id="modemanagement"><a class="anchor" href="#modemanagement">#</a> ModeManagement</h1><h2 id="1-scope-of-document"><a class="anchor" href="#1-scope-of-document">#</a> 1 Scope of Document</h2><blockquote><p>The goal of this document is to define the functional and non-functional requirements for all modules of the AUTOSAR mode management：</p><ul><li>ECU State Manager [2] (EcuM) which manages startup and shutdown of the ECU. This includes triggering the shutdown when all requests for run are released;</li><li>Watchdog Manager [3] (WdgM) which collects the indications of aliveness and correct execution order from the independent applications and relays them to the hardware watchdog in a suitable way;</li><li>Communication Manager [4] (ComM) which coordinates the communication of the independent applications.</li><li>Basic Software Mode Manager (BswM) which organizes mode handling and mode related interaction of SW-Cs and the BSW modules.</li></ul><p>All modules are needed if more than one independent software component resides on the ECU.</p></blockquote><p>本文档的目标是定义 AUTOSAR 模式管理的所有模块的功能和非功能要求:</p><ul><li>ECU 状态管理器（ECUM）<ul><li>管理 ECU 的 startup 和 shutdown ，包括在所有的运行请求被释放后执行 shutdown.</li></ul></li><li>看门狗管理器（WdgM）<ul><li>从独立应用程序中收集可靠和正确的执行命令的指示，并以适当的方式将其转发给硬件监督机构；</li></ul></li><li>通信管理器（ComM）<ul><li>负责协调独立应用程序的通信。</li></ul></li><li>基本软件模式管理器 (BSWM)<ul><li>用于组织模式处理和 SWC 和 BSW 模块的模式相关交互。</li></ul></li></ul><h2 id="4-requirements-specification"><a class="anchor" href="#4-requirements-specification">#</a> 4 Requirements Specification</h2><h3 id="41-ecu-state-manager-ecum"><a class="anchor" href="#41-ecu-state-manager-ecum">#</a> 4.1 ECU State Manager (EcuM)</h3><blockquote><p>The ECU State Manager [2] is a basic software module that manages the ECU states and the transitions between these states.</p><p>It manages all wake-up events and configures the ECU for SLEEP when requested.</p></blockquote><p>ECU 状态管理器是一个基本的软件模块，用于管理 ECU 状态和这些状态之间的转换。</p><p>它管理所有唤醒事件，并根据睡眠的请求配置 ECU。</p><blockquote><p>The ECU State Manager [2] shall support individual preparation-activities and transitions to bring up the ECU or put it into a decreased power mode (low-power mode,e.g. sleep / standby).</p><p>By a well defined usage of ECU State Manager [2] features and capabilities, this module can then be used to perform a pre-defined strategy of power-consumption, thus allowing efficient energy management for the ECU.</p></blockquote><p>ECU 状态管理器 [2] 应支持单个准备活动和过渡活动，以启动 ECU 或将其放入降低功率模式 (低功率模式，例如睡眠 / 待机)。通过明确定义使用 ECU 状态管理器 [2] 该模块具有功能和能力，可用于执行预先定义的功耗策略，从而为 ECU 实现高效的能源管理。</p><p><strong>Configuration (Common)</strong></p><blockquote><p><strong>[SRS_ModeMgm_09122] Configuration of users of the ECU State Manager</strong></p></blockquote><p>所有的状态切换都是用户配置的，所以预先配置好，不是预期的状态切换不予响应</p><blockquote><p><strong>[SRS_ModeMgm_09100] Selection of wake-up sources shall be configurable</strong></p></blockquote><p>唤醒源可配置的</p><blockquote><p>Depending on the ECU, the allowed wake-up source may vary：</p><ul><li>reception of a CAN frame,</li><li>direct input(s),</li><li>either CAN frames or direct inputs,</li><li>等等</li></ul></blockquote><p><strong>Normal Operation (Common)</strong></p><blockquote><p><strong>[SRS_ModeMgm_09104] ECU State Manager shall take over control after OS shutdown</strong></p></blockquote><p>OS 关闭后由 ECUM 接管。因为 OS 启动也是由 ECUM 启动的。</p><blockquote><p><strong>[SRS_ModeMgm_09128] Several shutdown targets shall be supported</strong></p></blockquote><p>支持配置几个 shutdown 目标</p><blockquote><p>Power Off</p><p>Reset of ECU</p><p>Sleep Modes</p></blockquote><blockquote><p><strong>[SRS_ModeMgm_09270] The ECU State Manager shall provide a service for the selection of the shutdown target</strong></p></blockquote><p>服务化吧</p><blockquote><p><strong>[SRS_ModeMgm_09271] The ECU State Manager shall provide a service for the retrieval of the current shutdown target</strong></p></blockquote><p>能检索当前的 shutdown 目标，就增删改查呗</p><blockquote><p><strong>[SRS_ModeMgm_09119] Several sleep modes shall be available</strong></p><p><strong>[SRS_ModeMgm_09102] API for selecting the sleep mode shall be provided</strong></p><p><strong>[SRS_ModeMgm_09272] The ECU State Manager shall provide a service for the retrieval of the last sleep targets</strong></p></blockquote><p>跟 sleep 的实现和 shutdown 一样的标准</p><blockquote><p><strong>[SRS_ModeMgm_09072] ECU shutdown shall be forced</strong></p></blockquote><p>要有一个强制关机的接口</p><blockquote><p><strong>[SRS_ModeMgm_09017] The ECU State Manager shall provide an API to query the current ECU state</strong></p></blockquote><p>查询 ECU 状态的接口</p><blockquote><p><strong>[SRS_ModeMgm_09136] The ECU State Manager shall be the receiver of all wake up events</strong></p></blockquote><p>ECUM 是所有唤醒事件的接收者，废话整个芯片的状态都是 ECUM 说了算</p><blockquote><p><strong>[SRS_ModeMgm_09098] Storing the wake-up reasons shall be available</strong></p></blockquote><p>要存储下来当前的唤醒原因，也可以通过外部通信获取</p><blockquote><p><strong>[SRS_ModeMgm_09097] The ECU State Manager module shall start a timeout after receiving a wake-up indication</strong></p></blockquote><p>要有一个唤醒验证的操作，并有超时处理。</p><blockquote><p><strong>[SRS_ModeMgm_09126] An API for querying the wake-up reason shall be provided</strong></p></blockquote><p>可以获取最近的唤醒原因</p><blockquote><p><strong>[SRS_ModeMgm_09274] The ECU State Manager shall provide a service for the retrieval of the selected reset modality</strong></p><p><strong>[SRS_ModeMgm_09274] The ECU State Manager shall provide a service for the retrieval of the selected reset modality</strong></p><p><strong>[SRS_ModeMgm_09101] An API to query the reset reason shall be provided</strong></p><p><strong>[SRS_ModeMgm_09276] The ECU State Manager shall provide a service allowing the selection of the boot target</strong></p><p><strong>[SRS_ModeMgm_09275] The ECU State Manager shall provide a service for querying the time of previous resets</strong></p></blockquote><p>一堆接口要支持</p><blockquote><p><strong>[SRS_ModeMgm_09127] The ECU State Manager shall de-initialize Basic Software modules where appropriate during the shutdown process</strong></p></blockquote><p>ECUM 要在 shutdown 的过程中协助 bsw 去初始化。</p><blockquote><p><strong>[SRS_ModeMgm_09116] Requesting and releasing the RUN state shall be provided</strong></p></blockquote><p>要提供请求和释放 RUN 状态的接口</p><p><strong>Fixed</strong></p><blockquote><p>Please note that the Specification of ECU State Manager [2] with fixed state machine is not part of this Release anymore.</p><p>The ECU State Manager [2] Fixed is a variant of the EcuM which has a fixed set of states: OFF, RUN, SLEEP and transient states: STARTUP, WAKEUP, SHUTDOWN).</p></blockquote><p>也是 ECUM 的状态，不过规范了并固定了几种状态</p><blockquote><p><strong>[SRS_ModeMgm_09120] Configuration of initialization process of Basic Software modules shall be available</strong></p><p><strong>[SRS_ModeMgm_09147] Configuration of de-initialization process of Basic Software modules shall be provided</strong></p><p><strong>[SRS_ModeMgm_09146] Configuration of time triggered increased inoperation shall be provided</strong></p><p><strong>[SRS_ModeMgm_09001] The number and names of main states and the transitions between main states shall be standardized.</strong></p><p><strong>[SRS_ModeMgm_09173] A Run State shall have a minimum duration</strong></p><p><strong>[SRS_ModeMgm_09114] Starting/invoking the shutdown process shall be provided</strong></p><p><strong>[SRS_ModeMgm_09113] Initialization of Basic Software modules shall be done</strong></p><p><strong>[SRS_ModeMgm_09009] The ECU State Manager shall provide the ability to execute external, statically-configured code at each transition between ECU states</strong></p><p><strong>[SRS_ModeMgm_09118] The ECU State Manager shall provide a mechanism to enter a step by step decreasing power mode</strong></p></blockquote><p>支持分级别低功耗</p><blockquote><p><strong>[SRS_ModeMgm_09115] The ECU State Manager shall include a mechanism to evaluate the condition to stay in the RUN state</strong></p></blockquote><p>状态管理要可以判断可以保持在 RUN 的条件</p><blockquote><p><strong>[SRS_ModeMgm_09164] Shutdown synchronization for SW-Components shall be supported</strong></p></blockquote><p>支持 SWC 的 shutdown 同步</p><blockquote><p><strong>[SRS_ModeMgm_09165] The ECU State Manager shall provide services to request and release the POST-RUN state</strong></p><p><strong>[SRS_ModeMgm_09166] The ECU State Manager shall evaluate the condition to stay in the POST-RUN state</strong></p><p><strong>[SRS_ModeMgm_09145] Wake-sleep operation shall be supported</strong></p></blockquote><p><strong>Flex</strong></p><blockquote><p><strong>[SRS_ModeMgm_09234] The EcuM shall handle the initialization of Basic Software modules</strong></p><p><strong>[SRS_ModeMgm_09235] The ECU State Manager shall offer two targets for shutting down the ECU</strong></p><p><strong>[SRS_ModeMgm_09185] A persistent Alarm Clock used by local SW-Cs shall be provided</strong></p><p><strong>[SRS_ModeMgm_09186] Alarm Clock shall be active while the ECU is powered</strong></p><p><strong>[SRS_ModeMgm_09187] In Case of wakeup, all the alarm clock shall be canceled</strong></p><p><strong>[SRS_ModeMgm_09188] In Case of startup, all the alarm clock shall be canceled</strong></p><p><strong>[SRS_ModeMgm_09189] Consecutive requests shall honor the earliest expiring alarm only</strong></p><p><strong>[SRS_ModeMgm_09190] The alarm clock service shall allow setting an alarm relative to the current time using a time resolution of seconds</strong></p><p><strong>[SRS_ModeMgm_09199] The alarm clock service shall allow setting an alarm absolute by using an absolute time with a resolution of seconds</strong></p><p><strong>[SRS_ModeMgm_09194] The alarm clock service shall allow setting the clock</strong></p><p><strong>[SRS_ModeMgm_09277] The ECU State Manager shall provide an alarm clock service which shall allow the retrieval of clock values</strong></p></blockquote><p>自我感觉没那么重要</p><blockquote><p><strong>[SRS_ModeMgm_09236] There shall be one instance of the function EcuM_Init that distinguishes between the different cores</strong></p></blockquote><p>要区分多核，只有 master 核可以启动其他核心。</p><blockquote><p><strong>[SRS_ModeMgm_09237] RTE_Start shall be called on each core.</strong></p><p>RTE [7]_Start shall be called locally on each core by means of tasks triggered by the BswM on the main core through dedicated available actions.</p></blockquote><p>RTE_Start 应通过主核心上的 BswM 通过专用可用动作触发的任务在每个核心上本地调用，每个核心都需要初始化，且需要同步，避免其他核提前进入 OS 调度</p><blockquote><p><strong>[SRS_ModeMgm_09238] State changes shall be ECU global</strong></p><p>Only the entire ECU changes into either</p><ul><li>"off",</li><li>"fully functional"</li><li>or "sleeping"(halted or set to poll)</li></ul></blockquote><blockquote><p><strong>[SRS_ModeMgm_09239] To shutdown, ShutdownAllCores shall be called on the</strong><br><strong>master core after synchronizing all cores</strong></p></blockquote><p>关闭也需要同步</p><blockquote><p><strong>[SRS_ModeMgm_09254] Validation and handling of a wakeup event shall be done locally</strong></p></blockquote><p>唤醒事件也要在本核心上</p><h3 id="42-watchdog-manager"><a class="anchor" href="#42-watchdog-manager">#</a> 4.2 Watchdog Manager</h3><p><strong>Functional Overview</strong></p><blockquote><p>The Watchdog Manager [3] is a basic software module of the standardized basic software architecture of AUTOSAR (service layer).</p></blockquote><p>看门狗管理器是 AUTOSAR (服务层) 标准化基本软件架构的 BSW 模块</p><blockquote><p>It is intended to supervise the reliability of application execution with respect to timing constraints (temporal program flow monitoring) and with respect to the correct sequence of execution (logical program flow monitoring).</p></blockquote><p>旨在监督应用程序执行的可靠性，包括时间约束 (时间程序流程监控) 和执行的正确顺序 (逻辑程序流程监控)</p><blockquote><p>Derived from the layered architecture approach [9], a decoupling between application timing constraints and watchdog hardware timing constraints becomes possible.</p></blockquote><p>源自分层架构方法，使得应用程序定时约束和看门狗硬件定时约定之间的解耦成为可能。</p><blockquote><p>Based on this decoupling the Watchdog Manager [3] provides temporal program flow monitoring (alive-supervision) of several independent applications as well as logical program flow monitoring (the supervision of the correct execution order) while triggering the watchdog hardware.</p></blockquote><p>基于这种解耦，Watchdog Manager 在触发看门狗硬件时，提供对几个独立应用程序的时间程序流监控 (alive-supervision) 以及逻辑程序流监控 (对正确执行顺序的监督)。</p><blockquote><p>The following features are provided by the Watchdog Manager</p><ul><li>Supervision of multiple individual applications located on the ECU, having in dependent timing constraints and requiring a special supervision of runtime be haviour and aliveness.</li><li>Logical supervision of safety-related tasks and periodic functions (main functions).</li><li>Fault-reaction mechanism for each independent supervised entity.</li><li>Possibility to switch off supervision of individual applications, without violating the watchdog triggering (e.g. for inhibited applications).</li><li>Triggering of internal or external, standard or window, watchdog, via a watchdog driver. The access to the internal or external watchdog will be handled by the Watchdog Interface.</li><li>Selection of the watchdog mode (Off Mode, Slow Mode, Fast Mode) depending on the ECU state and the hardware capabilities.</li></ul></blockquote><p>看门狗的特性</p><p><strong>Functional Requirements</strong></p><blockquote><p><strong>[SRS_ModeMgm_09107] The Watchdog Manager shall provide an initialization service</strong></p><p><strong>[SRS_ModeMgm_09109] It shall be possible to prohibit the disabling of watchdog</strong></p></blockquote><p>应该可以禁止失能看门狗</p><blockquote><p><strong>[SRS_ModeMgm_09112] The Watchdog Manager shall cyclically check the periodicity of the supervised entities</strong></p><p><strong>[SRS_ModeMgm_09221] The Watchdog Manager shall check the correct sequence of code execution in supervised entities</strong></p></blockquote><p>看门狗管理器不仅检查代码的执行时间还检查执行时序</p><blockquote><p><strong>[SRS_ModeMgm_09125] The Watchdog Manager shall provide a service allowing the Update temporal program flow monitoring</strong></p><p><strong>[SRS_ModeMgm_09222] The Watchdog Manager shall provide a service allowing the Update logical program flow monitoring</strong></p></blockquote><p>要在检查点那里做 trace</p><blockquote><p><strong>[SRS_ModeMgm_09160] The Watchdog Manager shall provide the indication of failed temporal monitoring</strong></p></blockquote><p>要有失败的指示，提醒 SWC 或其他模块</p><blockquote><p><strong>[SRS_ModeMgm_09161] The Watchdog Manager shall reset the triggering condition in the Watchdog Driver in Case of temporal failure</strong></p></blockquote><p>没看懂啥意思</p><blockquote><p><strong>[SRS_ModeMgm_09226] The Watchdog Manager shall reset reset the triggering condition in the Watchdog Driver in Case of logical program flow violation</strong></p></blockquote><p>程序流错误时看门狗触发</p><blockquote><p><strong>[SRS_ModeMgm_09169] The Watchdog Manager shall be able to immediately reset the MCU</strong></p><p><strong>[SRS_ModeMgm_09162] The Watchdog Manager shall be able to notify the software of an upcoming watchdog reset</strong></p></blockquote><p>就是看门狗触发时可以通知到其他软件</p><blockquote><p><strong>[SRS_ModeMgm_09163] It shall be possible to configure a delay before provoking a watchdog reset</strong></p></blockquote><p>可以配置看门狗触发后<strong>延时多久后重启</strong></p><blockquote><p><strong>[SRS_ModeMgm_09143] The Watchdog Manager shall set the triggering condition during inactive monitoring</strong></p><p><strong>[SRS_ModeMgm_09231] The Watchdog Manager shall periodically set the triggering condition in the Watchdog Driver as long as the monitoring has not failed</strong></p></blockquote><p>要设置触发条件，同时也要定期去设置看门狗的触发条件</p><blockquote><p><strong>[SRS_ModeMgm_09110] The watchdog Manager shall provide a service interface, to select a mode of the Watchdog Manager</strong></p></blockquote><p>有几个模式</p><ul><li>off</li><li>slow</li><li>fast</li></ul><blockquote><p><strong>[SRS_ModeMgm_09028] The Watchdog Manager shall support multiple watchdog instances</strong>****</p></blockquote><p>支持多个看门狗实现，感觉这个思想真的吊</p><blockquote><p><strong>[SRS_ModeMgm_09233] The Watchdog Manager shall support independent triggering condition values for each watchdog instance</strong></p></blockquote><p>每个看门狗都有自己的配置和触发条件</p><blockquote><p><strong>[SRS_ModeMgm_09232] The Watchdog Manager shall provide a service to cause a watchdog reset</strong></p><p><strong>[SRS_ModeMgm_09106] The list of entities supervised by the Watchdog Manager shall be configurable at pre-compile time</strong></p><p><strong>[SRS_ModeMgm_09220] It shall be possible to configure all the transition relations</strong></p><p><strong>[SRS_ModeMgm_09158] The Watchdog Manager shall support Post build time and mode dependent selectable configuration sets for the Watchdog Manager</strong></p><p><strong>[SRS_ModeMgm_09223] The Watchdog Manager shall support Post build time and mode dependent selectable configuration of transition relations</strong></p></blockquote><p>总之就是配配配</p><p><strong>Fault Operation</strong></p><blockquote><p><strong>[SRS_ModeMgm_09159] The Watchdog Manager shall report failure of temporal or program flow monitoring to DEM</strong></p></blockquote><p>有报错机制</p><h3 id="43-communication-manager"><a class="anchor" href="#43-communication-manager">#</a> 4.3 Communication Manager</h3><p><strong>Functional Overview</strong></p><blockquote><p>The Communication Manager [4] collects and coordinates the communication access requests from communication requestors (users, see glossary).</p></blockquote><p>通讯管理收集和协调来自通信请求者 (用户，请参见术语表) 的通信访问请求。</p><blockquote><p>The purpose of the Communication Manager [4] is:</p><ul><li>Simplifying the usage of the communication protocol stack for the user. This includes the starting and stopping physical channel communication and a simplified network management handling.</li><li>Temporarily disabling sending of messages to prevent the ECU from (actively) waking up the physical channel(s).</li><li>Controlling of more than one physical channels of an ECU by implementing a state machine for every physical channel.</li><li>Requesting the appropriate communication state to the BusState Manager</li><li>Simplifying the resource management by allocating all resources necessary for the requested communication mode.</li></ul></blockquote><p>ComM 有这么几个目的</p><ul><li>简化了用户对通信协议栈的使用，包括物理信道通信的启动和停止以及简化的网络管理处理</li><li>暂时禁用发送消息，以防止 ECU (主动) 唤醒物理信道。</li><li>通过为每个物理通道实现状态机来控制 ECU 的多个物理通道。</li><li>向 BusState Manager 请求适当的通信状态</li><li>通过分配所请求的通信模式所需的所有资源，简化了资源管理。</li></ul><blockquote><p>In order to do so, the Communication Manager [4] defines "communication modes",<br>indicating if a given physical channel is available for the application and how (send/<br>receive; only receive, neither send nor receive).</p></blockquote><p>为此，通信管理器 [4] 定义 “通信模式”，指示给定的物理信道是否可供应用程序使用，以及如何使用 (发送 / 接收；仅接收，既不发送也不接收)。</p><p><strong>Functional Requirements</strong></p><blockquote><p><strong>[SRS_ModeMgm_09078] The Communication Manager shall coordinate multiple communication requests</strong></p><p><strong>[SRS_ModeMgm_09246] The communication manager shall arbitrate and coordinate requests from users on physical channel and users on PNCs</strong></p><p><strong>[SRS_ModeMgm_09247] For each configured PNC an independent state machine shall be instantiated</strong></p></blockquote><p>ComM 来协调通信请求，也来管理 PNC，而且每个 PNC 都有自己的状态机</p><blockquote><p><strong>[SRS_ModeMgm_09248] it shall be possible to distinguish between internal and external PNC activation requests</strong></p></blockquote><p>要区分 PNC 的内部或外部激活请求</p><blockquote><p><strong>[SRS_ModeMgm_00049] The Communication Manager shall initiate the wake-up and keep awake physical channels</strong></p></blockquote><p>ComM 发起唤醒并保持物理通道唤醒</p><blockquote><p><strong>[SRS_ModeMgm_09080] Each physical channel shall be controlled by an independent communication mode</strong></p></blockquote><p>每个物理信道应由独立的通信模式控制</p><blockquote><p><strong>[SRS_ModeMgm_09081] The Communication Manager shall provide an API allowing collecting communication requests</strong></p></blockquote><p>ComM 应提供允许收集通信请求的 API</p><blockquote><p><strong>[SRS_ModeMgm_09083] The Communication Manager shall support two communication modes for each physical channel</strong></p></blockquote><p>ComM 应支持每个物理信道的两种通信模式</p><blockquote><p><strong>[SRS_ModeMgm_09084] The Communication Manager shall provide an API which allows application to query the current communication mode</strong></p></blockquote><p>ComM 应提供一个允许应用程序查询当前通信模式的 API</p><blockquote><p><strong>[SRS_ModeMgm_09172] It shall be possible to evaluate the current communication mode</strong></p></blockquote><p>应有可能评估当前的通信模式</p><blockquote><p><strong>[SRS_ModeMgm_09149] The Communication Manager shall provide an API for querying the requested communication mode</strong></p></blockquote><p>ComM 应提供一个 API，用于查询请求的通信模式</p><blockquote><p><strong>[SRS_ModeMgm_09085] The Communication Manager shall provide an indication of communication mode changes</strong></p></blockquote><p>模式改变的时候要有指示</p><blockquote><p><strong>[SRS_ModeMgm_09168] The Communication Manager shall support users that are connected to no physical channel</strong></p></blockquote><p>抽象呗，上下层级解耦</p><blockquote><p><strong>[SRS_ModeMgm_09071] It shall be possible to limit communication modes independently for each physical channel</strong></p></blockquote><p>应可为每个物理信道独立限制通信模式</p><blockquote><p><strong>[SRS_ModeMgm_09157] It shall be possible to revoke a communication mode limitation, independently for each physical channel</strong></p></blockquote><p>应该可以对每个物理信道独立地撤销通信模式限制</p><blockquote><p><strong>[SRS_ModeMgm_09087] The Minimum duration of communication request after wakeup shall be configurable</strong></p></blockquote><p>唤醒后的最小维持时间可配置</p><blockquote><p><strong>[SRS_ModeMgm_09089] The Communication Manager shall be able to prevent waking up physical channels</strong></p></blockquote><p>应该可以配置禁止唤醒物理通道</p><blockquote><p><strong>[SRS_ModeMgm_09155] The Communication Manager shall provide a counter for inhibited communication requests</strong></p><p><strong>[SRS_ModeMgm_09156] It shall be provided an API to retrieve the number of inhibited "Full Communication" mode requests</strong></p></blockquote><p>给各种请求计数</p><blockquote><p><strong draft="">[SRS_ModeMgm_09249]</strong> <strong>PNC gateway and coordination functionality</strong></p></blockquote><p><strong>Description:</strong></p><blockquote><p>Communication Manager shall be aware of the distribution of each PNC over different ComM channels (where each channel represents a particular connection to a bus (e.g. CAN, FlexRay) or network (e.g. switched Ethernet network)) and shall take care to forward the activation requests from one channel to the other.</p></blockquote><p>ComM 应了解每个 PNC 在不同 ComM 通道上的分布 (每个通道表示对总线例如 CAN、FlexRay) 或网络 (例如交换式以太网网络) 的特定连接)，并应小心地将激活请求从一个通道转发到另一个通道。</p><blockquote><p>The Communication Manager of a PNC gateway can either act per PNC as top-level PNC coordinator or as intermediate PNC coordinator.</p></blockquote><p>PNC 网关的 ComM 可以作为每个 PNC 的顶级 PNC 协调器或中间 PNC 协调人。</p><blockquote><p>The top-level PNC coordinator is responsible for the coordinated shutdown of all PNC members, because it is the only node which has the full overview of the states of all PNCs.</p></blockquote><p>最顶级 PNC 协调器负责协调关闭所有 PNC 成员，因为它是唯一全面了解所有 PNC 状态的节点。</p><blockquote><p>If the top-level PNC coordinator detects, that a PNC request has been released, then a NM message is transmitted where this PNC is indicated as released.</p></blockquote><p>如果顶级 PNC 协调器检测到已释放了 PNC 请求，则发送一个 NM 消息，其中该 PNC 被指示为已释放。</p><blockquote><p>The NM message is forwarded as usual NM message by the intermediate PNC coordinate to the PNC leaf nodes. If the optional feature "synchronized PNC shutdown" is enabled the top-level PNC coordinator transmits a NM message as PN shutdown message.</p></blockquote><p>NM 消息由中间 PNC 协调器作为常规 NM 消息转发到 PNC 叶节点。如果启用了可选功能 “同步 PNC 关机”，则顶级 PNC 协调器将 NM 消息作为 PN 关机消息发送。</p><blockquote><p>The intermediate PNC coordinator is responsible to forward a PN shutdown message (request for a synchronized PNC shutdown) per channel has fast as possible.</p></blockquote><p>中间 PNC 协调器负责尽可能快地在每个信道上转发 PN 关闭消息 (请求同步 PNC 关闭)</p><p><strong>Rationale:</strong></p><blockquote><p>A PNC can span over different buses which are not necessarily connected to each involved ECU.</p></blockquote><p>PNC 可以跨越不同的总线，而这些总线不一定与每个相关 ECU 相连。</p><blockquote><p>AUTOSAR supports Partial Network topologies, where different PNCs are coordinated by different ECUs in the role of a top-level PNC coordinator.</p></blockquote><p>AUTOSAR 支持部分网络拓扑，其中不同的 PNCs 由不同的 ECU 协调，扮演最高级别 PNC 协调器的角色。</p><blockquote><p>Please note, a PNC can have only one top-level coordinator across a Partial Network.</p><p>This has to be ensured by a proper Partial Network communication design.</p></blockquote><p>请注意，一个 PNC 在部分网络中只能有一个顶级协调器，必须通过适当的局部网络通信设计来确保这一点。</p><p><strong>Use Case:</strong></p><blockquote><p>ECU A is connected to network 1 and 2,</p><p>ECU B is connected to network 2 and 3,</p><p>ECU C is connected to network 3;</p><p>as PNC 1 involves SWCs on all these ECUs, the communication manager on each ECU must know where and how to forward the activation requests.</p><p>ECU A is acting as top-level PNC coordinator for PNC1. If all ECUs have released PNC1 and optional feature "synchronized PNC shutdown" is enabled, then ECU A transmit a PN shutdown message on network 1 and 2 to start a synchronized PNC shutdown of PNC1.</p><p>ECU B is acting as intermediate PNC coordinator and forwards the request for a synchronized PNC shutdown of PNC1 to network 3</p></blockquote><p>一个小例子</p><blockquote><p><strong>[SRS_ModeMgm_09250] PNC activation requests shall be exchanged with the Network Management via a PNC bit vector</strong></p></blockquote><p>PNC 激活请求应通过 PNC 位矢量与网络管理器交换</p><blockquote><p>Communication Manager shall provide callback functions get external PNC activation requests as PNC bit vector</p><p>and call functions of the Network Management in order to forward PNC activation requests as PNC bit vector according to the specified bit codes.</p><p>The content of the PNC bit vector is provided/required by the Network Management.</p></blockquote><p>ComM 和 PNC 和 NM 之间的交互，ComM 应提供回调函数，以便将外部 PNC 激活请求作为 PNC 位矢量接收，然后转发，PNC 位向量的内容由 NM 提供 / 要求。</p><blockquote><p><strong draft="">[SRS_ModeMgm_09278]</strong> <strong>The Communication Manager shall support synchronous and asynchronous request upon a indicated wakeup</strong></p><p><strong draft="">[SRS_ModeMgm_09279]</strong> <strong>The Communication Manager shall support a coordinated release of PNCs</strong></p></blockquote><p>一些支持项</p><blockquote><p><strong>[SRS_ModeMgm_09251] PNC communication state shall be forwarded to the BswM</strong></p></blockquote><p>因为要涉及其他模块所以要把 PNC 的状态告诉 BswM</p><blockquote><p><strong draft="">[SRS_ModeMgm_09256]</strong> <strong>PNC Gateway Functionality shall consider systems with more than one gateways connected to the same network</strong></p><p>If there are multiple PNC Gateways within the system, then mirroring of cluster-requests need to be limited to avoid keeping awake each other (forwarding of cluster-requests is unaffected). For this, the following distinction shall be possible:</p><ul><li>Channel Connector of PNC Gateway is of type "active", then PNC requests are forwarded and mirrored on the channel</li><li>Channel Connector of PNC Gateway is of type "passive", then PNC requests are only forwarded, but not mirrored on the channel</li><li>Channel Connector of PNC Gateway is of type "none", then PNC requests are not forwarded and not mirrored back on the channel</li></ul><p>Constraint: If there are multiple PNC Gateways within the system, there shall always be one Gateway on top of the PNC Gateways hierarchical topology.</p></blockquote><p>也要考虑多个 gateways 连接到同一个网络下的情况分三种类型</p><blockquote><p><strong draft="">[SRS_ModeMgm_09257]</strong> <strong>ComM shall forward PNC-Clusters also to busses that are currently not awake</strong></p><p><strong draft="">[SRS_ModeMgm_09258]</strong> <strong>Optional Dynamic Extension of PNC Gateway</strong></p><p>The PNC Gateway shall be extended to support a dynamic PNC Learning mechanism</p></blockquote><p>牛啊，还支持动态学习</p><blockquote><p><strong draft="">[SRS_ModeMgm_09259]</strong> <strong>ComM API shall provide interfaces to access PNC Mapping (optional)</strong></p><p>The API of the ComM shall provide interfaces for the configurable PNC Mapping stored in NVRAM:</p><ul><li>to read out the current entries (includes "statically" entries) *</li><li>to update / add entries (optional) *</li><li>to reset all entries ("statically" entries will be unaffected)</li></ul><p>* for testing reasons only</p></blockquote><p>要有这个接口</p><blockquote><p><strong draft="">[SRS_ModeMgm_09260]</strong> <strong>ComM API shall provide an interface to start PNC Learning mechanism for PNC Mapping (optional)</strong></p><p><strong draft="">[SRS_ModeMgm_09261]</strong> <strong>ComM shall forward the information for Partial Networking Learning (optional)</strong></p><p><strong draft="">[SRS_ModeMgm_09262]</strong> <strong>ComM shall set all its assigned PNCs when partial networking learning is requested (optional)</strong></p></blockquote><p>各种学习</p><blockquote><p><strong draft="">[SRS_ModeMgm_09263]</strong> <strong>ComM API shall provide an interface to set PNC-membership on Host-ECU (optional)</strong></p><p><strong draft="">[SRS_ModeMgm_09264]</strong> <strong>ComM API shall provide an interface to configure PN filter mask (optional)</strong></p></blockquote><p>提供接口</p><blockquote><p><strong draft="">[SRS_ModeMgm_09265]</strong> <strong>ComM shall send the information for Partial Networking Learning (optional)</strong></p></blockquote><p>ComM 应为部分联网学习发送信息</p><blockquote><p><strong>[SRS_ModeMgm_09266] ComM shall support communication channels that act as communication slaves with wake-up capability</strong></p></blockquote><p>ComM 应支持作为具有唤醒能力的通信从机的通信信道</p><blockquote><p><strong draft="">[SRS_ModeMgm_09267]</strong> <strong>ComM shall support communication channels which act as communication slaves without wake-up capability</strong></p><p><strong>[SRS_ModeMgm_09268] ComM shall support the possibility to forward the information if the communication request is active or passive to it’s lower layer layer</strong></p><p><strong draft="">[SRS_ModeMgm_09269]</strong> <strong>The Communication Manager shall support synchronized PNC shutdown</strong></p></blockquote><p>就支持这些玩意</p><blockquote><p><strong>[SRS_ModeMgm_09090] Relationship between users and physical channels shall be configurable at pre compile time</strong></p><p><strong>[SRS_ModeMgm_09133] It shall be possible to assign physical channels to the Communication Manager</strong></p><p><strong>[SRS_ModeMgm_09132] It shall be possible to assign Network Management to physical channels</strong></p><p><strong>[SRS_ModeMgm_09141] The Communication Manager shall be able to configure the physical channel wake-up prevention</strong></p><p><strong>[SRS_ModeMgm_09243] The Communication Manager shall be able to handle the Partial Networks on Flexray, CAN and Ethernet</strong></p><p><strong>[SRS_ModeMgm_09244] The number of supported PNCs shall be configurable strictly at pre-compile time</strong></p><p><strong>[SRS_ModeMgm_09245] Enabling or disabling the Partial Network Cluster management in ComM shall be post-build selectable.</strong></p><p><strong>[SRS_ModeMgm_09207] ComM shall allow for additional bus specific state managers</strong></p></blockquote><p>都是要支持配置的</p><h3 id="44-basic-software-mode-manager"><a class="anchor" href="#44-basic-software-mode-manager">#</a> 4.4 Basic Software Mode Manager</h3><p><strong>Functional Overview</strong></p><blockquote><p>The VFB defines and the RTE implements the concept of Mode Declaration Groups.</p></blockquote><p>VFB 定义模式声明组，RTE 实现模式声明组的概念。</p><blockquote><p>There can be multiple Mode Declaration Groups that are independent of each other.E.g. in Figure 1 the Mode Declaration Group is "AMM_KeySwitch" and the Modes in this group are "Off", "Accessory", "Ignition".</p></blockquote><p>可以有多个彼此独立的模式声明组。例如，在图 1 中，式声明组为 “AMM_KeySwitch”，该组中的模式为 “Off”“Accessory” 和 “Ignition”。</p><blockquote><p>A Mode Declaration Group can not contain parallel Modes. Parallel Modes must be implemented by separate Mode Declaration Groups. E.g. diagnostic modes are independent of key switch modes, i.e., they go into a validMode Declaration Group "AMM_Diagnostics".</p></blockquote><p>模式声明组不能包含并行模式。并行模式必须由单独的模式声明组实现。例如，诊断模式与键开关模式无关，即它们进入有效的模式声明组 “AMM_Diagnostics”</p><blockquote><p>There is no hierarchy of Modes within a Mode Group. E.g. "Diagnostics_On" and "Diagnostics_Off" cannot have sub-modes.</p></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240820134255891.png" alt="image-20240820134255891"></p><p><strong>Interfaces between Mode -Requester, -Manager and -User</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240820134342051.png" alt="image-20240820134342051"></p><p><strong>Relation of Modes</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240820134756896.png" alt="image-20240820134756896"></p><p>这些层级的模式都是彼此影响的</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240820134942160.png" alt="image-20240820134942160"></p><p><strong>Functional Requirements</strong></p><blockquote><p><strong>[SRS_ModeMgm_09174] The BSW Mode Manager shall support the ’disable normal Communication’</strong></p></blockquote><p>支持禁用正常通信</p><blockquote><p>It shall be possible to disable normal communication and at the same time keep a predefined set of PDU groups active including diagnostic communication.</p></blockquote><p>可以禁用正常通信，同时保持一组预定义的 PDU 组处于活动状态，包括诊断通信。</p><blockquote><p><strong>[SRS_ModeMgm_09179] The BSW Mode Manager shall provide an Interface to allow Mode Requests of SW-C’s</strong></p><p><strong>[SRS_ModeMgm_09228] The BSW Mode Manager shall provide an Interface to allow Mode Requests of BSW Modules</strong></p></blockquote><p>给上下提供接口</p><blockquote><p><strong>[SRS_ModeMgm_09180] The BSW Mode Manager shall evaluate the current mode requests</strong></p><p><strong>[SRS_ModeMgm_09182] The BSW Mode Manager shall propagate a performed mode change to all local SW-Cs</strong></p><p><strong>[SRS_ModeMgm_09184] The mode manager shall be able to use a COM interface to activate, respectively deactivate, I-PDU groups</strong></p><p><strong>[SRS_ModeMgm_09229] The mode manager shall be able to make generic, configured callouts of void functions to other BSW modules</strong></p><p><strong>[SRS_ModeMgm_09230] All actions shall only be performed on mode change</strong></p></blockquote><p>所有的动作都只有在模式改变时执行，卧槽有所感悟。</p><p>写代码就首先写一个模式管理的，之后设定出用到的几个模式，然后设计各个模式之间切换的动作</p><p>初始化也是状态，卧槽悟了</p><blockquote><p><strong>[SRS_ModeMgm_09240] ComM shall notify BswM of any PNC communication state change</strong></p></blockquote><p>前面好像说过这个吧</p><blockquote><p><strong>[SRS_ModeMgm_09241] BswM shall be able to request communication modes for existing CommUsers</strong></p><p><strong>[SRS_ModeMgm_09253] The BswM shall be able to set the halt mode for each single CPU Core independently</strong></p></blockquote><p>一些模式吧我觉得</p><blockquote><p><strong>[SRS_ModeMgm_09177] The rules of the mode arbitration shall be pre-compile and post-build configurable</strong></p><p><strong>[SRS_ModeMgm_09178] The lists of mode transition specific actions shall be pre-compile and post-build configurable</strong></p><p><strong>[SRS_ModeMgm_09175] A configurable Set of Mode dependent enabled and concomitant disabled IPDU groups shall be supported</strong></p><p><strong>[SRS_ModeMgm_09176] Configurable Sets of Mode dependent enabled I-PDU Groups shall be supported</strong></p><p><strong>[SRS_ModeMgm_09183] Configurable Mode Activation initiated Reset of Signals to Initial Values shall be supported</strong></p></blockquote><p>这些配置要支持</p><h1 id="ecustatemanager"><a class="anchor" href="#ecustatemanager">#</a> ECUStateManager</h1><h2 id="1-introduction-and-functional-overview"><a class="anchor" href="#1-introduction-and-functional-overview">#</a> 1 Introduction and Functional Overview</h2><blockquote><p>The ECU Manager module (as specified in this document) is a basic software module (see [1]) that manages common aspects of ECU states. Specifically, the ECU Manager module:</p><ul><li>Initializes and de-initializes the OS, the SchM and the BswM as well as some basic software driver modules.</li><li>configures the ECU for SLEEP and SHUTDOWN when requested.</li><li>manages all wakeup events on the ECU</li></ul></blockquote><p>ECUM 是 BSW 层</p><ul><li>管理初始化 OS、SchM、BswM、以及一些基本的软件驱动模块</li><li>管理 ECU 的状态</li><li>管理唤醒事件</li></ul><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240724153319855.png" alt="image-20240724153319855"></p><blockquote><p>The ECU Manager module provides the wakeup validation protocol to distinguish ’real’ wakeup events from ’erratic’ ones.</p></blockquote><p>EcuM 提供了唤醒验证协议，来区分真实唤醒和不稳定唤醒</p><blockquote><p>Furthermore:</p><ul><li>Partial or fast startup where he ECU starts up with limited capabilities and later, as determined by the application, continues startup step by step.</li><li>Interleaved startup where the ECU starts minimally and then starts the RTE to execute functionality in SW-Cs as soon as possible. It then continues to start further BSW and SW-Cs, thus interleaving BSW and application functionality..</li><li>Multiple operational states where the ECU has more than one RUN state. This, among other things, refines the notion of a spectrum of SLEEP states to RUN states. There can now be a continuum of operational states spanning from the classic RUN (fully operational) to the deepest SLEEP (processor halted).</li><li>Multi-Core ECUs: STARTUP, SHUTDOWN, SLEEP and WAKEUP are coordi nated on all cores of the ECU.</li></ul></blockquote><p>此外</p><ul><li>部分或快速启动，ECU 以有限的功能启动，然后根据应用程序的决定，继续逐步启动。</li><li>交错启动，ECU 最小启动，然后启动 RTE 以尽快执行 SW-Cs 中的功能。然后，它继续启动进一步的 BSW 和 SW-Cs，从而将 BSW 和应用程序功能交织在一起。</li><li>多个运行状态，ECU 具有多个 RUN 状态。这将睡眠状态谱的概念细化为运行状态。现在可以有一系列操作状态，从经典的 RUN (完全运行) 到最深的睡眠 (处理器停止)</li><li>多核 ECU: 启动，关闭，睡眠和唤醒是协调在所有核心的 ECU。</li></ul><blockquote><p>Flexible ECU management employs the generic mode management facilities provided by the following modules:</p><ul><li>RTE and BSW Scheduler module [2] are now amalgamated into one module: This module supports freely configurable BSW and application modes and their mode-switching facilities.</li><li>BSW Mode Manager module [3]: This module implements configurable rules and action lists to evaluate the conditions for switching ECU modes and to implement the necessary actions to do so.</li></ul></blockquote><p>BswM 模块配合 EcuM 来实现模式切换</p><blockquote><p>Thus with Flexible ECU Management, most ECU states are no longer implemented in the ECU Manager module itself. In general, the ECU Manager module takes over control when the generic mode management facilities are unavailable in:</p><ul><li>Early STARTUP phases,</li><li>Late SHUTDOWN phases,</li><li>SLEEP phases where the facilities are locked out by the scheduler</li></ul><p>During the UP Phase of the ECU Manager module the BSW Mode Manager is responsible for further actions. Whereas, the ECU Manager module arbitrates RUN and POST_RUN Requests from SW-Cs and notifies BswM about the status of the modes.</p></blockquote><p>在 ECU 管理器模块的 UP 阶段，BSW 模式管理器负责进一步的行动，而 ECU 管理器模块则仲裁来自 SW-C 的 RUN 和 POST RUN 请求，并通知 BSwM 关于式的状态。</p><h2 id="7-functional-specification"><a class="anchor" href="#7-functional-specification">#</a> 7 Functional Specification</h2><h3 id="71-phases-of-the-ecu-manager-module"><a class="anchor" href="#71-phases-of-the-ecu-manager-module">#</a> 7.1 Phases of the ECU Manager Module</h3><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240724161658298.png" alt="image-20240724161658298"></p><blockquote><p><strong>7.1.1</strong> <strong>STARTUP Phase</strong></p><p>The purpose of the STARTUP phase is to initialize the basic software modules to the</p><p>point where Generic Mode Management facilities are operational.</p><p><strong>7.1.2</strong> <strong>UP Phase</strong></p><p><strong>7.1.3</strong> <strong>SHUTDOWN Phase</strong></p><p><strong>7.1.4</strong> <strong>SLEEP Phase</strong></p><p>The ECU saves energy in the SLEEP phase.</p><p>The ECU Manager module wakes the ECU up in response to intended or unintended wakeup events. Since unintended wakeup events should be ignored, the ECU Manager module provides a protocol to validate wakeup events. The protocol specifies a cooperative process between the driver which handles the wakeup source and the ECU Manager (see section 7.6.4 ).</p><p>响应预期或者非预期的唤醒事件，并且有响应的唤醒验证机制</p><p><strong>7.1.5</strong> <strong>OFF Phase</strong></p></blockquote><h3 id="72-structural-description-of-the-ecu-manager"><a class="anchor" href="#72-structural-description-of-the-ecu-manager">#</a> 7.2 Structural Description of the ECU Manager</h3><p><strong>Standardized AUTOSAR Software Modules</strong></p><blockquote><p>Some Basic Software driver modules are initialized, shut down and re-initialized upon wakeup by the ECU Manager module.</p><p>The OS is initialized and shut down by the ECU Manager.</p><p>After the OS initialization, additional initialization steps are undertaken by the ECU Manager module before passing control to the BswM. The BswM hands execution control back to the ECU Manager module immediately before OS shutdown. Details are provided in the chapters 7.3 STARTUP and 7.4 SHUTDOWN .</p></blockquote><p>一些标准化的软件模块</p><p><strong>Software Components</strong></p><blockquote><p>SW-Components contain the AUTOSAR ECU’s application code. A SW-C interacts with the ECU Manager module using AUTOSAR ports.</p></blockquote><h3 id="73-startup-phase"><a class="anchor" href="#73-startup-phase">#</a> 7.3 STARTUP Phase</h3><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240724181823042.png" alt="image-20240724181823042"></p><p><strong>StartPreOS Sequence</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240725110729816.png" alt="image-20240725110729816"></p><p><strong>Activities in the StartPostOS Sequence</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240725111024887.png" alt="image-20240725111024887"></p><h3 id="74-shutdown-phase"><a class="anchor" href="#74-shutdown-phase">#</a> 7.4 SHUTDOWN Phase</h3><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162235012.png" alt="image-20240823162235012"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162326111.png" alt="image-20240823162326111"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162348543.png" alt="image-20240823162348543"></p><h3 id="75-sleep-phase"><a class="anchor" href="#75-sleep-phase">#</a> 7.5 SLEEP Phase</h3><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162413491.png" alt="image-20240823162413491"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162521318.png" alt="image-20240823162521318"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162542307.png" alt="image-20240823162542307"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823162654622.png" alt="image-20240823162654622"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823163040612.png" alt="image-20240823163040612"></p><h3 id="76-up-phase"><a class="anchor" href="#76-up-phase">#</a> 7.6 UP Phase</h3><blockquote><p>In the UP Phase, the EcuM_MainFunction is executed regularly and it has three major functions:</p><ul><li>To check if wakeup sources have woken up and to initiate wakeup validation, if necessary (see 7.6.4 Activities in the WakeupValidation Sequence)</li><li>To update the Alarm Clock timer</li><li>Arbitrate RUN and POST_RUN requests and releases.</li></ul></blockquote><p>在 UP 阶段，EcuM MainFunction 会定期执行，它有三个主要功能:</p><ul><li>检查唤醒源是否已唤醒，并在必要时启动唤醒验证 (参见唤醒验证序列中的 7.6.4 活动)</li><li>更新闹钟定时器</li><li>对 RUN 和 POST_RUN 请求和释放进行仲裁。</li></ul><p><strong>Alarm Clock Handling</strong></p><p><strong>Interaction of Wakeup Sources and the ECU Manager</strong></p><p><strong>Wakeup Validation Timeout</strong></p><p><strong>Requirements for Drivers with Wakeup Sources</strong></p><p><strong>Requirements for Wakeup Validation</strong></p><p><strong>Wakeup Sources with Integrated Power Control</strong></p><h3 id="77-shutdown-targets"><a class="anchor" href="#77-shutdown-targets">#</a> 7.7 Shutdown Targets</h3><blockquote><p>"Shutdown Targets" is a descriptive term for all states ECU where no code is executed.</p><p>They are called shutdown targets because they are the destination states where the state machine will drive to when the UP phase is left. The following states are shutdown targets:</p><ul><li>Off</li><li>Sleep</li><li>Reset</li></ul></blockquote><h3 id="78-alarm-clock"><a class="anchor" href="#78-alarm-clock">#</a> 7.8 Alarm Clock</h3><h3 id="79-multicore"><a class="anchor" href="#79-multicore">#</a> 7.9 MultiCore</h3><blockquote><p>The BSW modules can be distributed over different partitions and therefore over different cores. Some BSW modules as the BswM have to be included into every partition. Other modules like the OS or the EcuM have be included into one partition per core.</p></blockquote><p>BSW 模块可以分布在不同的分区中，因此可以分布在不同的核心上。一些 BSW 模块，如 BsWM，必须包含在每个分区中。其他模块，如 OS 或 EcuM，必须包含在一个分区中。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823170909487.png" alt="image-20240823170909487"></p><blockquote><p>In a multi core architecture the EcuM has to be distributed in a way, that one instance per core exists.</p></blockquote><p>在多核心架构中，EcuM 必须以每个核心存在一个实例的方式进行分布。</p><blockquote><p>There is one designated master core in which the boot loader starts the master EcuM via EcuM_Init.</p></blockquote><p>有一个指定的主核心，引导加载程序在其中通过 EcuM_Init 启动主 EcuM。</p><blockquote><p>The master EcuM starts some drivers, determines the Post Build configuration and starts all remaining cores with all their satellite EcuMs.</p></blockquote><p>主 EcuM 启动一些驱动程序，确定构建后配置，并使用其所有卫星 EcuM 来启动所有剩余的核心。</p><blockquote><p>Each EcuM now starts the core local OS and all core local BswMs (in every partition resides exactly one BswM).</p></blockquote><p>每个 EcuM 现在都启动核心本地操作系统和所有核心本地 BswM (每个分区中都驻留着一个 BsWM</p><blockquote><p>If the same image of EcuM is executed on every core of the ECU, the ECU Manager’s behavior has to differ on the different cores.</p></blockquote><p>如果 EcuM 的相同映像在 ECU 的每个核心上执行，则 ECU Manager 在不同的核心上的行为必须有所不同。</p><blockquote><p>This can be accomplished by the ECU Manager by testing first whether it is on a master or a slave core and act appropriately.</p></blockquote><p>这可以通过 ECU 管理器来完成，首先测试它是否位于主核心或从属核心上，并采取适当的行动。</p><blockquote><p>The ECU Manager module supports the same phases on a MultiCore ECU as are available on conventional ECUs (i.e. STARTUP, UP, SHUTDOWN and SLEEP).</p></blockquote><p>ECU Manager 模块支持与传统 ECU 相同的多核 ECU 阶段 (即 STARTUP、UP、SHUTDOWN 和 SLEEP)</p><blockquote><p>If safety mechanisms are used, The ECU State Manager has to run with full trust level.</p></blockquote><p>如果使用安全机制，ECU 状态管理器必须在完全信任级别运行。</p><blockquote><p>This section uses previous ECU Manager terms for various ECU states, notably Run/PostRun.</p></blockquote><p>本节使用以前的 ECU Manager 术语来描述各种 ECU 状态，特别是 Run/PostRun。</p><blockquote><p>With flexible ECU management, the system integrator determines the ECU’s states’ names and semantics.</p></blockquote><p>通过灵活的 ECU 管理，系统集成商确定 ECU 的状态名称和语义。</p><blockquote><p>Methods to ensure a de-initialization phase must be upheld, however. The names used here are therefore not normative.</p></blockquote><p>但是，必须坚持确保去初始化阶段的方法，因此这里使用的名称不是规范性的。</p><p><strong>Master Core</strong></p><blockquote><p>There is one explicit master core. Which core the master core is, is determined by the boot loader.</p></blockquote><p>有一个显式的主核，主核是什么，由引导加载程序决定。</p><blockquote><p>The EcuM of the master core gets started as first BSW module and performs initialization actions.</p></blockquote><p>主核心的 EcuM 作为第一个 BSW 模块启动，并执行初始化操作。</p><blockquote><p>Then is starts all other cores with all other EcuMs.</p></blockquote><p>然后用所有其他 EcuM 启动所有其他核心。</p><blockquote><p>When these are started, it initializes together with each satellite EcuM the core local OS and BswM.</p></blockquote><p>当这些启动时，它会与每个卫星 EcuM 一起初始化核心本地操作系统和 BsWM。</p><p><strong>Slave Core</strong></p><blockquote><p>On every slave core, one satellite EcuM has to run. If a core contains more than one partition, only on EcuM per core has to exist.</p></blockquote><p>在每个从属核心上，必须运行一个卫星 EcuM。如果一个核心包含多个分区，每个核心必须只存在于 EcuM 上。</p><p><strong>Master Core - Slave Core Signalling</strong></p><blockquote><p>This section discusses the general mechanisms with which BSW can communicate over cores. It presupposed general knowledge of the SchM, which is described and specified in the RTE.</p></blockquote><p>本节讨论了 BSW 在核心上进行通信的一般机制，前提是人们对 SchM 有一定的了解，这在 RTE 中已经作了描述和阐述。</p><blockquote><p>The Operating System provides a basic mechanism for synchronizing the starts of the operating systems on the master and slave cores.</p></blockquote><p>操作系统提供了一个基本机制，用于同步操作系统在主从内核上的启动。</p><blockquote><p>The Scheduler Manager provides basic mechanisms for communication of BSW modules across partition boundaries.</p></blockquote><p>Scheduler Manager 为 BSW 模块跨分区边界通信提供了基本机制。</p><blockquote><p>One BSW Mode Manager per core is responsible for starting and stopping the RTE.</p></blockquote><p>每个核心中有一个 BSW 模式管理器负责启动和停止 RTE。</p><p><strong>Example for Shutdown Synchronization</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826134415650-172510160353732.png" alt="image-20240826134415650"></p><p><strong>UP Phase</strong></p><blockquote><p>From the hardware perspective, it is possible that wakeup interrupts could occur on all cores. Then the whole ECU gets woken up and the EcuM running on that processes the wakeup event.</p></blockquote><p>从硬件角度来看，所有内核都可能发生唤醒中断，然后整个 ECU 被唤醒，运行在该 ECU 上的 EcuM 处理唤醒事件。</p><p><strong>STARTUP Phase</strong></p><blockquote><p>The ECU Manager module functions nearly identically on all cores. That is, as for the single-core case, the ECU Manager module performs the steps specified for Startup;</p></blockquote><p>ECU Manager 模块在所有内核上的功能几乎相同，即对于单内核的情况，ECU Manager 模块执行指定的启动步骤；</p><blockquote><p>most importantly starting the OS, initializing the SchM and starting the core local BswMs.</p></blockquote><p>最重要的是启动操作系统，初始化 SchM 并启动核心本地 BswM。</p><blockquote><p>After each EcuM has called StartOs on its core, the OS synchronizes the cores before executing the core-individual startup hooks and synchronizes the cores again before executing the first tasks on each core.</p></blockquote><p>每个 EcuM 在其核心上调用 StartOs 后，OS 在执行核心级启动挂钩之前同步核心，并在每个核心上执行第一个任务之前再次同步核心。</p><blockquote><p>StartPostOS is executed on each core and the SchM is initialized on each core. All core local BswMs are initialized by each EcuM.</p></blockquote><p>StartPostOS 在每个核心上执行，SchM 在每个核心初始化。所有核心本地 BswMs 都由每个 EcuM 初始化。</p><blockquote><p>One BswM on every partition has to start the RTE for that core.</p></blockquote><p>每个分区上有一个 BswM 必须为该核心启动 RTE.</p><p><strong>Master Core STARTUP</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135159450-172510162535834.png" alt="image-20240826135159450"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135243337.png" alt="image-20240826135243337"></p><p><strong>Slave Core STARTUP</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135405363.png" alt="image-20240826135405363"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135454522.png" alt="image-20240826135454522"></p><p><strong>SHUTDOWN Phase</strong></p><blockquote><p>When the ECU shall be shut down, the master ECU Manager module calls ShutdownAllCores rather than somehow calling ShutdownOS on the individual cores. The ShutdownAllCores stops the OS on all cores and stops all cores as well.</p></blockquote><p>目前只支持所有核心同时关闭</p><p><strong>Master Core SHUTDOWN</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135814637.png" alt="image-20240826135814637"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135832000.png" alt="image-20240826135832000"></p><p><strong>Slave Core SHUTDOWN</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135921626.png" alt="image-20240826135921626"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826135936834.png" alt="image-20240826135936834"></p><p><strong>SLEEP Phase</strong></p><p>就是要同步，无聊死了</p><p><strong>Runnables and Entry points</strong></p><p>P93 没看懂干啥的</p><h3 id="710-ecum-mode-handling"><a class="anchor" href="#710-ecum-mode-handling">#</a> 7.10 EcuM Mode Handling</h3><blockquote><p>The ECU State Manager provides interfaces for SW-Cs to request and release the modes RUN and POST_RUN optionally.</p></blockquote><p>ECU 状态管理器为 SWC 提供接口，可选择地请求和释放 RUN 和 POST_RUN 模式。</p><blockquote><p>EcuMFlex arbitrates the requests and releases made by SW-Cs and propagates the result to BswM.</p></blockquote><p>EcuMFlex 对 SWC 提出的请求和释放进行仲裁，并将结果传播到 BswM。</p><blockquote><p>The cooperation between EcuM and BswM is necessary as only the BswM can decide when a transition to a different mode can be made.</p></blockquote><p>EcuM 和 BsWM 之间的合作是必要的，因为只有 BswM 可以决定何时可以过渡到不同的模式。</p><blockquote><p>Due to the fact that the EcuM does not have an own state machine, the EcuM relies on the state transitions made by BswM.</p></blockquote><p>由于 EcuM 没有自己的状态机，所以 EcuM 依赖于 BswM 所做的状态转换。</p><blockquote><p>Therefore the EcuM does not request a state. Furthermore it notifies the BswM about the current arbitration of all requests.</p></blockquote><p>因此，EcuM 不请求某个状态，而且它将所有请求的当前仲裁情况通知 BswM。</p><blockquote><p>And the BswM is notified when the RTE has executed all Runnables belonging to a certain mode.</p></blockquote><p>当 RTE 执行了属于某个模式的所有 Runnables 时，BswM 将收到通知。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826140757779.png" alt="image-20240826140757779"></p><h3 id="711-advanced-topics"><a class="anchor" href="#711-advanced-topics">#</a> 7.11 Advanced Topics</h3><p><strong>Relation to Bootloader</strong></p><blockquote><p>The Bootloader is not part of AUTOSAR. Still, the application needs an interface to activate the bootloader. For this purpose, two functions are provided: EcuM_Select_BootTarget and EcuM_GetBootTarget .</p></blockquote><p>引导加载程序不是 AUTOSAR 的一部分。尽管如此，应用程序需要一个接口来激活引导加载程序。为此，提供了两个函数：EcuM_Select_BootTarget 和 EcuM_GetBootTarget 。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826141145160.png" alt="image-20240826141145160"></p><p><strong>Relation to Complex Drivers</strong></p><blockquote><p>If a complex driver handles a wakeup source, it must follow the protocol for handling wakeup events specified in this document.</p></blockquote><p><strong>Handling Errors during Startup and Shutdown</strong></p><blockquote><p>BSW modules are responsible themselves for reporting errors occurring during their initialization directly to the DEM module or the DET module, as specified in their SWSs.</p></blockquote><p>BSW 模块自行负责将初始化过程中发生的错误直接报告给 DEM 模块或 DET 模块，如其 SWS 中所指定的那样。</p><blockquote><p>The ECU Manager module does not report the errors. The BSW module is also responsible for taking any special measures to react to errors occurring during their initialization.</p></blockquote><p>ECU Manager 模块不报告错误。BSW 模块还负责采取任何特别措施来应对初始化过程中发生的错误。</p><h3 id="712-errorhook"><a class="anchor" href="#712-errorhook">#</a> 7.12 ErrorHook</h3><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826141436988.png" alt="image-20240826141436988"></p><h3 id="713-error-classification"><a class="anchor" href="#713-error-classification">#</a> 7.13 Error classification</h3><p><strong>Development Errors</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826141611330.png" alt="image-20240826141611330"></p><p><strong>Runtime Errors</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826141637010.png" alt="image-20240826141637010"></p><h2 id="9-sequence-charts"><a class="anchor" href="#9-sequence-charts">#</a> 9 Sequence Charts</h2><h3 id="91-state-sequences"><a class="anchor" href="#91-state-sequences">#</a> 9.1 State Sequences</h3><p>参照前面的状态切换序列图</p><h3 id="92-wakeup-sequences"><a class="anchor" href="#92-wakeup-sequences">#</a> 9.2 Wakeup Sequences</h3><p><strong>GPT Wakeup Sequences</strong></p><p>General Purpose Timer (GPT)</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826141923686.png" alt="image-20240826141923686"></p><p><strong>ICU Wakeup Sequences</strong></p><p>Input Capture Unit (ICU)</p><p>ICU 不是唤醒源，因此与 GPT 不同，它只是触发中断然后交由 EcuM 去检查唤醒信号</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826142206291.png" alt="image-20240826142206291"></p><p><strong>CAN Wakeup Sequences</strong></p><blockquote><p>On CAN a wake up can be detected by the transceiver or the communication controller using either an interrupt or polling. Wake up source identifiers should be shared between transceiver and controller as the ECU State Manager module only needs to know the network that has woken up and passes that on to the Communication Manager module.</p></blockquote><p>在 CAN 上，收发器或通信控制器可以使用中断或轮询来检测唤醒。唤醒源标识符应在收发器和控制器之间共享，因为 ECU 状态管理器模块只需要知道唤醒的网络，并将其传递给通信管理器模块。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826142620855.png" alt="image-20240826142620855"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826142814534.png" alt="image-20240826142814534"></p><p><strong>LIN Wakeup Sequences</strong></p><p><strong>FlexRay Wakeup Sequences</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826143106053.png" alt="image-20240826143106053"></p><p><strong>Ethernet Wakeup Sequence</strong></p><blockquote><p>On a Ethernet switched network with OA TC10 compliant Ethernet hardware a wake up can be detected by the used Ethernet hardware (PHY).</p></blockquote><p>在具有 OA TC10 兼容的以太网硬件的以太交换网络上，可用的以太网络硬件 (PHY) 可以检测到唤醒。</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826143417427.png" alt="image-20240826143417427"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826143433321.png" alt="image-20240826143433321"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826143454607.png" alt="image-20240826143454607"></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240826143508844.png" alt="image-20240826143508844"></p><h1 id="bswmodemanager"><a class="anchor" href="#bswmodemanager">#</a> BSWModeManager</h1><h2 id="1-introduction-and-functional-overview-2"><a class="anchor" href="#1-introduction-and-functional-overview-2">#</a> 1 Introduction and functional overview</h2><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240820174856654.png" alt="image-20240820174856654"></p><blockquote><p>This specification specifies the functionality, API and the configuration of the AUTOSAR Basic Software module BSW Mode Manager (BswM).</p><p>The BSW Mode Manager is the module that implements the part of the Vehicle Mode Management and Application Mode Management concept that resides in the BSW.</p><p>Its responsibility is to arbitrate mode requests from application layer SW-Cs or other BSW modules based on simple rules, and perform actions based on the arbitration result.</p></blockquote><p>就是要标准化这个 BSWM</p><p>BSW 模式管理器是实现 BSW 中车辆模式管理和应用模式管理概念的部分，</p><p>其职责是基于简单规则对应用层 SWC 或其他 BSW 模块的模式请求进行仲裁，并根据仲裁结果执行操作。</p><h2 id="5-dependencies-to-other-modules"><a class="anchor" href="#5-dependencies-to-other-modules">#</a> 5 Dependencies to other modules</h2><ul><li><p><strong>RTE</strong></p><ul><li>The BswM receives mode requests from the SW-Cs via the RTE. Mode Switch Notifications are also propagated to the SW-Cs via the RTE.</li></ul></li><li><p><strong>EcuM - Flex</strong></p><ul><li>EcuM Flex can indicate the state of its wakeup sources to BswM. When ECU Mode Handling is used, BswM can set the state of EcuM - Flex and receives status of certain modes based on the RUN Request Protocol.</li></ul></li><li><p><strong>ComM</strong></p><ul><li>Mode Switch Indications originating from the ComM go through the BswM for further propagation to the SW-Cs. The BswM can request communication modes at the ComM by means of ComMUsers.</li></ul></li><li><p><strong>COM</strong></p><ul><li>The handling of I-PDU Groups in COM is performed by the BswM. As a part of IPDU group start/stop, it is possible to have the included signal values reset to their corresponding initialization values. BswM handles the enabling and disabling of deadline monitoring of signals in COM.BswM can also trigger transmission of an I-PDU.</li></ul></li><li><p><strong>PduR</strong></p><ul><li>The BswM can enable and disable routing groups of I-PDUs in the PDU router.</li></ul></li><li><p><strong>CanSM</strong></p><ul><li>Mode Switch Indications originating from the CanSM go through the BswM for further propagation to the SW-Cs.</li></ul></li><li><p><strong>LinSM</strong></p><ul><li>BswM coordinates switching of LIN Schedule Tables in the LinSM with starting and stopping of the corresponding I-PDU groups in COM.</li><li>Mode Switch Indications originating from the LinSM go through the BswM for further propagation to the SW-Cs.</li></ul></li><li><p><strong>LinTp</strong></p><ul><li>The LIN Transport Protocol that is a part of LinIf requests modes from BswM to makesure that the correct LIN Schedule Table is active during LinTp operation.</li></ul></li><li><p><strong>FrSM</strong></p><ul><li>Mode Switch Indications originating from the FrSM go through the BswM for further propagation to the SW-Cs.</li><li>The usage of "Single Slot Mode" on FlexRay is controlled by the FrSM by request of BswM. The send capability of the FlexRay stack can be controlled by the BswM via FrSM by calling the API FrSM_SetEcuPassive.</li></ul></li><li><p><strong>EthSM</strong></p><ul><li>Mode Switch Indications originating from the EthSM go through the BswM for further propagation to the SW-Cs.</li></ul></li><li><p><strong>DCM</strong></p><ul><li><p>The DCM performs mode requests to the BswM based on the diagnostic requests it receives.</p></li><li><p>Example: DCM can request "Disable Normal Communication". During this mode BswM</p><p>will turn off the corresponding I-PDU groups and NM PDUs.</p></li></ul></li><li><p><strong>J1939Dcm</strong></p><ul><li>The J1939Dcm reports communication state changes to the BswM for further propagation to the SW-Cs. BswM changes states of J1939Dcm via J1939Dcm_SetState.</li></ul></li><li><p><strong>J1939Nm</strong></p><ul><li>The J1939Nm provides a state indication via BswM_J1939Nm_StateChangeNotification.</li></ul></li><li><p><strong>J1939Rm</strong></p><ul><li>BswM changes states of J1939Rm via J1939Rm_SetState.</li></ul></li><li><p><strong>NM Interface</strong></p><ul><li>BswM will use the Nm_EnableCommunication and Nm_DisableCommunication to control the NM communication based on the current mode.</li><li>Example: In "Disable Normal Communication" mode, the BswM needs to disable NM communication on the corresponding NM channel.</li><li>The Nm uses BswM_Nm_CarWakeUpIndication to indicate a CarWakeup.</li></ul></li><li><p><strong>NvM</strong></p><ul><li>The NvM module reports the state of its blocks to the BswM via "integration code" registered as NvM callbacks. BswM has actions causing the NvM to read and write all blocks during startup and shutdown.</li></ul></li><li><p><strong>OS</strong></p><ul><li>The features of OS that are required by BswM, are implementation specific.</li></ul></li><li><p><strong>Sd</strong></p><ul><li>The BswM receives status indications from Sd via several exported APIs (see chapter 8.3 for examples). These status indications from Sd can be configured as BswMModeRequestSources.</li></ul></li></ul><h2 id="7-functional-specification-2"><a class="anchor" href="#7-functional-specification-2">#</a> 7 Functional specification</h2><blockquote><p>This chapter specifies the functional behavior of the BSW Mode Manager. The operation of the BSW Mode Manager basic functionality can be described as two different tasks: Mode Arbitration and Mode Control.</p></blockquote><p>BSW 模式管理器基本功能的操作可以描述为两个不同的任务:</p><ul><li>模式仲裁</li><li>模式控制</li></ul><blockquote><p>The Mode Arbitration part initiates mode switches resulting from rule-based arbitration of mode requests and mode indications received from SW-Cs or other BSW modules.</p></blockquote><p>模式仲裁部分启动（从 SW-Cs 或其他 BSW 模块接收的（模式请求）和（模式指示）的基于规则的仲裁导致的）模式切换。</p><blockquote><p>The Mode Control part performs the mode switches by execution of action lists containing mode switch operations of other BSW modules.</p></blockquote><p>模式控制部分通过执行包含其他 BSW 模块模式切换操作的操作列表来执行模式切换</p><blockquote><p>The BswM should be seen as a mode management framework module in which behavior is completely defined by its configuration.</p></blockquote><p>BswM 应该被看作是一个模式管理框架模块，其中的行为完全由其配置来定义。</p><blockquote><p>There may be different ways of implementing the BswM, such as generation of the complete BswM based on the configuration, or as a rule interpreter that parses an encoded configuration at run time.</p></blockquote><p>可能有不同的实现 BswM 的方式，例如根据配置生成完整的 BsWM，或者作为规则解释器在运行时解析编码配置。</p><blockquote><p>However, this specification does not intend to specify any implementation details of the BSW Mode Manager. Hence, any examples stated in this document describing design details should be treated as explanatory text and not as requirements.</p></blockquote><p>然而，该规范并不打算指定 BSW 模式管理器的任何实现细节。因此，本文件中描述设计细节的任何示例都应被视为解释性文本，而不是要求。</p><h3 id="mode-arbitration"><a class="anchor" href="#mode-arbitration">#</a> Mode Arbitration</h3><blockquote><p>The Mode Arbitration performed by the BswM is simple and rule-based. The rules used for mode arbitration are specified in the configuration of the BSW Mode Manager module.</p></blockquote><p>BswM 执行的模式仲裁是简单且基于规则的，模式仲裁使用的规则在 Bsw 模式管理器模块的配置中指定。</p><p><strong>Arbitration Rules</strong></p><blockquote><p>A rule is a logical expression that is composed of a set of mode request conditions.</p></blockquote><p>规则是逻辑表达式，由一组模式请求条件组成。</p><p><strong>Mode Conditions and Logical Expressions.</strong></p><blockquote><p>The logical expression that comprises a mode arbitration rule can use different operators such as</p><ul><li>AND</li><li>OR</li><li>XOR</li><li>NOT</li><li>NAND</li></ul></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240821165600924.png" alt="image-20240821165600924"></p><p><strong>Requirements of Mode Arbitration</strong></p><blockquote><p>As mentioned above, the BswM accepts mode requests and mode indications as input for the mode arbitration.</p></blockquote><p>如上所述，BswM 接受模式请求和模式指示作为模式仲裁的输入。</p><p><strong>Immediate and Deferred Operation</strong></p><blockquote><p>There are two different ways to schedule the processing of the mode arbitration.</p><p>It is either done immediately within the context of a mode request/indication,</p><p>or deferred (cyclically) to the main function of the BswM.</p></blockquote><p>两种模式立即操作和延迟操作</p><p><strong>Arbitration Behavior after Initialization</strong></p><h3 id="mode-control"><a class="anchor" href="#mode-control">#</a> Mode Control</h3><blockquote><p>The Mode Control part of BswM performs all required actions based on the results of the mode arbitration.</p></blockquote><p>根据模式仲裁的结果进行执行所必须的操作</p><blockquote><p>The actions in an Action List can be of three types:</p><ol><li><p>Calls to other BSW modules or the RTE. A set of pre-defined actions are listed in 7.2.4.</p></li><li><p>Links to other action lists to be included in the execution.</p></li><li><p>Mode arbitration rules. These rules will be evaluated when the corresponding action list is executed. In this way, a hierarchy of rules is obtained.</p></li></ol></blockquote><p>1. 调用 BSW 或者 RTE</p><p>2. 包含其他操作列表</p><p>3. 嵌套的仲裁规则</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240821173105981.png" alt="image-20240821173105981"></p><p><strong>Mode Processing Cycle</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240821173543692.png" alt="image-20240821173543692"></p><p><strong>Requirements on Mode Control</strong></p><p><strong>Triggered and Conditional action lists</strong></p><blockquote><p>There are two ways that an action list may be executed based on evaluation of rules.</p><p>Either it is executed every time the rule is evaluated with the corresponding result, or only when the evaluation result has changed from the previous evaluation.</p></blockquote><p>有两种方式：</p><ul><li>每次结果相同时执行</li><li>每次结果不同时执行</li></ul><p><strong>Available Actions</strong></p><p><strong>Behavior of Mode Control after Initialization</strong></p><p>用来配置第一次初始化后的执行规则</p><h3 id="waiting-functionality"><a class="anchor" href="#waiting-functionality">#</a> <strong>Waiting Functionality</strong></h3><blockquote><p>Sometimes it is necessary to delay specific actions or wait for further mode controls. For this reason a Timer handling was added to the BswM.</p></blockquote><p>有时需要延迟特定操作或等待进一步的模式控制。为此，在 BswM 中添加了计时器处理</p><h3 id="multi-partition-support"><a class="anchor" href="#multi-partition-support">#</a> Multi Partition Support</h3><blockquote><p>For multiple BswM instances, each BswM instance will generate its own separate service component description based on its own config set. The integrator will need to allocate these separate service components to the corresponding partition.</p><p>BswM is present in each partition with a partition specific configuration (separate instance of BswMConfig per partition). The contained action lists are executed partition locally</p></blockquote><p>对于多个 BswM 实例，每个 BswM 实例将根据自己的配置集生成自己的单独的服务组件描述。集成器需要将这些单独的服务组件分配给相应的分区。</p><h3 id="error-classification"><a class="anchor" href="#error-classification">#</a> Error classification</h3><blockquote><p>Section 7.2 "Error Handling" of the document "General Specification of Basic Software Modules" describes the error handling of the Basic Software in detail. Above all, it constitutes a classification scheme consisting of five error types which may occur in BSW modules.</p></blockquote><p>文档《基本软件模块通用规范》第 7.2 节 “错误处理” 详细描述了基本软件的错误处理，最重要的是，它构成了一个由 BSW 模块中可能出现的五种错误类型组成的分类方案。</p><p><strong>Development Errors</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823145641445.png" alt="image-20240823145641445"></p><p><strong>Runtime Errors</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823145721965.png" alt="image-20240823145721965"></p><h3 id="bswm-interfaces-and-ports"><a class="anchor" href="#bswm-interfaces-and-ports">#</a> BswM Interfaces and Ports</h3><blockquote><p>SW-Cs request modes from the BSW Mode Manager.</p></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823150150269.png" alt="image-20240823150150269"></p><blockquote><p>When the RTE performs the mode switch, it informs all connected entities (BSW Modules or SW-Cs) that are connected via Mode Switch R-Ports to the providing port.</p></blockquote><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823150834103.png" alt="image-20240823150834103"></p><p><strong>Mode Request Ports</strong></p><p><strong>Mode Switch Ports</strong></p><p><strong>Notifications of Mode Switches</strong></p><p><strong>Component Type and Internal Behavior</strong></p><h3 id="ethernet-switch-port-group-switching"><a class="anchor" href="#ethernet-switch-port-group-switching">#</a> Ethernet switch port group switching</h3><blockquote><p>The current version of the SWS BswM supports Ethernet switch port group switching.</p></blockquote><p>目前版本的 SWS BswM 支持以太网交换机端口组交换。</p><blockquote><p>Based on the current requested PNC, BswM maps the PNC request to a configured EthIfSwitchPortGroup and calls EthIf_SwitchPortGroupRequestMode.</p></blockquote><p>根据当前请求的 PNC，BSWM 将 PNC 请求映射到配置的 EthIfSwitchPortGroup , 并调用 EthIf_SwitchPortGroupRequestMode.</p><blockquote><p>The BswM is indicated by the EthIf, if the accumulated link state has changed.</p></blockquote><p>如果累积链路状态发生变化，则 BswM 由 Ethlf 指示。</p><blockquote><p>The accumulated link state could be used to inform an application. This could be used to cover error scenarios where the requested and the current accumulated link state of EthIfSwitchPortGroups are contradicting and error handling needs to be initiated.</p></blockquote><p>累积链路状态可以用于通知应用程序。这可以用于覆盖错误情况，其中请求的 EthIfSwitchPortGroups 的当前累积链路状态与当前累积链路状态相矛盾，并且需要启动错误处理。</p><blockquote><p>The AUTOSAR_EXP_ModemanagementGuide document contains guidelines for the BswM configuration regarding Ethernet switch port group switching.</p></blockquote><p>AUTOSAR_EXP_ModemanagementGuide 文档包含有关以太网交换机端口组交换的 BswM 配置指南。</p><h3 id="service-discovery-control"><a class="anchor" href="#service-discovery-control">#</a> Service Discovery Control</h3><p><strong>General</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823151826995.png" alt="image-20240823151826995"></p><blockquote><p>Following steps, fulfilled by configuration tools are neccessary:</p><ol><li>Analyze SWC descriptions to find the affected ports</li><li>Analyze the ECUC to deduce the related entities in Service Discovery</li><li>Create Rules and ActionLists to implement the desired behavior provided by BswM</li><li>Create the BswMModeRequestSources for the notifications from Service Discovery Module(s)</li><li>Create the BswM side of the required S/R ports serving as input for the rules</li><li>Create the BswM side of the provided ModeSwitch ports for indications towards SWCs</li><li>Connect the ports between BswM Service SWC and Applications SWCs based on the well-defined naming schema</li></ol></blockquote><p><strong>Client Service/Event Subscription Request</strong></p><blockquote><p>A software-component that implements the client functionality acts as a mode requester and exposes a PPortPrototype typed by a SenderReceiverInterface.</p></blockquote><p>实现客户端功能的软件组件充当模式请求器，并通过 SenderReceiverInterface 公开 PPortPrototype</p><blockquote><p>By this means, the software-component can send mode requests towards the BswM in order to subscribe and stop subscribe of dedicated events and methods.</p></blockquote><p>通过这种方式，软件组件可以向 BSWM 发送模式请求，以便订阅和停止订阅专用事件和方法</p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823152819401.png" alt="image-20240823152819401"></p><blockquote><p>Figure 7.7 shows the chain that builds up an event subscription request in case (SomeIP) Service Discovery is used. The elements in gray color are configured elements.</p></blockquote><p>图 7.7 显示了在使用 (SomelP) Service Discovery 时生成事件订阅请求的链。灰色元素是配置元素。</p><blockquote><p>The corresponding request port (SWC_P1_Req) can be deduced by evaluating the portgroup reference which references the application events (here Ev1).</p></blockquote><p>通过评估引用应用程序事件的端口组引用 (这里 Ev1)，可以推导出相应的请求端口 (SWC_P1_Req)</p><blockquote><p>The relation between application events to the corresponding SD Events (here Ev1 in Eventgroup1) is available by means of the Ecu Configuration.</p></blockquote><p>应用程序事件与对应的 SD 事件 (这里是 Eventgroup1) 中的 EV1) 之间的关系可以通过 Ecu 配置来实现。</p><p><strong>Client Service/Event Subscription state notification</strong></p><blockquote><p>A software-component that acts as a client and is interested in the subscription status for the events and methods exposes an RPortPrototype typed by a ModeSwitchInterface.</p></blockquote><p>作为客户端并对事件和方法的订阅状态感兴趣的软件组件通过 ModeSwitchInterface 公开 RPortPrototype .</p><blockquote><p>By this means the software-component can be notified by the BswM whether a subscription is in place.</p></blockquote><p>通过这种方式，BSwM 可以通知软件组件是否已订阅。</p><p><strong>Server Service Offer Request</strong></p><blockquote><p>A software-component that implements the server functionality acts as a mode requester and exposes a PPortPrototype typed by a SenderReceiverInterface.</p></blockquote><p>实现服务器功能的软件组件充当模式请求器，并公开由 SenderReceiverInterface 键入的 PPortPrototype.</p><blockquote><p>By this means, the software-component can send mode requests towards the BswM in order to offer and stop offer that service instance.</p></blockquote><p>通过这种方法，软件组件可以向 BsWM 发送模式请求，以提供和停止提供该服务实例。</p><blockquote><p>On the side of the BswM, a RPortPrototypetyped by the same SenderReceiver-Interface is used to requests for mode switches.</p></blockquote><p>在 BswM 的另一方面，一个 RPort 原型由相同的发送方接收方接口类型用于请求模式切换。</p><blockquote><p>Unlike the client use cases, the server service offer is only allowed by one port, that means that per instance of a service only one single port is supported.</p></blockquote><p>与客户端用例不同，服务器服务提供只允许一个端口，这意味着每个服务实例只支持一个单独的端口。</p><p><strong>Server Service/Event Subscription State Notification</strong></p><blockquote><p>A server instance sending events or field notifications might not need to produce and send those events if there are no subscriptions for that server instance events.</p></blockquote><p>如果没有对服务器实例事件的订阅，发送事件或字段通知的服务器实例可能不需要生成和发送这些事件。</p><blockquote><p>In order to notify the server instance whether there is at least one subscriber interested in the server’s events a ModeSwitchInterface is available to receive the subscription notifications.</p></blockquote><p>为了通知服务器实例是否至少有一个订阅者对服务器的事件感兴趣，ModeSwitchInterface 可用来接收订通知。</p><blockquote><p>A software-component that acts as a server and is interested in the subscription status for the service instance events exposes an RPortPrototype typed by a ModeSwitch Interface.</p></blockquote><p>作为服务器并感兴趣于服务实例事件的订阅状态的软件组件公开了由 ModeSwitch 接口类型化的 RPortPrototype .</p><blockquote><p>By this means, the software-component can be notified by the BswM on subscription changes.</p></blockquote><p>通过这种方式，BSWM 可以就订阅变更通知软件组件。</p><p><strong>Connecting ports at configuration time</strong></p><h2 id="9-sequence-diagrams"><a class="anchor" href="#9-sequence-diagrams">#</a> 9 Sequence diagrams</h2><p><strong>Deferred operation of BswM</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823161524797.png" alt="image-20240823161524797"></p><p><strong>Immediate operation of BswM</strong></p><p><img data-src="../../../img.assets/24-08-31%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%883%EF%BC%89ModeManagement/image-20240823161555207.png" alt="image-20240823161555207"></p><p>结束啦宝！睡觉🛏️</p><div class="tags"><a href="/tags/AUTOSAR/" rel="tag"><i class="ic i-tag"></i> AUTOSAR</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-09-22 10:34:00" itemprop="dateModified" datetime="2024-09-22T10:34:00+08:00">2024-09-22</time> </span><span id="archives/c9ca48bd.html" class="item leancloud_visitors" data-flag-title="小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="flechazo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="flechazo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="flechazo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>flechazo <i class="ic i-at"><em>@</em></i>我在人间贩卖黄昏，只为收集世间温柔遇见你.</li><li class="link"><strong>本文链接：</strong> <a href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c9ca48bd.html" title="小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement">https://flechazoclf.github.io/FlechazoCLF.github.io/archives/c9ca48bd.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/archives/38a44ca9.html" itemprop="url" rel="prev" data-background-image="/archives/38a44ca9.html../../../wallpaper/6.png" title="医院检查身体单子记录"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 自我提升</span><h3>医院检查身体单子记录</h3></a></div><div class="item right"><a href="/archives/47a7fa40.html" itemprop="url" rel="next" data-background-image="/archives/47a7fa40.html../../../wallpaper/7.png" title="小柴冲刺软考中级嵌入式系统设计师系列一、计算机系统基础知识（6）可靠性与系统性能评测基础"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 嵌入式</span><h3>小柴冲刺软考中级嵌入式系统设计师系列一、计算机系统基础知识（6）可靠性与系统性能评测基础</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6autosar%E7%B3%BB%E5%88%97%E4%B8%89-%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%873modemanagement"><span class="toc-number">1.</span> <span class="toc-text">小柴带你学 AutoSar 系列三、标准和规范篇（3）ModeManagement</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modemanagementguide"><span class="toc-number">2.</span> <span class="toc-text">ModeManagementGuide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-overall-mechanisms-and-concepts"><span class="toc-number">2.1.</span> <span class="toc-text">2 Overall mechanisms and concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-declaration-of-modes"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1 Declaration of modes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-mode-managers-and-mode-users"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.2 Mode managers and mode users</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-modes-in-the-rte"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.3 Modes in the RTE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-modes-in-the-basic-software-scheduler"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.4 Modes in the Basic Software Scheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-communication-of-modes"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.5 Communication of modes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-configuration-of-the-basic-software-modemanager"><span class="toc-number">2.2.</span> <span class="toc-text">3 Configuration of the Basic Software Modemanager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-semantics-of-bswm-configuration-interfaces-and-behavioral-aspects"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.2 Semantics of BswM Configuration: Interfaces and behavioral aspects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-ecu-state-management"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.3 ECU state management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-communication-management"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.4 Communication Management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-diagnostics"><span class="toc-number">2.2.4.</span> <span class="toc-text">3.5 Diagnostics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-bswm-to-bswm-interaction-on-multicore-ecus"><span class="toc-number">2.2.5.</span> <span class="toc-text">3.6 BswM to BswM interaction on multicore ECUs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-inter-partition-actions"><span class="toc-number">2.2.6.</span> <span class="toc-text">3.7 Inter-partition Actions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-inter-partition-requestsindications"><span class="toc-number">2.2.7.</span> <span class="toc-text">3.8 Inter-partition Requests/Indications</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modemanagement"><span class="toc-number">3.</span> <span class="toc-text">ModeManagement</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-scope-of-document"><span class="toc-number">3.1.</span> <span class="toc-text">1 Scope of Document</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-requirements-specification"><span class="toc-number">3.2.</span> <span class="toc-text">4 Requirements Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-ecu-state-manager-ecum"><span class="toc-number">3.2.1.</span> <span class="toc-text">4.1 ECU State Manager (EcuM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-watchdog-manager"><span class="toc-number">3.2.2.</span> <span class="toc-text">4.2 Watchdog Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-communication-manager"><span class="toc-number">3.2.3.</span> <span class="toc-text">4.3 Communication Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-basic-software-mode-manager"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.4 Basic Software Mode Manager</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ecustatemanager"><span class="toc-number">4.</span> <span class="toc-text">ECUStateManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-introduction-and-functional-overview"><span class="toc-number">4.1.</span> <span class="toc-text">1 Introduction and Functional Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-functional-specification"><span class="toc-number">4.2.</span> <span class="toc-text">7 Functional Specification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-phases-of-the-ecu-manager-module"><span class="toc-number">4.2.1.</span> <span class="toc-text">7.1 Phases of the ECU Manager Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-structural-description-of-the-ecu-manager"><span class="toc-number">4.2.2.</span> <span class="toc-text">7.2 Structural Description of the ECU Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-startup-phase"><span class="toc-number">4.2.3.</span> <span class="toc-text">7.3 STARTUP Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-shutdown-phase"><span class="toc-number">4.2.4.</span> <span class="toc-text">7.4 SHUTDOWN Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-sleep-phase"><span class="toc-number">4.2.5.</span> <span class="toc-text">7.5 SLEEP Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-up-phase"><span class="toc-number">4.2.6.</span> <span class="toc-text">7.6 UP Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-shutdown-targets"><span class="toc-number">4.2.7.</span> <span class="toc-text">7.7 Shutdown Targets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-alarm-clock"><span class="toc-number">4.2.8.</span> <span class="toc-text">7.8 Alarm Clock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-multicore"><span class="toc-number">4.2.9.</span> <span class="toc-text">7.9 MultiCore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#710-ecum-mode-handling"><span class="toc-number">4.2.10.</span> <span class="toc-text">7.10 EcuM Mode Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#711-advanced-topics"><span class="toc-number">4.2.11.</span> <span class="toc-text">7.11 Advanced Topics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-errorhook"><span class="toc-number">4.2.12.</span> <span class="toc-text">7.12 ErrorHook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-error-classification"><span class="toc-number">4.2.13.</span> <span class="toc-text">7.13 Error classification</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-sequence-charts"><span class="toc-number">4.3.</span> <span class="toc-text">9 Sequence Charts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#91-state-sequences"><span class="toc-number">4.3.1.</span> <span class="toc-text">9.1 State Sequences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-wakeup-sequences"><span class="toc-number">4.3.2.</span> <span class="toc-text">9.2 Wakeup Sequences</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bswmodemanager"><span class="toc-number">5.</span> <span class="toc-text">BSWModeManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-introduction-and-functional-overview-2"><span class="toc-number">5.1.</span> <span class="toc-text">1 Introduction and functional overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-dependencies-to-other-modules"><span class="toc-number">5.2.</span> <span class="toc-text">5 Dependencies to other modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-functional-specification-2"><span class="toc-number">5.3.</span> <span class="toc-text">7 Functional specification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mode-arbitration"><span class="toc-number">5.3.1.</span> <span class="toc-text">Mode Arbitration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mode-control"><span class="toc-number">5.3.2.</span> <span class="toc-text">Mode Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting-functionality"><span class="toc-number">5.3.3.</span> <span class="toc-text">Waiting Functionality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multi-partition-support"><span class="toc-number">5.3.4.</span> <span class="toc-text">Multi Partition Support</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-classification"><span class="toc-number">5.3.5.</span> <span class="toc-text">Error classification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bswm-interfaces-and-ports"><span class="toc-number">5.3.6.</span> <span class="toc-text">BswM Interfaces and Ports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ethernet-switch-port-group-switching"><span class="toc-number">5.3.7.</span> <span class="toc-text">Ethernet switch port group switching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service-discovery-control"><span class="toc-number">5.3.8.</span> <span class="toc-text">Service Discovery Control</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-sequence-diagrams"><span class="toc-number">5.4.</span> <span class="toc-text">9 Sequence diagrams</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/archives/dfcb5141.html" rel="bookmark" title="LD文件在AUTOSAR工程中的作用和语法解析">LD文件在AUTOSAR工程中的作用和语法解析</a></li><li><a href="/archives/cbed58a6.html" rel="bookmark" title="小柴带你学AutoSar总目录">小柴带你学AutoSar总目录</a></li><li><a href="/archives/b20010d9.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（1）概念和目标">小柴带你学AutoSar系列一、基础知识篇（1）概念和目标</a></li><li><a href="/archives/e0c2534f.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement">小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement</a></li><li><a href="/archives/e8a5cc27.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构">小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构</a></li><li><a href="/archives/e8bc299.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（5）makefile基础">小柴带你学AutoSar系列一、基础知识篇（5）makefile基础</a></li><li><a href="/archives/5e71c9a6.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（3）C语言基础">小柴带你学AutoSar系列一、基础知识篇（3）C语言基础</a></li><li><a href="/archives/7cac95ec.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（4）编译">小柴带你学AutoSar系列一、基础知识篇（4）编译</a></li><li><a href="/archives/3c7f112.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850">小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850</a></li><li><a href="/archives/3f4a19e2.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（7）术语">小柴带你学AutoSar系列一、基础知识篇（7）术语</a></li><li><a href="/archives/962e9003.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（1）General">小柴带你学习AutoSar系列三、标准和规范篇（1）General</a></li><li><a href="/archives/db4ff6ff.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral">小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral</a></li><li class="active"><a href="/archives/c9ca48bd.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement">小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement</a></li><li><a href="/archives/fd244a42.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（4）RTE">小柴带你学AutoSar系列三、标准和规范篇（4）RTE</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="flechazo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">flechazo</p><div class="description" itemprop="description">我在人间贩卖星光</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">192</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">44</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">41</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fnb25pMzdD" title="https://github.com/Agoni37C"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" title="https://www.zhihu.com/people/jiu_sheng"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvcGxheWxpc3Q/aWQ9NzE3NTI4NzIwNQ==" title="https://music.163.com/#/playlist?id=7175287205"><i class="ic i-cloud-music"></i></span> <span class="exturl item weixin" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vbXAvaG9tZXBhZ2U/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZoaWQ9MiZzbj05ZThkZGVkOGU3MTgxYTA4YTA1MjFiOTQ2MjIyY2Q3MiZzY2VuZT0xOCN3ZWNoYXRfcmVkaXJlY3Q=" title="http://mp.weixin.qq.com/mp/homepage?__biz=MzAxODM2NTQ0Nw==&amp;hid=2&amp;sn=9e8dded8e7181a08a0521b946222cd72&amp;scene=18#wechat_redirect"><i class="ic i-address-card"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxODc1ODQ0P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https://space.bilibili.com/441875844?spm_id_from=333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAwLw=="><i class="ic i-home"></i>首页</span></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>小伙伴们</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAxLw=="><i class="ic i-magic"></i>导航页🚀</span></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>小天地🍼</a><ul class="submenu"><li class="item"><a href="/broken-thoughts/" rel="section"><i class="ic i-heart"></i>碎碎念</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAyLw=="><i class="ic i-heart"></i>云小🎪盘</span></li><li class="item"><a href="/mypages/Videoparse/" rel="section"><i class="ic i-heart"></i>视频解析</a></li><li class="item"><a href="/movies/" rel="section"><i class="ic i-heart"></i>影集</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA5Lw=="><i class="ic i-heart"></i>游戏🎮小站</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA2Lw=="><i class="ic i-heart"></i>动感天地🎶</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAzLw=="><i class="ic i-heart"></i>4k壁纸❄</span></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>有趣单页</a><ul class="submenu"><li class="item"><a href="/mypageslayout/barrage/" rel="section"><i class="ic i-list-alt"></i>弹幕墙</a></li><li class="item"><a href="/mypages/crossing-the-cliff/" rel="section"><i class="ic i-th"></i>圣诞老人过桥</a></li><li class="item"><a href="/mypages/eat/" rel="section"><i class="ic i-tags"></i>今天吃什么</a></li><li class="item"><a href="/mypages/clock/" rel="section"><i class="ic i-list-alt"></i>好看的闹钟</a></li><li class="item"><a href="/mypages/QQpage/" rel="section"><i class="ic i-list-alt"></i>QQ展示页</a></li><li class="item"><a href="/mypages/jianli/" rel="section"><i class="ic i-th"></i>简历</a></li><li class="item"><a href="/mypages/love/" rel="section"><i class="ic i-tags"></i>执子之手</a></li><li class="item"><a href="/mypages/tiangou/" rel="section"><i class="ic i-list-alt"></i>舔狗语录</a></li><li class="item"><a href="/mypages/washing/" rel="section"><i class="ic i-th"></i>洗衣机</a></li><li class="item"><a href="/mypages/todolist/" rel="section"><i class="ic i-tags"></i>行动清单</a></li><li class="item"><a href="/mypages/yindao2/" rel="section"><i class="ic i-list-alt"></i>引导页</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/archives/38a44ca9.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/archives/47a7fa40.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/QT/" title="分类于 QT">QT</a></div><span><a href="/archives/d989430a.html" title="一种flash的存储方式,基于GD25Q64">一种flash的存储方式,基于GD25Q64</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/AUTOSAR/" title="分类于 AUTOSAR">AUTOSAR</a></div><span><a href="/archives/962e9003.html" title="小柴带你学习AutoSar系列三、标准和规范篇（1）General">小柴带你学习AutoSar系列三、标准和规范篇（1）General</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/english/" title="分类于 english">english</a> <i class="ic i-angle-right"></i> <a href="/categories/english/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E8%8B%B1%E8%AF%AD/" title="分类于 从零开始学英语">从零开始学英语</a></div><span><a href="/archives/311979d6.html" title="🍖58个日常家电单词">🍖58个日常家电单词</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/c3251f5b.html" title="小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理">小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/QT/" title="分类于 QT">QT</a></div><span><a href="/archives/dec6794a.html" title="QT给输入框添加自动补全提示词">QT给输入框添加自动补全提示词</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blog/" title="分类于 blog🌮">blog🌮</a> <i class="ic i-angle-right"></i> <a href="/categories/blog/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/archives/2b388030.html" title="markdown语法汇总">markdown语法汇总</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/C%E8%AF%AD%E8%A8%80/" title="分类于 C语言">C语言</a></div><span><a href="/archives/48b3f971.html" title="C语言define的骚操作">C语言define的骚操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/AUTOSAR/" title="分类于 AUTOSAR">AUTOSAR</a></div><span><a href="/archives/3f4a19e2.html" title="小柴带你学AutoSar系列一、基础知识篇（7）术语">小柴带你学AutoSar系列一、基础知识篇（7）术语</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/C%E8%AF%AD%E8%A8%80/" title="分类于 C语言">C语言</a></div><span><a href="/archives/8ef5993a.html" title="c语言异或的妙用">c语言异或的妙用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/3b468ee7.html" title="小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（2）电子电路设计">小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（2）电子电路设计</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">© 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">flechazo @ flechazo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">906k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">13:44</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> &amp; Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL={path:"archives/c9ca48bd.html",favicon:{show:"flechazo",hide:"(´Д｀)客官别走！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html><!-- rebuild by hrmmi -->