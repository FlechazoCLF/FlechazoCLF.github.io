<!-- build time:Mon Feb 10 2025 22:46:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><script src="http://echarts.baidu.com/dist/echarts.common.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/map/js/china.min.js"></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="yandex-verification" content="fadb7324b0f3dbe2"><link rel="alternate" type="application/rss+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/atom.xml"><link rel="alternate" type="application/json" title="我在人间贩卖黄昏，只为收集世间温柔遇见你." href="https://flechazoclf.github.io/FlechazoCLF.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="AUTOSAR,嵌入式,软件开发"><link rel="canonical" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/db4ff6ff.html"><title>小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral - AUTOSAR - 技术教程🎃 | flechazo = 我在人间贩卖黄昏，只为收集世间温柔遇见你. = 有幸来到人间的旅人</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral</h1><div class="meta"><span class="item" title="创建时间：2024-07-28 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-07-28T00:00:00+08:00">2024-07-28</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">flechazo</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/archives/db4ff6ff.html../../../wallpaper/9.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/" itemprop="item" rel="index" title="分类于 技术教程🎃"><span itemprop="name">技术教程🎃</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope="" itemtype="https://schema.org/ListItem"><a href="/categories/technique/AUTOSAR/" itemprop="item" rel="index" title="分类于 AUTOSAR"><span itemprop="name">AUTOSAR</span></a><meta itemprop="position" content="2"></span></div><article itemscope="" itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/db4ff6ff.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="flechazo"><meta itemprop="description" content="有幸来到人间的旅人, 我在人间贩卖星光"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="我在人间贩卖黄昏，只为收集世间温柔遇见你."></span><div class="body md" itemprop="articleBody"><p></p><div class="links"><div class="item" title="【知乎】flechazo" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=">【知乎】flechazo</span><p class="desc">https://www.zhihu.com/people/jiu_sheng</p></div></div></div><p></p><p></p><div class="links"><div class="item" title="【CSDN】小柴带你学AutoSar总目录" style="--block-color:#21d4fd"><span class="exturl image" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=" data-background-image="https://foruda.gitee.com/avatar/1680342439464493317/9010997_flechazo5201314_1680342439.png!avatar200"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW5zaGFuZzUyMDEzL2FydGljbGUvZGV0YWlscy8xMzgxNDAyMzU/c3BtPTEwMDEuMjAxNC4zMDAxLjU1MDE=">【CSDN】小柴带你学AutoSar总目录</span><p class="desc">https://blog.csdn.net/qianshang52013/article/details/138140235?spm=1001.2014.3001.5501</p></div></div></div><p></p><p>Autosar 系列教程：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZhbXA7bWlkPTIyNDc0OTIzMjYmYW1wO2lkeD0xJmFtcDtzbj1kNDdhYWM4YTE4MWJkZjM0NGNmMzJhOThmNzAxMjkyNyZhbXA7Y2hrc209OWJkNWNmOGVhY2EyNDY5ODgyMzcxZTEyOTY5Yzc3NzdiMDY1NGRiMGE3MDVlNWE1ZDNkZGFmNjRjODk5ZjhmYzUyYmRhNTM4MzczMiZhbXA7cGF5cmVhZHRpY2tldD1IQjBaZE1Tc3RNVmVRVXF2RkdBb2E1U2Q3Mnk2bzJOb192OF9PLUhsaXRxMHBaOWcxVzFablBrbmwwQmJySGZZajcxeUtkZyNyZA==">小柴带你学 AutoSar 总目录</span></p><h1 id="小柴带你学autosar系列三-标准和规范篇2bswgeneral"><a class="anchor" href="#小柴带你学autosar系列三-标准和规范篇2bswgeneral">#</a> 小柴带你学 AutoSar 系列三、标准和规范篇（2）BSWGeneral</h1><p>我来啦</p><p>虽迟但到哈哈哈😜</p><p>一个人的精力果然是有限的</p><p>最近可能有些许懒散😋</p><p>不过可以晚但不能忘哦</p><p>只要坚持下去就可以打败 99.99% 的人了✌️</p><p>一起加油吧🧐！</p><h1 id="bswdistributionguide"><a class="anchor" href="#bswdistributionguide">#</a> BSWDistributionGuide</h1><h2 id="bsw在autosar架构中的这里哦"><a class="anchor" href="#bsw在autosar架构中的这里哦">#</a> BSW 在 AUTOSAR 架构中的这里哦</h2><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240504123208031.png" alt="image-20240504123208031"></p><h2 id="bsw-distribution-in-multi-core-systems"><a class="anchor" href="#bsw-distribution-in-multi-core-systems">#</a> BSW Distribution in Multi-Core Systems</h2><p><strong>BSW Functional Clusters</strong></p><p>BSW 功能集群是一组相关功能的模块</p><blockquote><p>BSW functional clusters are groups of functionally coherent BSW modules.</p></blockquote><p>The following types of clusters might be standardized in a later release:</p><ul><li>Communication cluster 通信集群</li><li>Memory cluster 内存集群</li><li>I/O cluster I/O 集群</li><li>Watchdog cluster 看门狗集群</li></ul><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626161806728.png" alt="image-20240626161806728"></p><h2 id="parallel-execution-of-bsw-modules"><a class="anchor" href="#parallel-execution-of-bsw-modules">#</a> Parallel Execution of BSW modules</h2><h3 id="core-dependent-branching"><a class="anchor" href="#core-dependent-branching">#</a> Core-Dependent Branching</h3><blockquote><p>It is possible for example to use the core id for this, i.e. branch the control flow depending on the return value of the OS APIs GetCoreID, or also GetApplicationID.</p></blockquote><p>BSW 模块的并行处理，可以通过获取 Core ID 来进行分支处理</p><h3 id="using-shared-buffers-in-systems-without-memory-protection"><a class="anchor" href="#using-shared-buffers-in-systems-without-memory-protection">#</a> Using Shared Buffers (in systems without memory protection)</h3><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626162549425.png" alt="image-20240626162549425"></p><p>使用共享的 buffer，所以需要防止并发访问哦，保持数据一致性</p><h3 id="concurrency-safe-implementation-of-modules"><a class="anchor" href="#concurrency-safe-implementation-of-modules">#</a> Concurrency safe implementation of modules</h3><p>并发，可重入 / 不可重入都是需要考虑的事情</p><h3 id="kernel-based-master-satellite-realization"><a class="anchor" href="#kernel-based-master-satellite-realization">#</a> Kernel based Master-Satellite Realization</h3><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626163902377.png" alt="image-20240626163902377"></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626163953945.png" alt="image-20240626163953945"></p><h3 id="atomic-operations-library"><a class="anchor" href="#atomic-operations-library">#</a> Atomic Operations Library</h3><p>支持原子操作哦</p><h2 id="schm-interfaces-for-parallel-bsw-execution"><a class="anchor" href="#schm-interfaces-for-parallel-bsw-execution">#</a> SchM Interfaces for Parallel BSW execution</h2><p>用于并行执行的 SchM 接口</p><blockquote><p>The Basic Software Scheduler (SchM) is responsible for handling the inter-partition communication between BSW modules.</p></blockquote><p>SchM 负责 BSW 分区间的通信</p><blockquote><p>For the distribution of BSW modules across several partitions, the SchM shall implement the methods SchM_Call, SchM_Result, SchM_Send and SchM_Receive</p></blockquote><p>SchM 要实现多种方法</p><ul><li>SchM_Call</li><li>SchM_Result</li><li>SchM_Send</li><li>SchM_Receive</li></ul><blockquote><p>The SchM can use IocSend (a direct call to the OS) to send data in inter-partition communication. Other RTE internal mechanism might not be available during startup.</p></blockquote><p>SchM 可以使用 IOC 去做分区间通信</p><h2 id="configuration-of-basic-software-in-partitioned-systems"><a class="anchor" href="#configuration-of-basic-software-in-partitioned-systems">#</a> Configuration of Basic Software in Partitioned Systems</h2><h3 id="task-mapping"><a class="anchor" href="#task-mapping">#</a> Task Mapping</h3><blockquote><p>The parallelization of BSW modules introduces several new subclasses of BswEvent to the AUTOSAR metamodel. These classes are shown in Figure 2.5. Each BswEvent (including instances of subclasses of BswEvent) is assigned to a BswSchedulableEntity, which is started upon occurrence of the event.</p></blockquote><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240704102125498.png" alt="image-20240704102125498"></p><p>总而言之呢就是通过事件触发函数</p><h3 id="general-configuration-of-master-and-satellites"><a class="anchor" href="#general-configuration-of-master-and-satellites">#</a> General Configuration of Master and Satellites</h3><blockquote><p>Modules that shall be available in multiple partitions can be implemented as masters and satellites. In this case, the master and all satellites of the same module share the same code (which may implement core-dependent behavior however) and the same configuration. Hence, a master and its satellites are treated as one module entity w.r.t. their configuration.</p></blockquote><p>主模块和卫星模块共享相同的代码和配置</p><blockquote><p>The communication between master and satellites is not to be standardized. It is considered to be module-internal and it is not visible to other modules. However, since it is recommended to use SchM mechanisms for internal communication, the nonstandardized client-server entries and data accesses in the BSWMD to connect master and satellite need to be configured.</p></blockquote><h3 id="configuring-the-bswm-per-partition"><a class="anchor" href="#configuring-the-bswm-per-partition">#</a> Configuring the BswM (per Partition)</h3><blockquote><p>On systems with distributed BSW there is one BSW Mode Manager (BswM) per partition (but one OS and EcuM per core, which is the same as long as we have one BSW partition per core). Each of these BswMs can be configured independently. A BswM mainly interacts with the state managers (ECU state manager and bus state managers, for instance) on the same partition.</p></blockquote><p>每个部分的 BswM 可以被单独配置</p><blockquote><p>The BswM is also responsible for the initialization and shutdown of BSW modules running in the same partition. Therefore, its configuration depends on the mapping of BSW modules to partitions.</p></blockquote><p>BswM 可以响应同分区的 initialization 和 shutdown</p><h3 id="configuring-the-ecum-per-core"><a class="anchor" href="#configuring-the-ecum-per-core">#</a> Configuring the EcuM (per Core)</h3><blockquote><p>On systems with distributed BSW there is one EcuM per core (even if there are multiple BSW partitions on that core). In other words, on every core there shall be one and only one partition that runs the EcuM. The partition running the EcuM is determined by the EcuMFlexEcucPartitionRef, which is specified in the container EcuMFlexUser Config of the EcuM configuration.</p></blockquote><p>每个核都应该只要有一个 EcuM，即使这个核上有多个 BswM 的不同分区。</p><blockquote><p>On architectures with a sequential start of cores, there is one designated master core in which the boot loader starts the master EcuM via EcuM_Init. The EcuM in the master core starts some drivers, determines the Post Build configuration and starts all remaining cores with all their satellite EcuMs</p></blockquote><p>引导程序 -&gt; EcuM_Init -&gt; master core -&gt; remaining cores</p><h2 id="mcal-distribution"><a class="anchor" href="#mcal-distribution">#</a> MCAL Distribution</h2><h3 id="introduction"><a class="anchor" href="#introduction">#</a> Introduction</h3><blockquote><p>It shall be noted that the introduction of the multi-core MCAL requires the introduction of asynchronously behaving interfaces to enable non-blocking parallel execution on multiple cores.</p></blockquote><p>要实现异步非阻塞，不能阻塞哦</p><blockquote><p>Furthermore it is assumed that a multi-core microcontroller is used however this is not mandatory as the concept provides an identical set of service API’s regardless whether it is a single- or multi-core implementation. Additionally it is possible to realize mixed ASIL systems with segregation in space and time where the mappable MCAL elements are assigned to the different partitions respecting the safety integrity level of the resulting MCAL implementation.</p></blockquote><p>多核并发 + 硬件分离解耦</p><h3 id="criteria"><a class="anchor" href="#criteria">#</a> Criteria</h3><ul><li>1 - APIs Availability<ul><li>1a: Local service API’s (executable on one core only)</li><li>1b: Global (distributed /shared) service API’s (executable on any core)</li></ul></li><li>2 - MCAL Kernel Execution Context<ul><li>2a: One Local kernel (executable on one core only)</li><li>2b: Global (distributed /shared) kernel (executable on any core)</li></ul></li><li>HW Elements Mapping<ul><li>3a: One HW element mappable to one core only</li><li>3b: One HW element mappable to several cores</li></ul></li></ul><h2 id="com-stack-distribution"><a class="anchor" href="#com-stack-distribution">#</a> Com-Stack Distribution</h2><blockquote><p>In general, one major job of the PduR is to take care of PDU routings between different networks.</p></blockquote><p>PduR 来处理不同的网络间的路由</p><h2 id="bsw-distribution-in-safety-systems"><a class="anchor" href="#bsw-distribution-in-safety-systems">#</a> BSW Distribution in Safety Systems</h2><blockquote><p>the main safety mechanisms:</p><ul><li>Partitioning of SWCs to support the isolation in space.</li><li>Timing and control flow supervision to monitor executing entities and to detectfaults caused by blocking or wrong execution. In AUTOSAR the Os and the WdgM take care of this issue.</li><li>A safe communication via end-to-end protection is possible between ECUs (and even inside an ECU). This guarantees e.g. that the data which is send is not modified between the sender and the receiver(s). The responsible module is the E2Elibrary.</li></ul></blockquote><p>简单来说呢三件事：空间隔离、定时保护、E2E 端到端</p><h1 id="bswgeneral"><a class="anchor" href="#bswgeneral">#</a> BSWGeneral</h1><h2 id="requirements-specification"><a class="anchor" href="#requirements-specification">#</a> Requirements Specification</h2><blockquote><p>This chapter describes all requirements driving the work to define the General Requirements on Basic Software Modules.</p></blockquote><h2 id="functional-overview"><a class="anchor" href="#functional-overview">#</a> Functional Overview</h2><p>BSW 涵盖了以下几个区域</p><blockquote><p>The requirements on Basic Software cover the following domains:</p><ul><li>Body</li><li>Powertrain</li><li>Chassis</li><li>Safety (assumption: covered, because hardware and system infrastructure are similar to the domains above)</li></ul></blockquote><p>有下面几种 ECU</p><blockquote><p>The ECU application experience is taken from the following concrete applications:</p><ul><li>Sunroof and power window ECU</li><li>Diesel engine ECU</li><li>ESP ECU</li><li>BMW, DC and VW standard software packages (’Standard Core’, ’Standard Software Platform’, ’Standard Software Core’) including ISO 17356-3 OS [3], communication modules, bootloader, basic diagnostic functions for the domains listed above</li><li>Infotainment control ECU</li></ul></blockquote><h2 id="functional-requirements"><a class="anchor" href="#functional-requirements">#</a> Functional Requirements</h2><h3 id="configuration"><a class="anchor" href="#configuration">#</a> Configuration</h3><blockquote><p><strong>[SRS_BSW_00344] BSW Modules shall support link-time configuration</strong></p><p><strong>[SRS_BSW_00404] BSW Modules shall support post-build configuration</strong></p><p><strong>[SRS_BSW_00405] BSW Modules shall support multiple configuration sets</strong></p><p><strong>[SRS_BSW_00345] BSW Modules shall support pre-compile configuration</strong></p><p><strong>[SRS_BSW_00159] All modules of the AUTOSAR Basic Software shall support a tool based configuration</strong></p></blockquote><p>支持各种配置</p><blockquote><p><strong>[SRS_BSW_00167] All AUTOSAR Basic Software Modules shall provide configuration rules and constraints to enable plausibility checks</strong></p><p><strong>[SRS_BSW_00171] Optional functionality of a Basic-SW component that is not required in the ECU shall be configurable at pre-compile-time</strong></p></blockquote><p>支持一些检查</p><blockquote><p><strong>[SRS_BSW_00170] The AUTOSAR SW Components shall provide information about their dependency from faults, signal qualities, driver demands</strong></p></blockquote><p>SWC 应该提供有关故障、信号质量、驱动的依赖</p><blockquote><p><strong>[SRS_BSW_00380] Configuration parameters being stored in memory shall be placed into separate c-files</strong></p></blockquote><p>配置的参数应该在一个单独的 c 文件中</p><blockquote><p><strong>[SRS_BSW_00419] If a pre-compile time configuration parameter is implemented as const it should be placed into a separate c-file</strong></p></blockquote><p>如果是 const 类型，也需要单独放在一个 c 文件中</p><blockquote><p><strong>[SRS_BSW_00383] The Basic Software Module specifications shall specify which other configuration files from other modules they use at least in the description</strong></p></blockquote><p>应该至少描述出需要用到的其他模块的哪些配置文件</p><blockquote><p><strong>[SRS_BSW_00384] The Basic Software Module specifications shall specify at least in the description which other modules they require</strong></p></blockquote><p>应该说明要使用哪些模块</p><blockquote><p><strong>[SRS_BSW_00388] Containers shall be used to group configuration parameters that are defined for the same object</strong></p></blockquote><p>对配置进行分组</p><blockquote><p><strong>[SRS_BSW_00389] Containers shall have names</strong></p><p><strong>[SRS_BSW_00390] Parameter content shall be unique within the module</strong></p><p><strong>[SRS_BSW_00392] Parameters shall have a type</strong></p><p><strong>[SRS_BSW_00393] Parameters shall have a range</strong></p><p><strong>[SRS_BSW_00394] The Basic Software Module specifications shall specify the scope of the configuration parameters</strong></p><p><strong>[SRS_BSW_00395] The Basic Software Module specifications shall list all configuration parameter dependencies</strong></p><p><strong>[SRS_BSW_00396] The Basic Software Module specifications shall specify the supported configuration classes for changing values and multiplicities for each parameter/container</strong></p><p><strong>[SRS_BSW_00403] The Basic Software Module specifications shall specify foreach parameter/container whether it supports different values or multiplicity indifferent configuration sets</strong></p><p><strong>[SRS_BSW_00397] The configuration parameters in pre-compile time are fixed before compilation starts</strong></p><p><strong>[SRS_BSW_00398] The link-time configuration is achieved on object code basis in the stage after compiling and before linking</strong></p></blockquote><p>一些乱七八糟的，懒得解释哈哈哈</p><blockquote><p><strong>[SRS_BSW_00399] Parameter-sets shall be located in a separate segment and shall be loaded after the code</strong></p></blockquote><p>给代码划个段</p><blockquote><p><strong>[SRS_BSW_00400] Parameter shall be selected from multiple sets of parameters after code has been loaded and started</strong></p><p><strong>[SRS_BSW_00438] Configuration data shall be defined in a structure</strong></p><p><strong>[SRS_BSW_00402] Each module shall provide version information</strong></p></blockquote><h3 id="wake-up"><a class="anchor" href="#wake-up">#</a> Wake-Up</h3><blockquote><p><strong>[SRS_BSW_00375] Basic Software Modules shall report wake-up reasons</strong></p></blockquote><p>应该提供一个唤醒原因</p><h3 id="initialization"><a class="anchor" href="#initialization">#</a> Initialization</h3><blockquote><p><strong>[SRS_BSW_00101] The Basic Software Module shall be able to initialize variables and hardware in a separate initialization function</strong></p></blockquote><p>在初始化函数中初始化变量和硬件</p><blockquote><p><strong>[SRS_BSW_00416] The sequence of modules to be initialized shall be configurable</strong></p></blockquote><p>初始化顺序支持配置</p><blockquote><p><strong>[SRS_BSW_00406] A static status variable denoting if a BSW module is initialized shall be initialized with value 0 before any APIs of the BSW module is called</strong></p></blockquote><p>静态状态变量应该被初始化为 0 在调用任何 API 之前</p><blockquote><p><strong>[SRS_BSW_00467] The init / deinit services shall only be called by BswM or EcuM</strong></p></blockquote><p>初始化函数只能由 BswM 或 EcuM 调用</p><blockquote><p><strong>[SRS_BSW_00437] Memory mapping shall provide the possibility to define RAM segments which are not to be initialized during startup</strong></p></blockquote><p>支持定义地址映射中的 RAM 段是否要初始化</p><h3 id="normal-operation"><a class="anchor" href="#normal-operation">#</a> Normal Operation</h3><blockquote><p><strong>[SRS_BSW_00168] SW components shall be tested by a function defined in a common API in the Basis-SW</strong></p></blockquote><p>有一些测试的函数</p><blockquote><p><strong>[SRS_BSW_00407] Each BSW module shall provide a function to read out the version information of a dedicated module implementation</strong></p></blockquote><p>支持读模块信息，版本信息</p><blockquote><p><strong>[SRS_BSW_00423] BSW modules with AUTOSAR interfaces shall be describable with the means of the SW-C Template</strong></p></blockquote><p>不知道啥意思，应该是有一些对 SWC 的适配和依赖</p><blockquote><p><strong>[SRS_BSW_00424] BSW module main processing functions shall not be allowed to enter a wait state</strong></p></blockquote><p>Bsw 模块的主处理函数不允许进入等待状态</p><blockquote><p><strong>[SRS_BSW_00425] The BSW module description template shall provide means to model the defined trigger conditions of schedulable objects</strong></p></blockquote><p>定义可调度对象的触发条件</p><blockquote><p><strong>[SRS_BSW_00426] BSW Modules shall ensure data consistency of data which is shared between BSW modules</strong></p><p>There are two possible scenarios</p><ul><li>Scenario 1: the data is defined and managed within one BSW Module. In this case, Exclusive Areas shall be defined and documented in the BSW module description template of the managing module and used in the implementation. The exclusive areas shall be defined with a name and the accessing maifunctions, API services, callback functions and ISR functions.</li><li>Scenario 2: the data is not managed by a BSW Module. This is only possible in case of special hardware resources like registers. In this case, the accessing modules need to disable and enable interrupts to ensure data consistency</li></ul></blockquote><p>要保证数据一致性</p><blockquote><p><strong>[SRS_BSW_00427] ISR functions shall be defined and documented in the BSW module description template</strong></p><p><strong>[SRS_BSW_00428] A BSW module shall state if its main processing function(s) has to be executed in a specific order or sequence</strong></p><p><strong>[SRS_BSW_00429] Access to OS is restricted</strong></p><p>BSW modules shall only be allowed to use certain OS services.</p><p>The services and their access shall be defined in SWS_BSW_General.</p></blockquote><p>BSW 应该只能访问特定的 OS 服务</p><blockquote><p><strong>[SRS_BSW_00432] Modules should have separate main processing functions for read/receive and write/transmit data path</strong></p></blockquote><p>BSW 模块要有自己的专门的读写发送接收函数</p><blockquote><p><strong>[SRS_BSW_00433] Main processing functions are only allowed to be called from task bodies provided by the BSW Scheduler</strong></p></blockquote><p>主处理函数只允许在 BSW 调度器调用</p><blockquote><p><strong>[SRS_BSW_00450] A Main function of a un-initialized module shall return immediately</strong></p></blockquote><p>未初始化的模块要立即返回</p><blockquote><p><strong>[SRS_BSW_00461] Modules called by generic modules shall satisfy all interfaces requested by the generic module</strong></p></blockquote><p>应该提供所有的接口，若是不支持就提供空的实现</p><blockquote><p><strong>[SRS_BSW_00451] Hardware registers shall be protected if concurrent access to these registers occur</strong></p></blockquote><p>如果并发访问硬件寄存器，那应该加一些保护</p><blockquote><p><strong>[SRS_BSW_00478] Timing limits of main functions</strong></p></blockquote><h3 id="shutdown-operation"><a class="anchor" href="#shutdown-operation">#</a> Shutdown Operation</h3><blockquote><p><strong>[SRS_BSW_00336] Basic SW module shall be able to shutdown</strong></p></blockquote><p>应该能去死</p><h3 id="fault-operation-and-error-detection"><a class="anchor" href="#fault-operation-and-error-detection">#</a> Fault Operation and Error Detection</h3><blockquote><p><strong>[SRS_BSW_00337] Classification of development errors</strong></p></blockquote><p>给开发错误分类</p><blockquote><p><strong>[SRS_BSW_00369] All AUTOSAR Basic Software Modules shall not return specific development error codes via the API</strong></p></blockquote><p>返回值是开发错误代码</p><blockquote><p><strong>[SRS_BSW_00339] Reporting of production relevant error status</strong></p><p>AUTOSAR Basic Software Modules shall report all production errors and extended production errors to the Dem (Diagnostic Event Manager)</p></blockquote><p>报给 DEM 去集中处理错误</p><blockquote><p><strong>[SRS_BSW_00422] Pre-de-bouncing of error status information is done within the Dem</strong></p></blockquote><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240716141143275.png" alt="image-20240716141143275"></p><blockquote><p><strong>[SRS_BSW_00417] Software which is not part of the SW-C shall report error events only after the Dem is fully operational.</strong></p></blockquote><p>为了简化处理，除了 SWC 其他的软件在 DEM 完全运行之后才进行处理</p><blockquote><p><strong>[SRS_BSW_00323] All AUTOSAR Basic Software Modules shall check passed API parameters for validity</strong></p></blockquote><p>检查参数</p><blockquote><p><strong>[SRS_BSW_00004] All Basic SW Modules shall perform a pre-processor check of the versions of all imported include files</strong></p></blockquote><p>在包含头文件时要检查版本信息是否兼容</p><blockquote><p><strong>[SRS_BSW_00409] All production code error ID symbols are defined by the Dem module and shall be retrieved by the other BSW modules from Dem configuration</strong></p></blockquote><p>错误码在 DEM 中定义</p><blockquote><p><strong>[SRS_BSW_00385] List possible error notifications</strong></p></blockquote><p>应该列出可能的错误提醒</p><blockquote><p><strong>[SRS_BSW_00386] The BSW shall specify the configuration and conditions for detecting an error</strong></p><p><strong>[SRS_BSW_00452] Classification of runtime errors</strong></p><p><strong>[SRS_BSW_00458] Classification of production errors</strong></p><p><strong>[SRS_BSW_00466] Classification of extended production errors</strong></p><p><strong draft="">[SRS_BSW_00488]</strong> <strong>Classification of security events</strong></p><p><strong draft="">[SRS_BSW_00489]</strong> <strong>Reporting of security events</strong></p><p>AUTOSAR Basic Software Modules shall report the configured security events to the IdsM (Intrusion Detection System Manager).</p><p><strong draft="">[SRS_BSW_00490]</strong> <strong>List possible security events</strong></p><p><strong draft="">[SRS_BSW_00491]</strong> <strong>Specification of trigger conditions and context data</strong></p><p><strong draft="">[SRS_BSW_00492]</strong> <strong>Reporting of security events during startup</strong></p><p><strong draft="">[SRS_BSW_00493]</strong> <strong>Definition of security event ID symbols</strong></p><p><strong>[SRS_BSW_00469] Fault detection and healing of production errors and extended production errors</strong></p><p><strong>[SRS_BSW_00470] Execution frequency of production error detection</strong></p><p><strong>[SRS_BSW_00471] Do not cause dead-locks on detection of production errors - the ability to heal from previously detected production errors</strong></p><p><strong>[SRS_BSW_00472] Avoid detection of two production errors with the same root cause</strong></p><p><strong>[SRS_BSW_00473] Classification of transient faults</strong></p></blockquote><h2 id="non-functional-requirements-qualities"><a class="anchor" href="#non-functional-requirements-qualities">#</a> Non-Functional Requirements (Qualities)</h2><h3 id="software-architecture-requirements"><a class="anchor" href="#software-architecture-requirements">#</a> Software Architecture Requirements</h3><blockquote><p><strong>[SRS_BSW_00161] The AUTOSAR Basic Software shall provide a microcontroller abstraction layer which provides a standardized interface to higher software layers</strong></p></blockquote><p>要提供标准的 MCAL 接口给上层</p><blockquote><p><strong>[SRS_BSW_00162] The AUTOSAR Basic Software shall provide a hardware abstraction layer</strong></p></blockquote><p>要提供标准的硬件抽象层接口</p><blockquote><p><strong>[SRS_BSW_00005] Modules of the µC Abstraction Layer (MCAL) may not have hard coded horizontal interfaces</strong></p><p>Necessary interactions (e.g. GPT triggered ADC conversion) shall be implemented by using statically configurable notifications (callbacks).</p></blockquote><p>MCAL 不推荐硬编码，必要的接口用回调函数实现</p><p><strong>软编码</strong>：相对地，软编码实践鼓励将这些固定值抽象出来，通过外部配置文件、数据库或环境变量等方式管理，使得程序在不同环境或需要调整时更加灵活。</p><blockquote><p><strong>[SRS_BSW_00415] Interfaces which are provided exclusively for one module shall be separated into a dedicated header file</strong></p></blockquote><p>专门给一个模块提供的接口需要放在一个单独的头文件里</p><h3 id="software-integration-requirements"><a class="anchor" href="#software-integration-requirements">#</a> Software Integration Requirements</h3><blockquote><p><strong>[SRS_BSW_00164] The Implementation of interrupt service routines shall be done by the Operating System, complex drivers or modules</strong></p></blockquote><blockquote><p><strong>[SRS_BSW_00325] The runtime of interrupt service routines and functions that are running in interrupt context shall be kept short</strong></p></blockquote><p>中断应该占用时间短，如果用时较长就使用 OS Task 来替代</p><blockquote><p><strong>[SRS_BSW_00342] It shall be possible to create an AUTOSAR ECU out of modules provided as source code and modules provided as object code, even mixed</strong></p><p>Some simple drivers could be provided as object code. More complex and configurable modules could be provided as source code or even generated code.</p></blockquote><p>可以拆出配置代码</p><blockquote><p><strong>[SRS_BSW_00343] The unit of time for specification and configuration of Basic SW modules shall be preferably in physical time unit</strong></p><p><strong>[SRS_BSW_00160] Configuration files of AUTOSAR Basic SW module shall be readable for human beings</strong></p></blockquote><p>配置文件因该具有可读性</p><blockquote><p><strong>[SRS_BSW_00453] BSW Modules shall be harmonized</strong></p><p><strong>[SRS_BSW_00456] A Header file shall be defined in order to harmonize BSW Modules</strong></p></blockquote><p>如果这个类型定义需要被多个模块引用</p><p>那需要在 &lt;Module Abbreviation&gt;_GeneralTypes.h 头文件中声明</p><blockquote><p><strong>[SRS_BSW_00457] Callback functions of Application software components shall be invoked by the Basis SW</strong></p></blockquote><p>ASW 的回调是被 BSW 调用</p><blockquote><p><strong>[SRS_BSW_00479] Interfaces for handling request from external devices</strong></p></blockquote><p>外部设备同样要符合规范</p><blockquote><p><strong>[SRS_BSW_00483] BSW Modules shall handle buffer alignments internally</strong></p></blockquote><p>BSW 模块应该在内部处理 Buffer 对齐</p><h3 id="software-module-design-requirements"><a class="anchor" href="#software-module-design-requirements">#</a> Software Module Design Requirements</h3><blockquote><p><strong>[SRS_BSW_00007] All Basic SW Modules written in C language shall conform to the MISRA C 2012 Standard.</strong></p></blockquote><p>要符合 MISRA C 规范，违反规范要注明</p><blockquote><p><strong>[SRS_BSW_00413] An index-based accessing of the instances of BSW modules shall be done</strong></p></blockquote><p>基于索引的 BSW 模块</p><blockquote><p><strong>[SRS_BSW_00347] A Naming seperation of different instances of BSW drivers shall be in place</strong></p><p>Driver modules shall be named according to the following rules (only for implementation, not for the software specification):</p><ul><li>First the module name has to be listed: &lt;Module Abbreviation&gt;</li><li>After that the vendor Id defined in the AUTOSAR vendor list has to be given &lt;Vendor Id</li><li>At last a vendor specific name (the vendor API infix) follows &lt;Vendor APIinfix&gt;</li><li>Only for API names, last name shall be &lt;API Service name&gt;</li><li>All parts shall be separated by underscores "_".</li><li>This naming extension applies to the following externally visible elements of the module:<ul><li>File names</li><li>API names</li><li>Published parameters</li><li>Memory allocation keyword</li></ul></li><li>For API names, &lt;Vendor specific name&gt; should be followed by "_" and the &lt;API Service Name&gt;.</li><li>For the creation of file names, no trailing underscore shall be added.</li><li>For Published parameters and Memory allocation keyword names, &lt;Vendor Specific name&gt; shall have a trailing underscores.</li></ul></blockquote><p>Examples:</p><ul><li>EEPROM (LD): Eep_21_LDExtEepDriver.c</li><li>Published parameters: EEP_21_LDEXT_SW_MAJOR_VERSION</li><li>API: Eep_21_LDExt_Init</li></ul><p>一些命名规范啦</p><blockquote><p><strong>[SRS_BSW_00441] Naming convention for type, macro and function</strong></p><p>All AUTOSAR Basic Software Modules shall label enumeration literals and</p><p>#defines according to the following scheme:</p><ul><li>Composition: &lt;Module Abbreviation&gt;_&lt;Specific name&gt;</li><li>&lt;Module Abbreviation&gt; shall be written in UPPERCASE</li><li>&lt;Specific name&gt; shall be written in UPPERCAS</li><li>&lt;Module Abbreviation&gt; and &lt;Specific name&gt; shall be separated by underscore</li><li>If &lt;Specific name&gt; consists of several words, they shall be separated by underscore</li></ul><p>The #define E_OK and E_NOT_OK are exceptions to this.</p></blockquote><p>Example #define:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EEP_PARAM_CONFIG</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EEP_SIZE</span></span></pre></td></tr></tbody></table></figure><p>Example enumeration literals:</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    EEP_DRA_CONFIG <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    EEP_ARE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    EEP_EV <span class="token operator">=</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">}</span> Eep_NotificationType<span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><p>类型、宏、函数的命名约定</p><blockquote><p><strong>[SRS_BSW_00305] Data types naming convention</strong></p><p>All AUTOSAR Basic Software Modules shall label data types according to the following scheme:</p><ul><li>Composition of type: &lt;Module name&gt;_&lt;Type name&gt;Type</li><li>Only one underscore between module name and type name</li><li>&lt; Type name &gt; shall be written in UpperCamelCase.</li></ul></blockquote><p>数据类型的命名约束</p><blockquote><p><strong>[SRS_BSW_00307] Global variables naming convention</strong></p><ul><li>All AUTOSAR Basic Software Modules shall label global variables according to the following scheme:</li><li>Composition of name: &lt;Module name&gt;_&lt;Variable name&gt;</li><li>Only one underscore between module name and variable name</li><li>Spelling of name: First letter of each word upper case, consecutive letters lower case</li></ul></blockquote><p>全局变量命名约定</p><blockquote><p><strong>[SRS_BSW_00310] API naming convention</strong></p><p>All AUTOSAR Basic Software Modules shall implement an API based on the following naming rules:</p><ul><li>Composition of API: &lt;Module name&gt;_ServiceName()</li></ul><p>&lt;Mip&gt;_&lt;Sn&gt;</p><ul><li>Where &lt;Mip&gt; is the Module implementation prefix and &lt;Sn&gt; is the API Service name Module name: 2..8 letters, derived from [7]</li><li>Only one underscore between module name and service name</li><li>Spelling of API: First letter of each word upper case, consecutive letter lower case</li></ul></blockquote><p>例子：</p><ul><li>Can_TransmitFrame()</li><li>Nm_RequestBusCommunication()</li><li>Adc_Init()</li><li>Eep_Write(</li><li>Nvm_GetState()</li></ul><blockquote><p><strong>[SRS_BSW_00494] ServiceInterface argument with a pointer datatype</strong></p><p>A ServiceInterface argument with a pointer datatype (DATA_REFERENCE) shall have a Ptr postfix in its argument type and -name. No other argument type shall use this postfix in its argument type or -name. The argument direction of a pointer datatype is always IN.</p></blockquote><p>服务接口的参数是一个指针</p><blockquote><p><strong>[SRS_BSW_00373] The main processing function of each AUTOSAR Basic Software Module shall be named according the defined convention</strong></p><p>The main processing function of each AUTOSAR Basic Software Module shall be named according to the following rule:</p><p>&lt;Module name&gt;_MainFunction_&lt;module specific extension&gt; ()</p><p>Module specific extension shall be used to distinguish between multiple mainprocessing functions of one module (e.g. Cluster index, Rx /Tx <em>. . .</em> ). If only one main processing function exists in one module no module specific extension is required.</p><p>It is responsibility of the modules to either define one main processing function and handle all the processing internally or define multiple main processing functions with appropriate module specific extensions.</p><p>This depends on Module requirements.</p><p>Main processing functions shall have no parameters and no return value.</p><p>Main processing functions shall not be re-entrant.</p></blockquote><p>用例</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>Possible main processing function of EEPROM driver<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">Eep_MainFunction</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Possible main processing functions of FlexRay driver<span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fr_MainFunction_TxClst1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fr_MainFunction_TxClst2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fr_MainFunction_RxClst1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fr_MainFunction_RxClst2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>Please Note<span class="token operator">:</span> The Use <span class="token keyword">case</span> is no recommendation <span class="token keyword">for</span> the particular Module<span class="token punctuation">,</span> it just illustrates Main processing function possibilities<span class="token punctuation">.</span></pre></td></tr></tbody></table></figure><p>主处理函数的命名</p><blockquote><p><strong>[SRS_BSW_00327] Error values naming convention</strong></p><p>All AUTOSAR Basic Software Modules shall apply the following naming rules for all error values:</p><ul><li>Error values shall have only CAPITAL LETTERS</li><li>Naming convention: &lt;MODULENAME&gt;<em>E</em>&lt;ERRORNAME&gt;</li><li>If &lt;ERRORNAME&gt; consists of several words, they shall be separated by underscores</li></ul></blockquote><p>例子</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>The EEPROM driver has the following error values<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>• EEP_E_BUSY</pre></td></tr><tr><td data-num="3"></td><td><pre>• EEP_E_PARAM_ADDRESS</pre></td></tr><tr><td data-num="4"></td><td><pre>• EEP_E_PARAM_LENGTH</pre></td></tr><tr><td data-num="5"></td><td><pre>• EEP_E_WRITE_FAILED</pre></td></tr></tbody></table></figure><blockquote><p><strong>[SRS_BSW_00335] Status values naming convention</strong></p><p>All AUTOSAR Basic Software Modules shall apply the following naming rules for status values that are visible outside of the module:</p><ul><li>Status values shall have only CAPITAL LETTERS</li><li>If &lt;STATUSNAME&gt; consists of several words, they shall be separated by underscores</li></ul></blockquote><p>例子</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>The Eeprom driver has the following status values<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>• EEP_UNINIT</pre></td></tr><tr><td data-num="3"></td><td><pre>• EEP_IDLE</pre></td></tr><tr><td data-num="4"></td><td><pre>• EEP_BUSY</pre></td></tr></tbody></table></figure><blockquote><p><strong>[SRS_BSW_00350] All AUTOSAR Basic Software Modules shall allow the enabling/disabling of detection and reporting of development errors.</strong></p></blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>In Eep<span class="token punctuation">.</span>h<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EEP_DEV_ERROR_DETECT</span> <span class="token expression">STD_ON </span><span class="token comment">/* detection module</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>wide enabled */</pre></td></tr><tr><td data-num="4"></td><td><pre>In source Eep<span class="token punctuation">.</span>c<span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Eep.h"</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> EEP_DEV_ERROR_DETECT <span class="token operator">==</span> STD_ON <span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span> development errors to be detected</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* EEP_DEV_ERROR_DETECT */</span></span></pre></td></tr></tbody></table></figure><p>可以用使能 / 使能检测和报告开发错误</p><blockquote><p><strong>[SRS_BSW_00408] All AUTOSAR Basic Software Modules configuration parameters shall be named according to a specific naming rule</strong></p><p>All AUTOSAR Basic Software Modules configuration parameters shall be named according to the following naming rules:</p><ul><li>Naming convention: &lt;Module Abbreviation&gt;&lt;ParameterName&gt;</li></ul><p>&lt; Module Abbreviation &gt; is the prefix derived from [7].</p><p>&lt; ParameterName &gt; may consist of several words which may or may not be separated by underscore.</p><p>The configuration parameter name can either be in UpperCamelCase or Uppercase</p></blockquote><p>Example: CanIfTxConfirmation</p><p>配置参数的命名规范</p><blockquote><p><strong>[SRS_BSW_00410] Compiler switches shall have defined values</strong></p></blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>Example<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Do <span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> EEP_DEV_ERROR_DETECT <span class="token operator">==</span> STD_ON <span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Don’t<span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">EEP_DEV_ERROR_DETECT</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></tbody></table></figure><p>宏定义要有值</p><blockquote><p><strong>[SRS_BSW_00411] All AUTOSAR Basic Software Modules shall apply a naming rule for enabling/disabling the existence of the API</strong></p></blockquote><p>所有 AUTOSAR 的 API 都应该用宏定义来开关</p><blockquote><p><strong>[SRS_BSW_00463] Naming convention of callout prototypes</strong></p></blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>Each callout function shall be mapped to its own memory section and memory class<span class="token punctuation">.</span> These memory classes will then be mapped to the actually implemented memory classes at integration time<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>The following naming convention shall be used<span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>— Start section definition<span class="token operator">:</span> —</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>\#define MSN_START_SEC_CBN_CODE</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>— Stop section definition<span class="token operator">:</span> —</pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>\#define MSN_STOP_SEC_CBN_CODE</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>— Function prototype definition<span class="token operator">:</span> —</pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">MSN_Cbn</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>Where<span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>MSN<span class="token operator">:</span> Module Short Name as officially defined in <span class="token function">AUTOSAR</span> <span class="token punctuation">(</span>see supporting material<span class="token punctuation">)</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>CBN<span class="token operator">:</span> Call Back Name<span class="token punctuation">,</span> which shall have the same spelling of the Callback name including module reference but using only capital letters<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>Cbn<span class="token operator">:</span> Callback name using the conventional Camel Case notation <span class="token keyword">for</span> API names<span class="token punctuation">.</span></pre></td></tr></tbody></table></figure><p>Callback 的命名约定</p><blockquote><p><strong>[SRS_BSW_00464] File names shall be considered case sensitive regardless of the filesystem in which they are used</strong></p><p><strong>[SRS_BSW_00465] It shall not be allowed to name any two files so that they only differ by the cases of their letters</strong></p></blockquote><p>文件名字要区分大小写，不允许两个文件名只有大小写不一致</p><blockquote><p><strong>[SRS_BSW_00480] Null pointer errors shall follow a naming rule</strong> &lt;MIP&gt;_E_PARAM_POINTER</p></blockquote><p>空指针错误</p><blockquote><p><strong>[SRS_BSW_00487] Errors for module initialization shall follow a naming rule</strong> &lt;MIP&gt;_E_UNINIT</p></blockquote><p>初始化错误</p><blockquote><p><strong>[SRS_BSW_00481] Invalid configuration set selection errors shall follow a naming rule</strong></p><p><strong>[SRS_BSW_00482] Get version information function shall follow a naming rule</strong></p><p><strong>[SRS_BSW_00346] All AUTOSAR Basic Software Modules shall provide at least a basic set of module files</strong></p><p><strong>[SRS_BSW_00314] All internal driver modules shall separate the interrupt frame definition from the service routine</strong></p><p>All internal driver modules shall separate the interrupt frame definition from the service routine in the following way:</p><ul><li>&lt;Module name&gt;_Irq.c: implementation of interrupt frame</li><li>&lt;Module name&gt;.c: implementation of service routine called from interrupt frame</li></ul></blockquote><p>中断要单独出一个文件</p><blockquote><p><strong>[SRS_BSW_00447] Standardizing Include file structure of BSW Modules Implementing Autosar Service</strong></p><p><strong>[SRS_BSW_00348] All AUTOSAR standard types and constants shall be placed and organized in a standard type header file</strong></p><p><strong>[SRS_BSW_00353] All integer type definitions of target and compiler specific scope shall be placed and organized in a single type header</strong></p><p><strong>[SRS_BSW_00301] All AUTOSAR Basic Software Modules shall only import the necessary information</strong></p><p><strong>[SRS_BSW_00302] All AUTOSAR Basic Software Modules shall only export information needed by other modules</strong></p><p><strong>[SRS_BSW_00328] All AUTOSAR Basic Software Modules shall avoid the duplication of code</strong></p></blockquote><p>都是一些头文件的结构啊说明啊什么的</p><blockquote><p><strong>[SRS_BSW_00312] Shared code shall be reentrant</strong></p></blockquote><p>代码可重入</p><blockquote><p><strong>[SRS_BSW_00006] The source code of software modules above the µC Abstraction Layer (MCAL) shall not be processor and compiler dependent.</strong></p></blockquote><p>硬件抽象</p><blockquote><p><strong>[SRS_BSW_00439] Enable BSW modules to handle interrupts</strong></p><p><strong>[SRS_BSW_00448] Module SWS shall not contain requirements from other modules</strong></p></blockquote><p>没看懂</p><blockquote><p><strong>[SRS_BSW_00449] BSW Service APIs used by Autosar Application Software shall return a Std_ReturnType</strong></p><p><strong>[SRS_BSW_00357] For success/failure of an API call a standard return type shall be defined</strong></p><p><strong>[SRS_BSW_00377] A Basic Software Module can return a module specific types</strong></p></blockquote><p>要有返回值</p><blockquote><p><strong>[SRS_BSW_00304] All AUTOSAR Basic Software Modules shall use only AUTOSAR data types instead of native C data types</strong></p></blockquote><p>要使用 AUTOSAR 定义的类型来代替原生 C 数据类型</p><blockquote><p><strong>[SRS_BSW_00378] AUTOSAR shall provide a boolean type</strong></p></blockquote><p>bool 类型</p><blockquote><p><strong>[SRS_BSW_00306] AUTOSAR Basic Software Modules shall be compiler and platform independent</strong></p></blockquote><p>要独立于编译器和平台</p><blockquote><p><strong>[SRS_BSW_00308] AUTOSAR Basic Software Modules shall not define global data in their header files, but in the C file</strong></p></blockquote><p>不要在头文件中定义全局数据，在 C 文件中定义</p><blockquote><p><strong>[SRS_BSW_00309] All AUTOSAR Basic Software Modules shall indicate all global data with read-only purposes by explicitly assigning the const keyword</strong></p></blockquote><p>只读的要加 const</p><blockquote><p><strong>[SRS_BSW_00484] Input parameters of scalar and enum types shall be passed as a value.</strong></p></blockquote><p>枚举类型应该作为值传递</p><blockquote><p><strong>[SRS_BSW_00485] Input parameters of structure type shall be passed as a reference to a constant structure</strong></p></blockquote><p>结构体的参数要使用指针来引用</p><blockquote><p><strong>[SRS_BSW_00486] Input parameters of array type shall be passed as a reference to the constant array base type</strong></p></blockquote><p>数组的参数要作为一个常数数组指针类型传入</p><blockquote><p><strong>[SRS_BSW_00358] The return type of init() functions implemented by AUTOSAR Basic Software Modules shall be void</strong></p></blockquote><p>init 函数返回值为空</p><blockquote><p><strong>[SRS_BSW_00414] Init functions shall have a pointer to a configuration structure as single parameter</strong></p></blockquote><p>init 函数应有单一一个指向配置的指针传入</p><blockquote><p><strong>[SRS_BSW_00359] All AUTOSAR Basic Software Modules callback functions shall avoid return types other than void if possible</strong></p></blockquote><p>回调函数的返回值都是 void</p><blockquote><p><strong>[SRS_BSW_00360] AUTOSAR Basic Software Modules callback functions are allowed to have parameters</strong></p></blockquote><p>允许回调函数有参数</p><blockquote><p><strong>[SRS_BSW_00440] The callback function invocation by the BSW module shall follow the signature provided by RTE to invoke servers via</strong> <strong>Rte_Call</strong> <strong>API</strong></p><p><strong>[SRS_BSW_00330] It shall be allowed to use macros instead of functions where source code is used and runtime is critical</strong></p><p>It shall be allowed to use macros instead of functions where source code is used and runtime is critical.</p><p>It shall be allowed to use inline functions for the same purpose. Inline functions have the advantage (compared to macros) that the compiler can do type checking of function parameters and return values.</p></blockquote><p>可以使用宏和内联函数</p><blockquote><p><strong>[SRS_BSW_00331] All Basic Software Modules shall strictly separate error and status information</strong></p><p><strong>[SRS_BSW_00462] All Standardized Autosar Interfaces shall have unique requirement Id / number</strong></p><p><strong>[SRS_BSW_00454] An alternative interface without a parameter of category DATA_REFERENCE shall be available.</strong></p><p><strong>[SRS_BSW_00477] The functional interfaces of AUTOSAR BSW modules shall be specified in C99</strong></p><p><strong>[SRS_BSW_00459] It shall be possible to concurrently execute a service offered by a BSW module in different partitions</strong></p><p><strong>[SRS_BSW_00460] Reentrancy Levels</strong></p></blockquote><h3 id="software-documentation-requirements"><a class="anchor" href="#software-documentation-requirements">#</a> Software Documentation Requirements</h3><blockquote><p><strong>[SRS_BSW_00009] All Basic SW Modules shall be documented according to a common standard.</strong></p></blockquote><p>所有的模块都应该标准文档化</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>The module documentation shall contain at least the following items<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>• Cover sheet with title<span class="token punctuation">,</span> version number<span class="token punctuation">,</span> date<span class="token punctuation">,</span> author<span class="token punctuation">,</span> document status<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>document name</pre></td></tr><tr><td data-num="4"></td><td><pre>• Change history with version number<span class="token punctuation">,</span> date<span class="token punctuation">,</span> author<span class="token punctuation">,</span> change description<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>document status</pre></td></tr><tr><td data-num="6"></td><td><pre>• Table of <span class="token function">contents</span> <span class="token punctuation">(</span>navigable<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>• Functional overview</pre></td></tr><tr><td data-num="8"></td><td><pre>• Source file list and description</pre></td></tr><tr><td data-num="9"></td><td><pre>• Module requirements</pre></td></tr><tr><td data-num="10"></td><td><pre>• Used <span class="token function">resources</span> <span class="token punctuation">(</span>interrupts<span class="token punctuation">,</span> µC peripherals etc<span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>• Integration <span class="token function">description</span> <span class="token punctuation">(</span>OS<span class="token punctuation">,</span> interface to other modules etc<span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>• Configuration description with parameter<span class="token punctuation">,</span> description<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> validrange<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">default</span> value<span class="token punctuation">,</span> relation to other parameters</pre></td></tr><tr><td data-num="14"></td><td><pre>The module documentation shall also contain examples <span class="token keyword">for</span></pre></td></tr><tr><td data-num="15"></td><td><pre>• the correct usage of the API</pre></td></tr><tr><td data-num="16"></td><td><pre>• the configuration of the module</pre></td></tr></tbody></table></figure><blockquote><p><strong>[SRS_BSW_00401] Documentation of multiple instances of configuration parameters shall be available</strong></p><p><strong>[SRS_BSW_00172] The scheduling strategy that is built inside the Basic Software Modules shall be compatible with the strategy used in the system</strong></p><p><strong>[SRS_BSW_00010] The memory consumption of all Basic SW Modules shall be documented for a defined configuration for all supported platforms.</strong></p></blockquote><p>文档记录参数配置还有 ROM/RAM 的消耗</p><blockquote><p><strong>[SRS_BSW_00333] For each callback function it shall be specified if it is called from interrupt context or not</strong></p></blockquote><p>应该指出是否可以在中断中调用</p><blockquote><p><strong>[SRS_BSW_00374] All Basic Software Modules shall provide a readable module vendor identification</strong></p></blockquote><p>应该可读供应商标识</p><blockquote><p><strong>[SRS_BSW_00379] All software modules shall provide a module identifier in the header file and in the module XML description file.</strong></p></blockquote><p>头文件中有模块 ID</p><blockquote><p><strong>[SRS_BSW_00003] All software modules shall provide version and identification information</strong></p></blockquote><p>提供软件版本信息</p><blockquote><p><strong>[SRS_BSW_00318] Each AUTOSAR Basic Software Module file shall provide version numbers in the header file</strong></p><p><strong>[SRS_BSW_00321] The version numbers of AUTOSAR Basic Software Modules shall be enumerated according specific rules</strong></p></blockquote><p>也要有规范的版本号</p><blockquote><p><strong>[SRS_BSW_00341] Module documentation shall contains all needed informations</strong></p><p><strong>[SRS_BSW_00334] All Basic Software Modules shall provide an XML file that contains the meta data</strong></p><p><strong>[SRS_BSW_00351] Encapsulation of compiler specific methods to map objects</strong></p></blockquote><h1 id="errordescription"><a class="anchor" href="#errordescription">#</a> ErrorDescription</h1><h2 id="generic-mechanisms"><a class="anchor" href="#generic-mechanisms">#</a> Generic Mechanisms</h2><h3 id="report-to-the-diagnostic-event-manager-dem"><a class="anchor" href="#report-to-the-diagnostic-event-manager-dem">#</a> Report to the Diagnostic Event Manager (DEM)</h3><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708171447383.png" alt="image-20240708171447383"></p><h3 id="diagnostic-event-manager"><a class="anchor" href="#diagnostic-event-manager">#</a> Diagnostic Event Manager</h3><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708172006241.png" alt="image-20240708172006241"></p><h3 id="det"><a class="anchor" href="#det">#</a> DET</h3><blockquote><p>The DET (Default Error Tracer) provides access to the DEM and RTE(SW-C) over integrator specific code. The occurrence of a <em>runtime error</em> (signaled by calling Det_ReportRuntimeError API) or <em>transient fault</em> (signaled by calling the Det_ReportTransientFault API) triggers the execution of a corresponding error handler which may be implemented as callout within the Det by an integrator of a particular ECU and may only include the storage of the corresponding error event to a memory, a call to the module Dem or the execution of short and reasonable actions.</p></blockquote><p>默认错误追踪</p><h3 id="function-inhibition-manager"><a class="anchor" href="#function-inhibition-manager">#</a> Function Inhibition Manager</h3><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708175232556.png" alt="image-20240708175232556"></p><h3 id="rte"><a class="anchor" href="#rte">#</a> RTE</h3><blockquote><p>The RTE provides access to the DEM and FIM operations for the SWCs. It executes the runnables associated to the DEM monitors (DEM callbacks) when information is required from a SWC or when a SWC must be notified. No specific functionalities are provided for the DEM by the RTE.</p></blockquote><p>RTE 为上层 SWC 提供了这些接口</p><h2 id="communication-related-errors"><a class="anchor" href="#communication-related-errors">#</a> Communication related errors</h2><h3 id="overview"><a class="anchor" href="#overview">#</a> Overview</h3><h4 id="error-handling-mechanisms"><a class="anchor" href="#error-handling-mechanisms">#</a> Error handling mechanisms</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708175349485.png" alt="image-20240708175349485"></p><h4 id="error-list-for-can-stack"><a class="anchor" href="#error-list-for-can-stack">#</a> Error list for CAN stack</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709105633398.png" alt="image-20240709105633398"></p><h4 id="mappings-of-eh-mechanisms-to-hardware-failure-modes"><a class="anchor" href="#mappings-of-eh-mechanisms-to-hardware-failure-modes">#</a> Mappings of EH mechanisms to hardware failure modes</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709110528161.png" alt="image-20240709110528161"></p><h3 id="loss-of-communication-channel"><a class="anchor" href="#loss-of-communication-channel">#</a> Loss of communication channel</h3><h4 id="can-bus-off"><a class="anchor" href="#can-bus-off">#</a> CAN Bus Off</h4><h5 id="summary"><a class="anchor" href="#summary">#</a> Summary</h5><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709111600994.png" alt="image-20240709111600994"></p><blockquote><p>Note: The AUTOSAR COM module (or other modules like CANNM or CANTP) will react on a BusOff indirectly because of the loss of the communication channel, but it is not aware of the specific kind of error. For this reason, these modules are not considered in this section.</p></blockquote><p>COM 模块将会间接反应在 BussOff，因此不考虑</p><h5 id="roles-of-the-modules"><a class="anchor" href="#roles-of-the-modules">#</a> Roles of the modules</h5><p><strong>CAN controller (peripheral)</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709112827606.png" alt="image-20240709112827606"></p><p><strong>CAN Driver</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709113051848.png" alt="image-20240709113051848"></p><p><strong>CAN Interface</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709113718130.png" alt="image-20240709113718130"></p><p><strong>CAN State Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709113922514.png" alt="image-20240709113922514"></p><p><strong>Communication Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709113944157.png" alt="image-20240709113944157"></p><p><strong>BSW State Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114004912.png" alt="image-20240709114004912"></p><h4 id="can-controller-hardware-timeout"><a class="anchor" href="#can-controller-hardware-timeout">#</a> CAN Controller Hardware Timeout</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114028472.png" alt="image-20240709114028472"></p><h5 id="roles-of-the-modules-2"><a class="anchor" href="#roles-of-the-modules-2">#</a> Roles of the modules</h5><p><strong>CAN Driver</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114620394.png" alt="image-20240709114620394"></p><p><strong>CAN Interface</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114740065.png" alt="image-20240709114740065"></p><p><strong>CAN State Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114754334.png" alt="image-20240709114754334"></p><p><strong>Communication Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114813484.png" alt="image-20240709114813484"></p><p><strong>BSW State Manager</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114827572.png" alt="image-20240709114827572"></p><h3 id="signal-error"><a class="anchor" href="#signal-error">#</a> Signal error</h3><h4 id="can-transmission-buffer-full"><a class="anchor" href="#can-transmission-buffer-full">#</a> CAN Transmission buffer full</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709114851469.png" alt="image-20240709114851469"></p><h5 id="roles-of-the-modules-3"><a class="anchor" href="#roles-of-the-modules-3">#</a> <strong>Roles of the modules</strong></h5><p><strong>CAN Driver</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709142548459.png" alt="image-20240709142548459"></p><p><strong>CAN Interface</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709142619671.png" alt="image-20240709142619671"></p><blockquote><p>See also the COM TX Deadline Monitoring, which provide a mechanism to detect and react (from SWC) in case of such an error.</p><p>This error may also impact a TP (Transport Protocol) communication; in that case, this will be detected as a CAN Transport Protocol error during transmission.</p></blockquote><h4 id="can-reception-dlc-error"><a class="anchor" href="#can-reception-dlc-error">#</a> CAN Reception DLC error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143115793.png" alt="image-20240709143115793"></p><blockquote><p>Note: the CAN Reception DLC error can be used in combination with the COM RX Deadline Monitoring mechanism.</p><p>Also, the reception of a wrong DLC does not necessarily indicate a malfunction in the ECU, but can be caused by the ECU’s environment.</p></blockquote><h5 id="roles-of-the-modules-4"><a class="anchor" href="#roles-of-the-modules-4">#</a> Roles of the modules</h5><p><strong>CAN Interface</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143234463.png" alt="image-20240709143234463"></p><blockquote><p>See also theCOM RX Deadline Monitoring, which provide a mechanism to detect and react (from SWC) in case of such an error.</p><p>This error may also affect the CAN Transport or Network Management protocols; in these cases, the error will also be detected by the CAN Transport Protocol error during reception mechanism or by the Network Management protocol.</p></blockquote><h4 id="com-rx-deadline-monitoring"><a class="anchor" href="#com-rx-deadline-monitoring">#</a> COM RX Deadline Monitoring</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143544239.png" alt="image-20240709143544239"></p><h5 id="roles-of-the-modules-5"><a class="anchor" href="#roles-of-the-modules-5">#</a> Roles of the modules</h5><p><strong>AUTOSAR COM</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143617818.png" alt="image-20240709143617818"></p><p><strong>RTE</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143729548.png" alt="image-20240709143729548"></p><p><strong>SWC</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709143748345.png" alt="image-20240709143748345"></p><p><strong>COM TX Deadline Monitoring</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709151329006.png" alt="image-20240709151329006"></p><h4 id="can-transport-protocol-error-during-transmission"><a class="anchor" href="#can-transport-protocol-error-during-transmission">#</a> CAN Transport Protocol error during transmission</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709153700257.png" alt="image-20240709153700257"></p><blockquote><p>Note: In the figure above, the DCM represents the CANTP user. Other users of CANTP should react similarly (they will receive the indication of failures, and are responsible for initiating a recovery). Another user could be a SWC, with the communication routed to AUTOSAR COM by the PDU Router, or a Complex Driver.</p></blockquote><h4 id="can-transport-protocol-error-during-reception"><a class="anchor" href="#can-transport-protocol-error-during-reception">#</a> <strong>CAN Transport Protocol error during reception</strong></h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709153943504.png" alt="image-20240709153943504"></p><blockquote><p>Note: In the figure above, the DCM represent the CANTP user. Other users of CANTP should react similarly (they will receive the indication of failures, and are responsible for initiating a recovery). Another user could be a SWC, with the communication routed to AUTOSAR COM by the PDU Router, or a Complex Driver.</p></blockquote><h4 id="client-server-timeout"><a class="anchor" href="#client-server-timeout">#</a> Client / Server timeout</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709154019944.png" alt="image-20240709154019944"></p><h2 id="nvram-related-errors"><a class="anchor" href="#nvram-related-errors">#</a> NVRAM related errors</h2><h3 id="overview-2"><a class="anchor" href="#overview-2">#</a> Overview</h3><h4 id="error-handling-mechanisms-2"><a class="anchor" href="#error-handling-mechanisms-2">#</a> Error handling mechanisms</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709154103080.png" alt="image-20240709154103080"></p><blockquote><p>On the lower levels of the NVRAM stack, mechanisms are implemented in the drivers to detect hardware access problems. Detection mechanisms are harmonized between EEPROM and Flash drivers.</p></blockquote><p>在 NVRAM 中驱动实现了检测硬件的机制</p><blockquote><p>On the upper layers of the NVRAM stack (mainly in the NVRAM manager), mechanisms are implemented to detect data corruption, memory address corruption and loss of redundancy. All the recovery mechanisms for the detected errors in the NVRAM stack are handled by the NVRAM Manager.</p></blockquote><p>在 NVRAM 堆栈的上层 (主要在 NVRAM 管理器中)，实现了检测数据损坏、内存地址损坏和冗余丢失的机制。NVRAM 堆栈中检测到的所有错误恢复机制都由 NVRAM 管理器处理。</p><blockquote><p>The error can be reported in polling or interrupt mode. The whole memory stack must be configured consistently with the usage done by SWC and BSW users.</p></blockquote><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709154729849.png" alt="image-20240709154729849"></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709154844126.png" alt="image-20240709154844126"></p><h3 id="driver-level-errors"><a class="anchor" href="#driver-level-errors">#</a> Driver level errors</h3><h4 id="flash-write-job-error"><a class="anchor" href="#flash-write-job-error">#</a> Flash write job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709155019883.png" alt="image-20240709155019883"></p><blockquote><p>Write job error is detected by HW (1). Flash Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. A recovery mechanism is present in the NVM module which permits to retry a write job in case of failure (3). If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5), see NVM API request failure.</p></blockquote><h4 id="flash-erase-job-error"><a class="anchor" href="#flash-erase-job-error">#</a> Flash erase job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709155141400.png" alt="image-20240709155141400"></p><blockquote><p>Erase job error is detected by HW (1). Flash Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. If the erase driver job is part of a write operation, write retries are initiated by the NVRAM manager (3) as soon as the error is reported to this layer. If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5), see NVM API request failure.</p></blockquote><h4 id="flash-read-job-error"><a class="anchor" href="#flash-read-job-error">#</a> Flash read job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709160921979.png" alt="image-20240709160921979"></p><blockquote><p>Read job error is detected by HW (1). Flash Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. Recovery is initiated by the NVRAM manager (3): one or more read attempts shall be made before continuing to read the redundant block or ROM data. If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5), see NVM API request failure.</p></blockquote><h4 id="flash-compare-job-error"><a class="anchor" href="#flash-compare-job-error">#</a> Flash compare job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161131748.png" alt="image-20240709161131748"></p><blockquote><p>Note: Flash compare function is an internal mechanism for the Flash EEPROM Emulation to determine whether erasing / writing is needed or not. Compare job error is detected by HW (1). Flash Driver is the first SW module involved, and is responsible for the report to the DEM and to the Flash EEPROM Emulation (2) which have to reset some internal states in order to accept new requests.</p></blockquote><h4 id="external-flash-hardware-id-mismatch"><a class="anchor" href="#external-flash-hardware-id-mismatch">#</a> External Flash Hardware ID Mismatch</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161326087.png" alt="image-20240709161326087"></p><blockquote><p>During the initialization of the external flash driver, the FLS module checks if there is a mismatch between the hardware ID of the external flash device and the corresponding published parameter (1). If there is a mismatch, the module stays uninitialized. An error is reported to the DEM and error status can also be forwarded to upper layers via<br>polling (2). No further reaction is described (error not taken into account at the NVRAM manager level). There is no recovery action.</p></blockquote><h4 id="eeprom-write-job-error"><a class="anchor" href="#eeprom-write-job-error">#</a> EEPROM write job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161445243.png" alt="image-20240709161445243"></p><blockquote><p>Write job error is detected by HW (1). EEPROM Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. A recovery mechanism is present in the NVM module which permits to retry a write job in case of failure (3). If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5), see NVM API request failure.</p></blockquote><h4 id="eeprom-erase-job-error"><a class="anchor" href="#eeprom-erase-job-error">#</a> EEPROM erase job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161521402.png" alt="image-20240709161521402"></p><blockquote><p>Erase job error is detected by HW (1). EEPROM Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. If the erase driver job is part of a write operation, write retries are initiated by the NVRAM manager (3) as soon as the error is reported to this layer. If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5),see NVM API request failure.</p></blockquote><h4 id="eeprom-read-job-error"><a class="anchor" href="#eeprom-read-job-error">#</a> EEPROM read job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161616149.png" alt="image-20240709161616149"></p><blockquote><p>Read job error is detected by HW (1). EEPROM Driver is the first SW module involved, and is responsible for the report to the DEM and to upper layers (2). Upper layers have to reset some internal states in order to accept new requests. Recovery is initiated by the NVRAM manager (3): one or more read attempts shall be made before continuing to read the redundant block or ROM data. If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery also fails (4), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NOK (5), see NVM API request failure.</p></blockquote><h4 id="eeprom-compare-job-error"><a class="anchor" href="#eeprom-compare-job-error">#</a> EEPROM compare job error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161716795.png" alt="image-20240709161716795"></p><blockquote><p>Note: EEPROM compare function is an internal mechanism for the EEPROM Abstrac tion to determine whether erasing / writing is needed or not. Compare job error is detected by HW (1). EEPROM Driver is the first SW module involved, and is responsible for the report to the DEM and to the Flash EEPROM Emulation (2) which have to reset some internal states in order to accept new requests.</p></blockquote><h3 id="eeprom-abstraction-flash-emulation-level-errors"><a class="anchor" href="#eeprom-abstraction-flash-emulation-level-errors">#</a> EEPROM Abstraction / Flash Emulation level errors</h3><h4 id="fee-consistency-check-error"><a class="anchor" href="#fee-consistency-check-error">#</a> FEE consistency check error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161752371.png" alt="image-20240709161752371"></p><blockquote><p>The Flash EEPROM Emulation checks the consistency of the read data (1). If a con sistency error is detected, error status is forwarded to the NVRAM manager (2). The NVRAM manager reports NVM_E_INTEGRITY_FAILED to the DEM (3). Recovery is also initiated: "read retry", "read redundant block" and "read ROM block", if configured (4).If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery fails (5), the job result is set to NVM_REQ_INTEGRITY_FAILED (6).</p></blockquote><h4 id="ea-consistency-check-error"><a class="anchor" href="#ea-consistency-check-error">#</a> EA consistency check error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709161856490.png" alt="image-20240709161856490"></p><blockquote><p>The EEPROM Abstraction checks the consistency of the read data (1). If a consistency error is detected, error status is forwarded to the NVRAM manager (2). The NVRAM manager reports NVM_E_INTEGRITY_FAILED to the DEM and recovery is initiated: "read retry", "read redundant block" and "read ROM block", if configured (3). If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery fails (4), the job result is set to NVM_REQ_INTEGRITY_FAILED (5).</p></blockquote><h3 id="nvram-manager-level-errors"><a class="anchor" href="#nvram-manager-level-errors">#</a> NVRAM manager level errors</h3><h4 id="nvm-crc-check"><a class="anchor" href="#nvm-crc-check">#</a> NVM CRC check</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709162106034.png" alt="image-20240709162106034"></p><blockquote><p>If the NV block is configured with CRC, the NVRAM Manager checks if there is a CRC mismatch on the RAM block at the end of the reading operation (1). If so, NVM_E_INTEGRITY_FAILED error is reported to the DEM. Recovery is also initiated: "read retry", "read redundant block" and "read ROM block", if configured (2). If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery fails (3), the job result is set to NVM_REQ_INTEGRITY_FAILED (4).</p></blockquote><h4 id="nvm-write-verification-error"><a class="anchor" href="#nvm-write-verification-error">#</a> NVM write verification error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709162221726.png" alt="image-20240709162221726"></p><blockquote><p>The NVRAM Block written to NV memory is immediately read back and compared with the original content in RAM (1). If the verification fails, NVM_E_VERIFY_FAILED error is reported to the DEM, and recovery is initiated with write retries if configured (2). If the recovery fails (3), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NVM_REQ_NOT_OK (4), see NVM API request failure.</p></blockquote><h4 id="static-block-check-error"><a class="anchor" href="#static-block-check-error">#</a> Static block check error</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709162351197.png" alt="image-20240709162351197"></p><blockquote><p>The Static Block ID check mechanism located in the NVRAM manager provides means to detect if the wrong block has been read from the NV memory due to an addressing problem. The NVRAM Manager stores the NV Block Header including the Static Block ID in the NV Block each time the block is written to NV memory. During read operation, the NV header is compared to the requested block ID (1). If the static block ID check fails then the failure NVM_E_WRONG_BLOCK_ID is reported to DEM and read recovery is initiated ("read retry", "read redundant block" and "read ROM block" if configured) (1). If recovery actions imply a loss of redundancy or the use of ROM data, the NVRAM manager reports the loss of data quality via the job result. A DEM error is reported for the loss of redundancy (see Loss of redundancy). If the recovery also fails (3), the NVRAM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NVM_REQ_NOT_OK (4), see NVM API request failure.</p></blockquote><h4 id="loss-of-redundancy"><a class="anchor" href="#loss-of-redundancy">#</a> Loss of redundancy</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709162418482.png" alt="image-20240709162418482"></p><blockquote><p>In case one redundant block is invalid during read or write (1), an attempt is made by the NVRAM manager to immediately recover the NV Block using data from the incorrupt NV Block (2). If the recovery fails (3), the error code NVM_E_LOSS_OF_REDUNDANCY is reported to the DEM and the NVRAM manager sets the job result to NVM_REQ_REDUNDANCY_FAILED (4).</p></blockquote><h4 id="nvm-api-request-failure"><a class="anchor" href="#nvm-api-request-failure">#</a> NVM API request failure</h4><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240709162822350.png" alt="image-20240709162822350"></p><blockquote><p>The NVRAM manager is notified of an error detected by the subsequent layers during the process of a NVM function or by an internal detection mechanism, write verification static block check, or config ID mismatch (1). Different recovery mechanisms are available at the NVRAM manager level de pending on the type of function involved, writing or reading (2). If the available recovery mechanisms fail (3), the NVM manager reports NVM_E_REQ_FAILED error to the DEM and sets the job result to NVM_REQ_NOT_OK (4).</p></blockquote><h1 id="applicationlevelerrorhandling"><a class="anchor" href="#applicationlevelerrorhandling">#</a> ApplicationLevelErrorHandling</h1><h2 id="error-model"><a class="anchor" href="#error-model">#</a> Error model</h2><blockquote><p>Design of dependable systems is based on a systematic analysis of potential faults (<em>fault models</em>) i.e., a set of postulated faults, derived from the operating environment of the system, which helps the designer or user to predict the consequences of these fault and define mechanisms for handling (detect, recover from etc.) those particular faults.</p></blockquote><p>可靠性系统的设计，假定一些可能出现的错误并实现错误处理。</p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240612161909400.png" alt="image-20240612161909400"></p><h2 id="error-handling-mechanisms-3"><a class="anchor" href="#error-handling-mechanisms-3">#</a> Error handling mechanisms</h2><ul><li>Plausibility checks<ul><li>合理性检查，变量的值的合理性</li></ul></li><li>Substitute Values<ul><li>替代值</li></ul></li><li>Voting<ul><li>构建冗余，去 3 选 2</li></ul></li><li>Agreement<ul><li>The difference between agreement and voting mechanisms is that when using agreement components interact to reach a decision, whereas in voting it is left to the voter to decide. Agreement protocols could be compared with closed loop systems, where the feedback consists of the sent messages received by all other parties.</li><li>闭环有 feedback</li><li>Voting 开环</li></ul></li><li>Checksums/Codes<ul><li>校验和</li></ul></li><li>Execution sequence monitoring<ul><li>执行顺序监控</li></ul></li><li>Aliveness monitoring<ul><li>活力监测</li></ul></li><li>Status and Mode Management<ul><li>状态和模式管理</li><li>Status and mode management deals with meta information for signals, applications, devices, etc. This meta information can be used to analyse the state of the system in order to isolate a faulty subsystem/component and modify its behaviour accordingly.</li><li>状态和模式管理用来处理信号、应用、设备等的元信息。</li><li><strong>Signal status</strong>: In addition to the value, a signal may have meta information as sociated with it, such as<ul><li><strong>Signal quality</strong>: This indicates the quality of the value, such as <em>nominal value</em>, <em>modelled value</em>, <em>replacement value</em>, and <em>default value</em>. The receiver of the signal may react differently depending on the quality of the signal.</li><li><strong>Signal timestamp</strong>: This indicates when the value was created and can be used to check the age of a signal. If a calculation uses several input signals, one can check that all input signals are created within a tolerable time window.</li><li><strong>Signal sequence number</strong>: It may be of interest to check that signal values are received in a certain order, and that no values or lost between reads. Also, sequence numbers can be used in a similar fashion as timestamps in that they allow a check that all values in a group are from a particular creation window (same sequence number, or with a minimum/maximum deviation).</li><li><strong>Update information</strong>: A consumer of a signal may want to know whether a signal has been updated since the last read or not.</li></ul></li><li><strong>Device status</strong>: An application may want to know the status of the devices it uses, such as sensors and actuators. If a device is not in normal operation, applications may want to choose to deliver some form of degraded service.</li><li><strong>Application status/mode</strong>: An application can also have a status, or a mode, which indicates the overall health or operating situation of the application. This status/mode can be used for recovery purposes, both internally in the said application and externally by other application.</li><li><strong>Vehicle mode</strong>: A vehicle may be in a number of different modes (e.g. normal operation, parked, limp-home) and the applications will have to behave accordingly.</li><li><strong>ECU Mode</strong>: An ECU may be in different states, such as sleeping, running, powered down, and transitional states between such states.</li><li>信号状态<ul><li>信号质量</li><li>信号时间戳</li><li>信号序列号</li><li>更新信息</li></ul></li><li>设备状态</li><li>应用状态 / 模式</li><li>车辆模式</li><li>ECU 模式</li></ul></li><li>Reconfiguration<ul><li>A technique for building fault-tolerant systems is to detect and isolate faults and then reconfigure the system to no longer use the faulty component, or to reconfigure to provide only a degraded set of services (or level of service).</li></ul></li><li>Reset</li><li>Error Filtering</li><li>Memory Protection<ul><li>Memory protection is used to protect against errors propagating from one protection domain (partition) to another.</li><li>内存保护防止了从一个内存保护区传播到另一个内存保护区。不同的功能有不同不内存，不能使用不是本功能的内存。</li></ul></li><li>Timing Protection<ul><li>Timing protection refers to protecting the system against activities requiring too much time to complete, such as an executing component taking too much execution time on the processor and thereby hindering the execution of other components, communication delays, peripheral units not responding in time, etc.</li><li>For activities, one may define time budgets providing an upper limit on how much time a given acitivy may use. For example, one may choose to set execution time budgets for components, or a maximum response times for communication.</li><li>对于活跃的任务，设定时间预算。</li></ul></li></ul><h2 id="terminating-and-restarting-partitions"><a class="anchor" href="#terminating-and-restarting-partitions">#</a> Terminating and restarting partitions</h2><blockquote><p>The main focus is on handling faults which lead to one of the following:</p><ul><li>Protection violation caused by erroneous memory access. This is detected by the OS (with support from an MMU).</li><li>Protection violation caused by exceeding of allocated execution time budget. This is detected by the OS.</li><li>Detection of application states which do not trigger a protection violation but require termination or restart of a partition.</li></ul></blockquote><p>主要聚焦处理下面几种错误</p><ul><li>内存访问错误</li><li>超出时间预算</li><li>检测不触发保护但需要终止或重启的冲突</li></ul><h3 id="rationale-use-cases"><a class="anchor" href="#rationale-use-cases">#</a> Rationale - Use Cases</h3><blockquote><p>Terminating and restarting an application is a basic approach to minimizing error propagation and performing error recovery (mainly the restart functionality). Two main usecases have been identified for AUTOSAR error handling and are presented in this section.</p></blockquote><p>终止和重新启动应用程序时减少错误传播的基本原理</p><h4 id="use-case-1-software-partitioning-uc1"><a class="anchor" href="#use-case-1-software-partitioning-uc1">#</a> Use Case 1: Software Partitioning [UC1]</h4><p>软件分区</p><h4 id="use-case-2-application-level-error-handling-uc2"><a class="anchor" href="#use-case-2-application-level-error-handling-uc2">#</a> Use Case 2: Application-level Error Handling [UC2]</h4><p>应用级别错误处理</p><h5 id="error-handling-of-distributed-automotive-applications"><a class="anchor" href="#error-handling-of-distributed-automotive-applications">#</a> Error handling of distributed automotive applications</h5><p>An application-level error manager (ALEM) would deal with issues that arise from such distribution. For example, if the termination of a partition leads to a need to terminate other partitions (not necessarily on the same ECU), this would be triggered by the ALEM.</p><h5 id="oem-specific-error-handling"><a class="anchor" href="#oem-specific-error-handling">#</a> OEM-specific error handling</h5><p>原厂描述的错误状态处理</p><h5 id="application-level-error-managers"><a class="anchor" href="#application-level-error-managers">#</a> Application-level Error Managers</h5><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626145815627.png" alt="image-20240626145815627"></p><h3 id="approach-for-terminating-and-restarting-partitions"><a class="anchor" href="#approach-for-terminating-and-restarting-partitions">#</a> Approach for Terminating and Restarting Partitions</h3><blockquote><p>In the subsequent sections, the text describes the support in AUTOSAR OS, BSW and RTE.</p></blockquote><p>就是介绍遇到错误时的终止和重启的机制</p><h4 id="os-features"><a class="anchor" href="#os-features">#</a> OS features</h4><blockquote><p>An OS Application is a set of OS objects, such as</p><ul><li>tasks,</li><li>interrupt service routines,</li><li>alarms,</li><li>schedule tables</li></ul><p>For instance application specific hook functions can be defined, such as startup and shutdown hook functions.</p></blockquote><p>可以定义 startup 或 shutdown 的钩子函数</p><blockquote><p>For OS controlled objects, there are a number of protection mechanisms available (see[14]). The mechanisms relevant for the termination/restart approach are memory protection and timing protection.</p><p>Memory protection covers stack and data and, optionally,code of OS-Applications.</p><p>Timing protection is based on execution time budgets and arrival rates.</p></blockquote><p>对于 OS 控制的对象</p><table><thead><tr><th>保护类型</th><th>保护内容</th></tr></thead><tbody><tr><td>内存保护</td><td>栈，数据，代码（可选）</td></tr><tr><td>时间保护</td><td>时间预算，到达率</td></tr></tbody></table><blockquote><p>OS-Applications are divided into i) trusted OS-Applications and ii) non-trusted OSApplications (see [14]).</p></blockquote><table><thead><tr><th>OS App</th><th>类型</th><th></th></tr></thead><tbody><tr><td>Trusted OS-Applications</td><td>信任</td><td>特权模式（不受监控）</td></tr><tr><td>Non-trusted OS-Applications</td><td>不信任</td><td>非特权模式（被内存保护和时间保护监控）</td></tr></tbody></table><p><strong>Protection Hook</strong></p><blockquote><p>The system has a single global <em>Protection Hook</em>.</p></blockquote><ul><li>这个钩子如果没有配置就 ShutdownOS ();</li><li>配置了的话根据返回值来处理（函数的实现是可自行决定如何处理的）<ul><li>PRO_IGNORE: Do nothing</li><li>PRO_TERMINATETASK: Forcibly terminate the faulty Task/Category 2 OsIsr</li><li>PRO_TERMINATEAPPL: Forcibly terminate the faulty OS-Application</li><li>PRO_TERMINATEAPPL_RESTART: Forcibly terminate the faulty OS-Application and trigger the execution of the OSRestartTask.</li><li>PRO_SHUTDOWN: Call ShutdownOS().</li></ul></li></ul><p><strong>TerminateApplication() API</strong></p><p>有这么一个函数可以终止 OS-Application</p><p>也可以通过参数去重启</p><p><strong>OSRestartTask</strong></p><p>这个函数执行时他会是当前分区的唯一任务，也有一个决策决定终止 / 重启 OS-Application</p><p><strong>OS-Application state machine</strong></p><ul><li><strong>APPLICATION_ACCESSIBLE</strong></li><li><strong>APPLICATION_RESTARTING</strong></li><li><strong>APPLICATION_TERMINATED</strong></li></ul><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626153321549.png" alt="image-20240626153321549"></p><p><strong>Partition state machine</strong></p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240626153827097.png" alt="image-20240626153827097"></p><p><strong>Error handling strategy in the Protection Hook</strong></p><p>当 OS 发现违反保护时，一下信息需要要收集</p><ul><li><strong>Partition ID</strong></li><li><strong>Error type</strong></li><li><strong>Partition restart counter</strong></li><li><strong>OS-Application State</strong></li></ul><p>Based on the input the Protection Hook needs to decide what to do:</p><ul><li><strong>Do nothing</strong></li><li><strong>Restart the partition</strong></li><li><strong>Terminate the partition</strong></li><li><strong>Shutdown OS/ECU</strong></li></ul><p><strong>Clean-up activities in the OSRestartTask</strong></p><p>当发生 OSRestartTask 时，各个模块有一些必要的处理。</p><p>【AUTOSAR_CP_EXP_ApplicationLevelErrorHandling.pdf】P61 页</p><h4 id="support-for-use-cases"><a class="anchor" href="#support-for-use-cases">#</a> Support for Use Cases</h4><p>UC1: SW Partitioning</p><blockquote><p>By placing each application requiring protection in an OS-Application, partitioning between applications is achieved. Possible reactions to errors include terminating and restarting of the affected partition. UC1 is therefore fully covered.</p></blockquote><p>把 SW 放在不同的 OS-Application 可以实现软件分区</p><h2 id="integrator-responsibility"><a class="anchor" href="#integrator-responsibility">#</a> Integrator Responsibility</h2><p>大白话就是拆分 sw-c 分不同的区，设定好保护的规则和钩子，设定好 cleanup 的行为。</p><h1 id="cdddesignandintegrationguideline"><a class="anchor" href="#cdddesignandintegrationguideline">#</a> CDDDesignAndIntegrationGuideline</h1><h2 id="introduction-to-cdd"><a class="anchor" href="#introduction-to-cdd">#</a> Introduction to CDD</h2><ul><li>A CDD may need to interface to modules of the layered software architecture</li><li>A module of the layered software architecture may need to interface to a CDD</li><li>A CDD may need to interface SW-Cs via Rte</li><li>都是简单的单词，很好理解，我就懒得翻译了略略略</li></ul><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708161654767.png" alt="image-20240708161654767"></p><h2 id="cdd-design-recommendations"><a class="anchor" href="#cdd-design-recommendations">#</a> CDD design recommendations</h2><p>CDD 的设计建议</p><h3 id="documentations"><a class="anchor" href="#documentations">#</a> Documentations</h3><p><strong>User’s Manual</strong></p><p>CDD designer shall provide a User’s Manual to ease the integration and provide information to customers:</p><p>要提供手册，手册里要有这些内容哦</p><ul><li>CDD introduction and overviewCDD<ul><li>简介和概述</li></ul></li><li>Description of the functional operations (initialisation, normal, shutdown, fault operation...)<ul><li>功能操作描述</li></ul></li><li>Description of the relationship with and need from other BSW Modules, SchM and Rte; e.g. memory blocks from NvM, critical sections to configure.<ul><li>描述与其他 BSW 模块、SchM 和 Rte 的关系</li></ul></li><li>Files structure and dependencies<ul><li>文件结构和依赖关系</li></ul></li><li>Description of the interfaces (including services): name, description, re-entrancy, parameters (names, types, ranges, values), return value (name, type, range, values), configuration class.</li><li>Description of the non-functional requirements: timing and behaviour requirements, resource usage, behaviour with other BSW modules or SW-C...<ul><li>描述时间啊行为的要求、资源使用情况、与其他 BSW 模块或 SWC 的行为</li></ul></li><li>Description of the Dem errors, optionally Det errors, debug variables<ul><li>描述 Dem 错误</li></ul></li><li>Description of the configuration parameters (names, types, ranges, values).<ul><li>配置参数的描述</li></ul></li><li>Description of the memory mapping needs (Flash, RAM)<ul><li>描述内存映射需求</li></ul></li><li>Usage limitations and open issues<ul><li>使用限制和未解决的问题</li></ul></li><li>Integration constraints and requirements to other modules<ul><li>集成的制约因素和对其他模块的要求</li></ul></li><li>Examples<ul><li>例子</li></ul></li></ul><p><strong>Module ID</strong></p><h3 id="implementation"><a class="anchor" href="#implementation">#</a> Implementation</h3><ul><li>CDD shall respect the input specifications [2], [3], [5], [6], [7], [8], [9], [10].</li><li>CDD shall protect its critical resources defining critical sections which can be handled by SchM or OS mechanisms.<ul><li>CDD 应保护其关键资源，界定可由 SchM 或 OS 机制处理的关键部分。</li></ul></li><li>CDD mode may be manageable by EcuM and BswM modules.<ul><li>CDD 模式可通过 EcuM 和 BswM 模块进行管理</li></ul></li><li>CDD may handle its memory sections using the memory mapping mechanisms.<ul><li>CDD 可以使用内存映射机制来处理其内存部分</li></ul></li><li>CDD may report its errors using Det or Dem modules.<ul><li>CDD 可使用 Det 或 Dem 模块报告其错误</li></ul></li></ul><h3 id="cdd-files"><a class="anchor" href="#cdd-files">#</a> CDD Files</h3><p><strong>Code file(s)</strong></p><ul><li>CDD_&lt;MODULENAME&gt;.c</li><li>CDD_&lt;MODULENAME&gt;_Irq.c</li><li>CDD_&lt;MODULENAME&gt;_Callout.c</li><li>CDD_&lt;MODULENAME&gt;_Lcfg.c</li><li>CDD_&lt;MODULENAME&gt;_PBcfg.c</li></ul><p><strong>Header file(s)</strong></p><ul><li>CDD_&lt;MODULENAME&gt;.h</li><li>CDD_&lt;MODULENAME&gt;_Cbk.h</li><li>CDD_&lt;MODULENAME&gt;_Cfg.h</li><li>CDD_&lt;MODULENAME&gt;_PBcfg.h</li><li>CDD_&lt;MODULENAME&gt;_Lcfg.h</li></ul><blockquote><p>CDD module may include <strong>Det.h</strong> and/or <strong>Dem.h</strong> header files to report errors.</p><p>CDD module may include <strong>&lt;Mip&gt;_MemMap.h</strong> header file if some memory mapping area have to be defined where &lt;Mip&gt; is the Module Implementation Prefix.</p><p>CDD module may include <strong>Rte_CDD_&lt;MODULENAME&gt;.h</strong> header file if interfaces to the Rte are configured.</p></blockquote><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240708162709924.png" alt="image-20240708162709924"></p><p>文件结构</p><h3 id="behaviour-and-interfaces-description"><a class="anchor" href="#behaviour-and-interfaces-description">#</a> Behaviour and Interfaces description</h3><blockquote><p>Some CDD not only have interfaces to other BSW modules or clusters, but have also more abstract interfaces accessed from application SW-Cs via the Rte.</p></blockquote><p>一些 CDD 不仅具有与其他 BSW 模块或集群的接口，而且还具有通过 Rte 从应用程序 SWC 访问的更抽象的接口。</p><ul><li>Description of the CDD services</li><li>Types and ports interfaces</li><li>Description of internal behaviour and runnable Entities</li><li>Description of the required triggered events of runnable Entities</li><li>Description of exclusive Areas for shared resources protection</li><li>Memory mapping</li></ul><h2 id="interfacing-to-other-modules"><a class="anchor" href="#interfacing-to-other-modules">#</a> Interfacing to other modules</h2><ul><li>Interfacing to Rte and SW-C</li><li>Interfacing to libraries</li><li>Interfacing to standard BSW modules<ul><li>CDD shall provide all configuration parameters which are necessary to satisfy other AUTOSAR modules which rely on the information,</li><li>依赖注入</li></ul></li></ul><h3 id="interfacing-to-standard-bsw-modules"><a class="anchor" href="#interfacing-to-standard-bsw-modules">#</a> Interfacing to standard BSW modules</h3><p><strong>Interfacing with BSW Mode Manager &amp; ECU State Manager</strong></p><p>ECU State Manager should be used for:</p><ul><li>Init and De-Init functions shall be exclusively called by the EcuM and/or the BswM modules.</li><li>If a CDD handles a wakeup source, it must follow the protocol for handling wakeup events specified in the document [11] <em>Specification of ECU State Manager</em>.</li></ul><p>BSW Mode Manager should be used for:</p><ul><li>CDD modes changed management</li></ul><p><strong>Interfacing with Memory Stack</strong></p><p><strong>Interfacing with Watchdog Stack</strong></p><p><strong>Interfacing with Communication Stack</strong></p><p>Several access points are possible:</p><ul><li>It is possible to interface to the PDU Router module to handle IPDU.</li><li>It is possible to interface to the &lt;Bus&gt; Interface.</li><li>It is possible to interface to the NM module.</li><li>It is possible to interface the TcpIp module.</li><li>It is possible to directly interface to Com module as it is possible to have signal interface.</li></ul><p><strong>Interfacing with XCP module</strong></p><p><strong>Interfacing with Diagnostic Log and Trace</strong></p><p><strong>Interfacing with Default Error Tracer and Diagnostic Event Manager</strong></p><p><strong>Interfacing with OS</strong></p><p><strong>Interfacing with StbM module</strong></p><p><strong>CDD in multi-cores system</strong></p><p><strong>CDD module of the MCAL</strong></p><h1 id="standardtypes"><a class="anchor" href="#standardtypes">#</a> StandardTypes</h1><p>Type definitions</p><p><strong>Std_ReturnType</strong></p><p><strong>[SWS_Std_00005] Definition of datatype Std_ReturnType</strong></p><blockquote><p>Layout of the Std_ReturnType shall be as stated in the RTE specification. Bit 7 and Bit 8 are reserved and defined by the RTE specification.</p></blockquote><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240719145428961.png" alt="image-20240719145428961"></p><p>返回值类型 Std_ReturnType</p><p>也就是说这两个是 RTE 的哦</p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240803232835895.png" alt="image-20240803232835895"></p><h1 id="platformtypes"><a class="anchor" href="#platformtypes">#</a> PlatformTypes</h1><p><strong>Byte Ordering (Memory)</strong></p><p>Big Endian byte ordering 大端</p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240719141259118.png" alt="image-20240719141259118"></p><p>Little Endian byte ordering 小端</p><p><img data-src="../../../img.assets/24-07-14%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0AutoSar%E7%B3%BB%E5%88%97%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%87%EF%BC%882%EF%BC%89BSWGeneral/image-20240719141331302.png" alt="image-20240719141331302"></p><h1 id="communicationstacktypes"><a class="anchor" href="#communicationstacktypes">#</a> CommunicationStackTypes</h1><h2 id="api-specification-type-definitions"><a class="anchor" href="#api-specification-type-definitions">#</a> API specification Type definitions</h2><ul><li><p>PduIdType</p><ul><li><strong>[SWS_COMTYPE_00005] Definition of datatype PduIdType</strong></li><li>This type is used within the entire AUTOSAR Com Stack except for bus drivers.</li></ul></li><li><p>PduLengthType</p><ul><li><strong>[SWS_COMTYPE_00008] Definition of datatype PduLengthType</strong></li><li>This type shall be used within the entire AUTOSAR Com Stack of an ECU except for bus drivers.</li></ul></li><li><p>PduInfoType</p><ul><li><strong>[SWS_COMTYPE_00011] Definition of datatype PduInfoType</strong></li><li>Variables of this type shall be used to store the basic information about a PDU of any type, namely a pointer variable pointing to its SDU (payload), a pointer to Meta Data of the PDU, and the corresponding length of the SDU in bytes.</li></ul></li><li><p>PNCHandleType</p><ul><li><strong>[SWS_COMTYPE_00036] Definition of datatype PNCHandleType</strong></li><li>Used to store the identifier of a partial network cluster.</li></ul></li><li><p>TPParameterType</p><ul><li><strong>[SWS_COMTYPE_00031] Definition of datatype TPParameterType</strong></li><li>Specify the parameter to which the value has to be changed (BS or STmin).</li></ul></li><li><p>BufReq_ReturnType</p><ul><li><strong>[SWS_COMTYPE_00012] Definition of datatype BufReq_ReturnType</strong></li><li>Variables of this type shall be used to store the result of a buffer request.</li></ul></li><li><p>TpDataStateType</p><ul><li><strong>[SWS_COMTYPE_00027] Definition of datatype TpDataStateType</strong></li><li>Variables of this type shall be used to store the state of TP buffer</li></ul></li><li><p>RetryInfoType</p><ul><li><strong>[SWS_COMTYPE_00037] Definition of datatype RetryInfoType</strong></li><li>Variables of this type shall be used to store the information about Tp buffer handling.</li></ul></li><li><p>NetworkHandleType</p><ul><li><strong>[SWS_COMTYPE_00037] Definition of datatype RetryInfoType</strong></li><li>Variables of this type shall be used to store the information about Tp buffer handling.</li></ul></li><li><p>CbkHandleIdType</p><ul><li><strong draft="">[SWS_COMTYPE_91001]</strong> <strong>Definition of datatype CbkHandleIdType</strong></li><li>Used for the handle Ids of Com and LdCom user callbacks.</li></ul></li><li><p>TimeTupleType</p><ul><li><p><strong draft="">[SWS_COMTYPE_91002]</strong> <strong>Definition of datatype TimeTupleType</strong></p></li><li><p>The Time Tuple represents the clock values of two related HW clocks</p><ul><li>the value of the clock used for timestamping of frame</li><li>and the corresponding value of the adjustable HW clock, derived by cross-timestamping</li></ul></li></ul></li><li><p>TimeStampType</p><ul><li><strong draft="">[SWS_COMTYPE_91003]</strong> <strong>Definition of datatype TimeStampType</strong></li></ul></li><li><p>TimeStampQualType</p><ul><li><strong draft="">[SWS_COMTYPE_91004]</strong> <strong>Definition of datatype TimeStampQualType</strong></li><li>Depending on the HW, quality information regarding the evaluated timestamp might be supported. If not supported, the value shall be always Valid. For Uncertain and Invalid values, the upper layer shall discard the time stamp.</li></ul></li><li><p>ListElemStructType</p><ul><li><strong draft="">[SWS_COMTYPE_91005]</strong> <strong>Definition of datatype ListElemStructType</strong></li></ul><p>反正是很多类型哈哈哈</p><p>结束啦宝！睡觉🛏️</p></li></ul><div class="tags"><a href="/tags/AUTOSAR/" rel="tag"><i class="ic i-tag"></i> AUTOSAR</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-09-22 10:34:00" itemprop="dateModified" datetime="2024-09-22T10:34:00+08:00">2024-09-22</time> </span><span id="archives/db4ff6ff.html" class="item leancloud_visitors" data-flag-title="小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="flechazo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="flechazo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="flechazo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>flechazo <i class="ic i-at"><em>@</em></i>我在人间贩卖黄昏，只为收集世间温柔遇见你.</li><li class="link"><strong>本文链接：</strong> <a href="https://flechazoclf.github.io/FlechazoCLF.github.io/archives/db4ff6ff.html" title="小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral">https://flechazoclf.github.io/FlechazoCLF.github.io/archives/db4ff6ff.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/archives/962e9003.html" itemprop="url" rel="prev" data-background-image="/archives/962e9003.html../../../wallpaper/8.png" title="小柴带你学习AutoSar系列三、标准和规范篇（1）General"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> AUTOSAR</span><h3>小柴带你学习AutoSar系列三、标准和规范篇（1）General</h3></a></div><div class="item right"><a href="/archives/38a44ca9.html" itemprop="url" rel="next" data-background-image="/archives/38a44ca9.html../../../wallpaper/6.png" title="医院检查身体单子记录"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 自我提升</span><h3>医院检查身体单子记录</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%9F%B4%E5%B8%A6%E4%BD%A0%E5%AD%A6autosar%E7%B3%BB%E5%88%97%E4%B8%89-%E6%A0%87%E5%87%86%E5%92%8C%E8%A7%84%E8%8C%83%E7%AF%872bswgeneral"><span class="toc-number">1.</span> <span class="toc-text">小柴带你学 AutoSar 系列三、标准和规范篇（2）BSWGeneral</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bswdistributionguide"><span class="toc-number">2.</span> <span class="toc-text">BSWDistributionGuide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bsw%E5%9C%A8autosar%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%BF%99%E9%87%8C%E5%93%A6"><span class="toc-number">2.1.</span> <span class="toc-text">BSW 在 AUTOSAR 架构中的这里哦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bsw-distribution-in-multi-core-systems"><span class="toc-number">2.2.</span> <span class="toc-text">BSW Distribution in Multi-Core Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parallel-execution-of-bsw-modules"><span class="toc-number">2.3.</span> <span class="toc-text">Parallel Execution of BSW modules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#core-dependent-branching"><span class="toc-number">2.3.1.</span> <span class="toc-text">Core-Dependent Branching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-shared-buffers-in-systems-without-memory-protection"><span class="toc-number">2.3.2.</span> <span class="toc-text">Using Shared Buffers (in systems without memory protection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrency-safe-implementation-of-modules"><span class="toc-number">2.3.3.</span> <span class="toc-text">Concurrency safe implementation of modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel-based-master-satellite-realization"><span class="toc-number">2.3.4.</span> <span class="toc-text">Kernel based Master-Satellite Realization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-operations-library"><span class="toc-number">2.3.5.</span> <span class="toc-text">Atomic Operations Library</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#schm-interfaces-for-parallel-bsw-execution"><span class="toc-number">2.4.</span> <span class="toc-text">SchM Interfaces for Parallel BSW execution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#configuration-of-basic-software-in-partitioned-systems"><span class="toc-number">2.5.</span> <span class="toc-text">Configuration of Basic Software in Partitioned Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#task-mapping"><span class="toc-number">2.5.1.</span> <span class="toc-text">Task Mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#general-configuration-of-master-and-satellites"><span class="toc-number">2.5.2.</span> <span class="toc-text">General Configuration of Master and Satellites</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#configuring-the-bswm-per-partition"><span class="toc-number">2.5.3.</span> <span class="toc-text">Configuring the BswM (per Partition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#configuring-the-ecum-per-core"><span class="toc-number">2.5.4.</span> <span class="toc-text">Configuring the EcuM (per Core)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mcal-distribution"><span class="toc-number">2.6.</span> <span class="toc-text">MCAL Distribution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#introduction"><span class="toc-number">2.6.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#criteria"><span class="toc-number">2.6.2.</span> <span class="toc-text">Criteria</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#com-stack-distribution"><span class="toc-number">2.7.</span> <span class="toc-text">Com-Stack Distribution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bsw-distribution-in-safety-systems"><span class="toc-number">2.8.</span> <span class="toc-text">BSW Distribution in Safety Systems</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bswgeneral"><span class="toc-number">3.</span> <span class="toc-text">BSWGeneral</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#requirements-specification"><span class="toc-number">3.1.</span> <span class="toc-text">Requirements Specification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#functional-overview"><span class="toc-number">3.2.</span> <span class="toc-text">Functional Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#functional-requirements"><span class="toc-number">3.3.</span> <span class="toc-text">Functional Requirements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#configuration"><span class="toc-number">3.3.1.</span> <span class="toc-text">Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wake-up"><span class="toc-number">3.3.2.</span> <span class="toc-text">Wake-Up</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initialization"><span class="toc-number">3.3.3.</span> <span class="toc-text">Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#normal-operation"><span class="toc-number">3.3.4.</span> <span class="toc-text">Normal Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-operation"><span class="toc-number">3.3.5.</span> <span class="toc-text">Shutdown Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fault-operation-and-error-detection"><span class="toc-number">3.3.6.</span> <span class="toc-text">Fault Operation and Error Detection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#non-functional-requirements-qualities"><span class="toc-number">3.4.</span> <span class="toc-text">Non-Functional Requirements (Qualities)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#software-architecture-requirements"><span class="toc-number">3.4.1.</span> <span class="toc-text">Software Architecture Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#software-integration-requirements"><span class="toc-number">3.4.2.</span> <span class="toc-text">Software Integration Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#software-module-design-requirements"><span class="toc-number">3.4.3.</span> <span class="toc-text">Software Module Design Requirements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#software-documentation-requirements"><span class="toc-number">3.4.4.</span> <span class="toc-text">Software Documentation Requirements</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#errordescription"><span class="toc-number">4.</span> <span class="toc-text">ErrorDescription</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-mechanisms"><span class="toc-number">4.1.</span> <span class="toc-text">Generic Mechanisms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#report-to-the-diagnostic-event-manager-dem"><span class="toc-number">4.1.1.</span> <span class="toc-text">Report to the Diagnostic Event Manager (DEM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diagnostic-event-manager"><span class="toc-number">4.1.2.</span> <span class="toc-text">Diagnostic Event Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#det"><span class="toc-number">4.1.3.</span> <span class="toc-text">DET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function-inhibition-manager"><span class="toc-number">4.1.4.</span> <span class="toc-text">Function Inhibition Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rte"><span class="toc-number">4.1.5.</span> <span class="toc-text">RTE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#communication-related-errors"><span class="toc-number">4.2.</span> <span class="toc-text">Communication related errors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overview"><span class="toc-number">4.2.1.</span> <span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#error-handling-mechanisms"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">Error handling mechanisms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error-list-for-can-stack"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Error list for CAN stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mappings-of-eh-mechanisms-to-hardware-failure-modes"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">Mappings of EH mechanisms to hardware failure modes</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loss-of-communication-channel"><span class="toc-number">4.2.2.</span> <span class="toc-text">Loss of communication channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#can-bus-off"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">CAN Bus Off</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#summary"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">Summary</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#roles-of-the-modules"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">Roles of the modules</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#can-controller-hardware-timeout"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">CAN Controller Hardware Timeout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#roles-of-the-modules-2"><span class="toc-number">4.2.2.2.1.</span> <span class="toc-text">Roles of the modules</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signal-error"><span class="toc-number">4.2.3.</span> <span class="toc-text">Signal error</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#can-transmission-buffer-full"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">CAN Transmission buffer full</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#roles-of-the-modules-3"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">Roles of the modules</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#can-reception-dlc-error"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">CAN Reception DLC error</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#roles-of-the-modules-4"><span class="toc-number">4.2.3.2.1.</span> <span class="toc-text">Roles of the modules</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#com-rx-deadline-monitoring"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">COM RX Deadline Monitoring</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#roles-of-the-modules-5"><span class="toc-number">4.2.3.3.1.</span> <span class="toc-text">Roles of the modules</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#can-transport-protocol-error-during-transmission"><span class="toc-number">4.2.3.4.</span> <span class="toc-text">CAN Transport Protocol error during transmission</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#can-transport-protocol-error-during-reception"><span class="toc-number">4.2.3.5.</span> <span class="toc-text">CAN Transport Protocol error during reception</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client-server-timeout"><span class="toc-number">4.2.3.6.</span> <span class="toc-text">Client / Server timeout</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nvram-related-errors"><span class="toc-number">4.3.</span> <span class="toc-text">NVRAM related errors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overview-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#error-handling-mechanisms-2"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">Error handling mechanisms</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#driver-level-errors"><span class="toc-number">4.3.2.</span> <span class="toc-text">Driver level errors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flash-write-job-error"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">Flash write job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flash-erase-job-error"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">Flash erase job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flash-read-job-error"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">Flash read job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flash-compare-job-error"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">Flash compare job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#external-flash-hardware-id-mismatch"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">External Flash Hardware ID Mismatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eeprom-write-job-error"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">EEPROM write job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eeprom-erase-job-error"><span class="toc-number">4.3.2.7.</span> <span class="toc-text">EEPROM erase job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eeprom-read-job-error"><span class="toc-number">4.3.2.8.</span> <span class="toc-text">EEPROM read job error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eeprom-compare-job-error"><span class="toc-number">4.3.2.9.</span> <span class="toc-text">EEPROM compare job error</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eeprom-abstraction-flash-emulation-level-errors"><span class="toc-number">4.3.3.</span> <span class="toc-text">EEPROM Abstraction / Flash Emulation level errors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fee-consistency-check-error"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">FEE consistency check error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ea-consistency-check-error"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">EA consistency check error</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nvram-manager-level-errors"><span class="toc-number">4.3.4.</span> <span class="toc-text">NVRAM manager level errors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nvm-crc-check"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">NVM CRC check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nvm-write-verification-error"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">NVM write verification error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-block-check-error"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">Static block check error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loss-of-redundancy"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">Loss of redundancy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nvm-api-request-failure"><span class="toc-number">4.3.4.5.</span> <span class="toc-text">NVM API request failure</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#applicationlevelerrorhandling"><span class="toc-number">5.</span> <span class="toc-text">ApplicationLevelErrorHandling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#error-model"><span class="toc-number">5.1.</span> <span class="toc-text">Error model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-handling-mechanisms-3"><span class="toc-number">5.2.</span> <span class="toc-text">Error handling mechanisms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#terminating-and-restarting-partitions"><span class="toc-number">5.3.</span> <span class="toc-text">Terminating and restarting partitions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rationale-use-cases"><span class="toc-number">5.3.1.</span> <span class="toc-text">Rationale - Use Cases</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#use-case-1-software-partitioning-uc1"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">Use Case 1: Software Partitioning [UC1]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#use-case-2-application-level-error-handling-uc2"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">Use Case 2: Application-level Error Handling [UC2]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#error-handling-of-distributed-automotive-applications"><span class="toc-number">5.3.1.2.1.</span> <span class="toc-text">Error handling of distributed automotive applications</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#oem-specific-error-handling"><span class="toc-number">5.3.1.2.2.</span> <span class="toc-text">OEM-specific error handling</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#application-level-error-managers"><span class="toc-number">5.3.1.2.3.</span> <span class="toc-text">Application-level Error Managers</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#approach-for-terminating-and-restarting-partitions"><span class="toc-number">5.3.2.</span> <span class="toc-text">Approach for Terminating and Restarting Partitions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#os-features"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">OS features</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#support-for-use-cases"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">Support for Use Cases</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#integrator-responsibility"><span class="toc-number">5.4.</span> <span class="toc-text">Integrator Responsibility</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cdddesignandintegrationguideline"><span class="toc-number">6.</span> <span class="toc-text">CDDDesignAndIntegrationGuideline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction-to-cdd"><span class="toc-number">6.1.</span> <span class="toc-text">Introduction to CDD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cdd-design-recommendations"><span class="toc-number">6.2.</span> <span class="toc-text">CDD design recommendations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#documentations"><span class="toc-number">6.2.1.</span> <span class="toc-text">Documentations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implementation"><span class="toc-number">6.2.2.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cdd-files"><span class="toc-number">6.2.3.</span> <span class="toc-text">CDD Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#behaviour-and-interfaces-description"><span class="toc-number">6.2.4.</span> <span class="toc-text">Behaviour and Interfaces description</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interfacing-to-other-modules"><span class="toc-number">6.3.</span> <span class="toc-text">Interfacing to other modules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interfacing-to-standard-bsw-modules"><span class="toc-number">6.3.1.</span> <span class="toc-text">Interfacing to standard BSW modules</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#standardtypes"><span class="toc-number">7.</span> <span class="toc-text">StandardTypes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#platformtypes"><span class="toc-number">8.</span> <span class="toc-text">PlatformTypes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#communicationstacktypes"><span class="toc-number">9.</span> <span class="toc-text">CommunicationStackTypes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#api-specification-type-definitions"><span class="toc-number">9.1.</span> <span class="toc-text">API specification Type definitions</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/archives/dfcb5141.html" rel="bookmark" title="LD文件在AUTOSAR工程中的作用和语法解析">LD文件在AUTOSAR工程中的作用和语法解析</a></li><li><a href="/archives/cbed58a6.html" rel="bookmark" title="小柴带你学AutoSar总目录">小柴带你学AutoSar总目录</a></li><li><a href="/archives/b20010d9.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（1）概念和目标">小柴带你学AutoSar系列一、基础知识篇（1）概念和目标</a></li><li><a href="/archives/e0c2534f.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement">小柴带你学AutoSar系列三、标准和规范篇（5）CommunicationManagement</a></li><li><a href="/archives/e8a5cc27.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构">小柴带你学AutoSar系列一、基础知识篇（2）AutoSar架构</a></li><li><a href="/archives/e8bc299.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（5）makefile基础">小柴带你学AutoSar系列一、基础知识篇（5）makefile基础</a></li><li><a href="/archives/5e71c9a6.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（3）C语言基础">小柴带你学AutoSar系列一、基础知识篇（3）C语言基础</a></li><li><a href="/archives/7cac95ec.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（4）编译">小柴带你学AutoSar系列一、基础知识篇（4）编译</a></li><li><a href="/archives/3c7f112.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850">小柴带你学AutoSar系列一、基础知识篇（6）车规级MCU入门RH850</a></li><li><a href="/archives/3f4a19e2.html" rel="bookmark" title="小柴带你学AutoSar系列一、基础知识篇（7）术语">小柴带你学AutoSar系列一、基础知识篇（7）术语</a></li><li><a href="/archives/962e9003.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（1）General">小柴带你学习AutoSar系列三、标准和规范篇（1）General</a></li><li class="active"><a href="/archives/db4ff6ff.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral">小柴带你学习AutoSar系列三、标准和规范篇（2）BSWGeneral</a></li><li><a href="/archives/c9ca48bd.html" rel="bookmark" title="小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement">小柴带你学习AutoSar系列三、标准和规范篇（3）ModeManagement</a></li><li><a href="/archives/fd244a42.html" rel="bookmark" title="小柴带你学AutoSar系列三、标准和规范篇（4）RTE">小柴带你学AutoSar系列三、标准和规范篇（4）RTE</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="flechazo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">flechazo</p><div class="description" itemprop="description">我在人间贩卖星光</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">192</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">44</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">41</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fnb25pMzdD" title="https://github.com/Agoni37C"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaXVfc2hlbmc=" title="https://www.zhihu.com/people/jiu_sheng"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvcGxheWxpc3Q/aWQ9NzE3NTI4NzIwNQ==" title="https://music.163.com/#/playlist?id=7175287205"><i class="ic i-cloud-music"></i></span> <span class="exturl item weixin" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vbXAvaG9tZXBhZ2U/X19iaXo9TXpBeE9ETTJOVFEwTnc9PSZoaWQ9MiZzbj05ZThkZGVkOGU3MTgxYTA4YTA1MjFiOTQ2MjIyY2Q3MiZzY2VuZT0xOCN3ZWNoYXRfcmVkaXJlY3Q=" title="http://mp.weixin.qq.com/mp/homepage?__biz=MzAxODM2NTQ0Nw==&amp;hid=2&amp;sn=9e8dded8e7181a08a0521b946222cd72&amp;scene=18#wechat_redirect"><i class="ic i-address-card"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDQxODc1ODQ0P3NwbV9pZF9mcm9tPTMzMy4xMDA3LjAuMA==" title="https://space.bilibili.com/441875844?spm_id_from=333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAwLw=="><i class="ic i-home"></i>首页</span></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>小伙伴们</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAxLw=="><i class="ic i-magic"></i>导航页🚀</span></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>小天地🍼</a><ul class="submenu"><li class="item"><a href="/broken-thoughts/" rel="section"><i class="ic i-heart"></i>碎碎念</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAyLw=="><i class="ic i-heart"></i>云小🎪盘</span></li><li class="item"><a href="/mypages/Videoparse/" rel="section"><i class="ic i-heart"></i>视频解析</a></li><li class="item"><a href="/movies/" rel="section"><i class="ic i-heart"></i>影集</a></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA5Lw=="><i class="ic i-heart"></i>游戏🎮小站</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDA2Lw=="><i class="ic i-heart"></i>动感天地🎶</span></li><li class="item"><span class="exturl" data-url="aHR0cDovLzEyMS4zNy4xNi4zMDo4MDAzLw=="><i class="ic i-heart"></i>4k壁纸❄</span></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>有趣单页</a><ul class="submenu"><li class="item"><a href="/mypageslayout/barrage/" rel="section"><i class="ic i-list-alt"></i>弹幕墙</a></li><li class="item"><a href="/mypages/crossing-the-cliff/" rel="section"><i class="ic i-th"></i>圣诞老人过桥</a></li><li class="item"><a href="/mypages/eat/" rel="section"><i class="ic i-tags"></i>今天吃什么</a></li><li class="item"><a href="/mypages/clock/" rel="section"><i class="ic i-list-alt"></i>好看的闹钟</a></li><li class="item"><a href="/mypages/QQpage/" rel="section"><i class="ic i-list-alt"></i>QQ展示页</a></li><li class="item"><a href="/mypages/jianli/" rel="section"><i class="ic i-th"></i>简历</a></li><li class="item"><a href="/mypages/love/" rel="section"><i class="ic i-tags"></i>执子之手</a></li><li class="item"><a href="/mypages/tiangou/" rel="section"><i class="ic i-list-alt"></i>舔狗语录</a></li><li class="item"><a href="/mypages/washing/" rel="section"><i class="ic i-th"></i>洗衣机</a></li><li class="item"><a href="/mypages/todolist/" rel="section"><i class="ic i-tags"></i>行动清单</a></li><li class="item"><a href="/mypages/yindao2/" rel="section"><i class="ic i-list-alt"></i>引导页</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/archives/962e9003.html" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/archives/38a44ca9.html" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/tools/" title="分类于 实用小工具">实用小工具</a></div><span><a href="/archives/cf625652.html" title="⛄常用的超级方便的工具☃">⛄常用的超级方便的工具☃</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/c3251f5b.html" title="小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理">小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/fb6a2cb8.html" title="小柴冲刺软考中级嵌入式系统设计师系列二、嵌入式系统硬件基础知识（7）嵌入式Soc">小柴冲刺软考中级嵌入式系统设计师系列二、嵌入式系统硬件基础知识（7）嵌入式Soc</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/QT/" title="分类于 QT">QT</a></div><span><a href="/archives/85c52c40.html" title="串口通信中的接收与发送队列处理大数据">串口通信中的接收与发送队列处理大数据</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blog/" title="分类于 blog🌮">blog🌮</a> <i class="ic i-angle-right"></i> <a href="/categories/blog/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/archives/dfd13216.html" title="🥚markdown页内跳转🥚">🥚markdown页内跳转🥚</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/ea275efd.html" title="小柴冲刺软考中级嵌入式系统设计师系列一、计算机系统基础知识（5）计算机体系结构">小柴冲刺软考中级嵌入式系统设计师系列一、计算机系统基础知识（5）计算机体系结构</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%B8%88/" title="分类于 嵌入式系统设计师">嵌入式系统设计师</a></div><span><a href="/archives/c3251f5b.html" title="小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理">小柴冲刺软考中级嵌入式系统设计师系列三、嵌入式硬件设计（1）嵌入式系统电源管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/english/" title="分类于 english">english</a> <i class="ic i-angle-right"></i> <a href="/categories/english/%E6%81%8B%E6%81%8B%E6%9C%89%E8%AF%8D/" title="分类于 恋恋有词">恋恋有词</a></div><span><a href="/archives/6b9688b3.html" title="🥩恋恋有词-高频核心词-unit01">🥩恋恋有词-高频核心词-unit01</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/GD32/" title="分类于 GD32">GD32</a></div><span><a href="/archives/9b195eb4.html" title="一个Led呼吸灯驱动">一个Led呼吸灯驱动</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/technique/" title="分类于 技术教程🎃">技术教程🎃</a> <i class="ic i-angle-right"></i> <a href="/categories/technique/QT/" title="分类于 QT">QT</a></div><span><a href="/archives/cd721bd1.html" title="QTsocket连接">QTsocket连接</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">© 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">flechazo @ flechazo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">906k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">13:44</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> &amp; Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL={path:"archives/db4ff6ff.html",favicon:{show:"flechazo",hide:"(´Д｀)客官别走！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html><!-- rebuild by hrmmi -->